
Marco Cantù  
 
Object Pascal Handbook  
 
 
 
 
The Complete Guide to the Object Pascal programming 
language for Delphi and AppMethod developers   
 
 
Piacenza (Italy), July 2015   
  
 Author: Marco Cantù   
Publisher: Marco Cantù   
Editor: Peter W A Wood   
Cover D esigner: Fabrizio Schiavi (www.fsd.it)   
 
Copyright 1995 -2015 Marco Cantù, Piacenza, Italy. World 
rights reserved.   
The author created example code in this publication expressly for the free use by its 
readers. Source code for this book is copyrighted freew are, distributed via the web 
site http://code.marcocantu.com . The copy - right prevents you from 
republishing the code in print or electronic media without permission. Readers are 
granted limited permission to use this code in their applications, as long at  the code 
itself is not distributed, sold, or commercially exploited as a stand -alone product.   
Aside from this specific exception concerning source code, no part of this publication 
may be stored in a retrieval system, transmitted, or reproduced in any wa y, in the 
original or in a translated language, including but not limited to photocopy, 
photograph, magnetic, or other record, without the prior agreement and writ - ten 
permission of the publisher.   
Delphi and Appmethod are trademarks of Embarcadero Techno logies. Other 
trademarks are of the respective owners, as referenced in the text. Whilst the author 
and publisher have made their best efforts to prepare this book, they make no 
representation or warranties of any kind with regard to the completeness or ac curacy 
of the contents herein and accepts no liability of any kind including but not limited to 
performance, mer - chantability, fitness for any particular purpose, or any losses or 
damages of any kind caused or alleged to be caused directly or indirectly f rom this 
book.   
 
Object Pascal Handbook   
ISBN -10: 1514349949   
ISBN -13: 978 -1514349946   
 
The electronic edition of this book has been licensed to Embarcadero 
Technologies Inc and it is also sold directly by the author. Any other download 
or sale outlet is l ikely to be illegal. Do not distribute the PDF version of this 
book without permission. The printed edition is self -published through 
CreateSpace Inc and sold in several online outlets.   
More information on 
http://www.marcocantu.com/objectpascal 
 1  
begin   
 
功能强大且简单、容易表达又具可读性、初学者跟专业人员都能快速熟悉，
这些就是今日 Object Pascal 的部份特点。  
 
Object Pascal 历久弥新，不断向前演进，而演进至今，更具备了多种不同面
向，它结合了面向对象程序语言的强大、泛型程序的高阶功能，以及动态
结构特性  (anonymous function 等结构化的程序区块 )， 却也没有舍弃许多程
序化语言的传统特性。 Object Pascal 适合所有行业，是一个在行动时代具备
编译功能的开发工具，更是一个具备坚强历史，已经准备好面对未来挑战
的程序语言。  
 
Object Pascal 是为了开发什么特定功能而存在的 ? 从单机桌面到主从式架
构应用程序，从大量处理数据的 web模块到中间件，从办公室自动化到最
新的行动装置 (手机与平板 app)的开发， 从工厂自动化系统到网际 /移动电话
虚拟网络等等，这些都不是这个语言被设计准备来处理的领域，而是在今
日世界中， Object Pascal 这个语言已经实际在服务的领域，这就是 Object 
Pascal 强大的地方，它不是预期可以做这些事，而是已经做到了。  
 
我们今日使用的 Object Pascal 程序语言的核心，都是早在 1995年，那个程
序语言发展的黄金年代就已经定义好的， 在同一个年代， JA VA跟JA VAScript
也刚被开发出来。虽然 Object Pascal 语言的根基是在那么久以前就已经奠
定的， 而且还有更久以前的 Pascal语言， 这个程序语言的发展并没有在 1995
年停下脚步，直至今日，它的核心功能仍旧不断的在增强当中，我们可以
在Embarcadero 的Appmethod, Delphi 跟RAD Studio 当中这些功能在单机应
用程序与行动应用程序、编译程序与开发工具的领域中继续进步着。  
 
一本介绍现代程序语言的书  
随着程序语言的 角色不断变化，功能的延伸也逐年在发生，最终会反应在
程序语言会吸引新的开发人员。我觉得写一本能够完整介绍现代的 Object 
Pascal所涵盖的各个领域是很重要的。 这个目标是要让新进的开发人员能够
有语言的手册，让对其他相似语言熟悉的开发人员也能快速入门，也让在 
 2 过去的这些年里，对熟悉不同版本 Pascal的开发人员能快速的知道目前
Object Pascal 究竟有了什么发展。  
 
新进的开发人员当然需要一些基础，但在刚开始的章节中，即使是熟悉过
去不同版本 Object Pascal 的开发人员，一定也能得到一些新的心得。 我们
会以一个篇幅不长的附录来简单介绍 Object Pascal 语言的历史，其余的篇
幅则会着重在今日的 Object Pascal 。 
 
从早期的 Delphi开始，大多数的核心功能并没有很显著的变化，绝大多数
很重要的核心功能，早在 1995年第一版的 Delphi当中就已经奠定了基础。  
 
在我即将开始介绍的本书的内容当中，这个程序语言在这么多年的存在过
程中，并不是停滞不前的，它在过去的这段期间中，以相当快的速度在进
化着。  
 
在我过去其他的作品当中，我的介绍手法比较传统，首先会介绍最传统的
Pascal程序语言，接着或多 或少介绍一些在发展过程中被加入的延伸功能。
但在这本书里，我会直接切中主题，直接介绍今日我们怎么透过 Object 
Pascal解决问题，或者怎么用它最好，而不会介绍它一路走来是怎么演进的
了。  
 
举例来说，最近被提出的原生的数据型别具备面向对象特性中 method的功
能，可溯及原始 Pascal语言。这部份我在第二章里面就会直接介绍怎么使
用这个功能，而不会试图先让读者们理解这当中的设计运作原理。  
 
换句话说，这本书会着重在让读者们怎么在今时今日使用 Object Pascal ，从
基础引导、让读者们从做中学，只会提到最 低限度的历史发展。即使读者
们已经很熟悉这个语言了，应该还是会希望直接切入主题，至于历史的发
展与脉络，我们只在最后一章介绍。  
 
从做中学  
这本书的意旨，是要介绍核心概念，并透过很短的范例让读者立即进入状
况，透过这些范例，读者们可以试着执行、练习、并且自行摸索了解到概
念，并对这些概念有更深切的体认。  
 
这本书不会是一本参考手册，参考手册会解释这个程序语言在理论上该怎
么做，并列举所有可能的案例作为说明。而为了精确的介绍概念，本书会 
 3 透过一步步的实战练习，用范例来让读者学会 Object Pascal 这个语言。这
些范例都会很简单，因为我们的目标，是让读者一次专注在一个主题上面。  
完整的范例程序代码会放在一个 Subversion 的Repository 里面，而不是单
单一个提供给读者下载的 文件，这样一来，万一我更新了里面的程序代码，
或者有更进一步的范例时，读者就可以透过 Subversion 更新这些范例了。
读者们可以使用任何一个版本的 Subversion Client 端程序 (我自己是用
Windows 版的 TortoiseSVN ，图示是一只乌龟 )，把当中的网址指向底下这
个网址，就能取得本书的所有范例程序了 (或者您也可以分别下载您有兴 趣
的章节范例 )： 
    http://code.marcocantu.com/svn/marcocantu_objectpascalhandbook/  
 
这个 Repository 的原始码也可以从浏览器来阅读，您可以从以下的网址当
中，点选右上角的 Browse Source 连结：  
    http://code.marcocantu.com/trac/marcocantu_objectpascalhandbook   
 
要编译或者测试这些范例程序，您会需要能够使用的 Object Pascal 编译程
序，而且越新版 的越好，这样才能保证所有的范例程序都能正确编译。
Embarcadero 有提供试用版的 Delphi，通常都会有 30天的免费试用期。  
 
本书的网站  
我也为本书建立了一个网站，提供延伸阅读的信息、链接、更新，以及更
多目前不足的地方，您可以从以下的网址浏览传统网站：  
http://www.marcocantu.com/objectpascalhandbook   
 
或者从 Google+跟Facebook 与我互动 : 
     http://bit.ly/objectpascalgplus   
     https://w ww.facebook.com/objectpascalhandbook   
致谢 
每一本书的完成，总是要感谢很多人，我要感谢的人可以列成一个很长很长
的名单，首先，是为本书付出许多心血的编辑， Peter Wood 。由于一再修改
出书的时程， 以及帮我使用的许许多多的科技用语顺成一般读者可以读的懂
的语汇，感谢 Peter，协助我成就了本书。  
 
由于我目前担任 Emarcadero 的产品经理，我也亏欠所有跟我一起工作的同
仁，以及研发团队的成员，更要感谢在这段期间当中，所有曾经跟我谈话、
开会或透过 Email进行讨论的同仁们 ，让我能够对这个产品，以及当中的技 
 4 术有更深层的了解。  
我也要感谢在 Embarcadero 以外的许多人士， 包含在 Wintech Italia 论坛的成
员们，以及无法计数的顾客们， Embarcadero 的业务与技术伙伴、 Delphi社
群的伙伴们、 MVP们以及使用其他程序语言跟工具的开发人员们，我也持
续的在与他们进行交流。  
 
最后，我要深深的感谢我的家人们，因为我常变动的旅程、在夜间的会议，
以及许多个用在写书的周末时间，谢谢 Lella, Benedetta 跟Jacopo.  
 
关于我自己  
我叫做 Marco, 我在过去 的20年当中，花了大部分的时间来写作、教学，
以及提供 Object Pascal 这个程序语言开发的软件顾问工作上。 我过去曾写过
Master Delphi 系列的畅销作品， 后来则是自己发行了几本关于开发工具的工
具书，横跨了 Delphi 2007 到Delphi XE 这几个不同的版本。在几个大洲的
许多程序开发座谈会上，我都担任过主讲人，并协助数以百计的程序开发人
员。  
 
在从事了多年的独立软件顾问工作以及训练者之后，在 2013年，我的职业
生涯有了很突然的变化， 我接受了 Embarcadero 的邀请， 担任 Delphi及RAD 
Studio的产品经理。 Embarcadero 开发、销售这些很棒的开发工具，同时还
涵盖了最新的 Appmethod 产品。  
 
为了不再多占篇幅，我只再多说一点，我目前定居在意大利，通勤到美国加
州上班，有爱我的太太跟两个很棒的小孩，而且会尽我所能的享受回归程序
设计的乐趣。  
 
希望你阅读本书的时候能够乐在其中，就像我写书的时候一样 (这是我的第
19本着作 )，如果你需要更多信息，可以透过以下任何一个方式跟我联系 : 
http://www.marcocantu.com http://blog.marcocantu.co m 
http://twitter.com/marcocantu 
https://www.google.com/+MarcoCantu 
http://www.facebook.com/marcocantu   
 
Marco Cantù , Object Pascal 程序语言手册    
 5 {.译者的话 } 
这是译者的第五本书，和第四本书『 Delphi/Kylix Indy 网络程序设计』间隔
了十四年。写书从来 都是需要被鞭策的工作，也是极需要耐心的一项工作。
在这十四年之间，译者的工作一直跟研发相关，从 Windows 应用程序 到iOS
应用程序，虽然程序语言不断的成长，我们身为开发人员也用生命陪着程序
语言一起成长，其中的甘苦不足为外人道。  
 
从1997年开始用 Delphi来写论文，到 1999年受学弟陈建良的影响，指导
他写出了到目前都还很畅销的雷电 MAILD，到2000年在服役的时候写出了
Indy当中的 TIdDNSServer ，再商业化成雷电 DNSD。 
 
在2004到2007之间专注在 Windows Media 播放程序、 网络程序以及网络备
份程序上，直到 2009年转移到 iOS的Objective -C领域， Delphi跟Object 
Pascal一直是我念兹在兹的程序语言。  
 
我常在许多场合被问到『 Delphi现在还有人用吗 ?』 『那不是早就过气的语言
吗?』这样的问题在 2010年以前，听来相当尴尬，但在那段时间当中，我知
道Delphi跟C++ Builder 的使用者仍然很多，因为其他工具对数据库整合的
程度不够好，使得 Delphi跟C++ Builder 成为硬件工具机台、生产机台跟数
据库之间整合最好的工具，至今仍然少有能出其右者，从新竹科学园区使用
这两个工具的公司仍占绝大多数的现象就能知道。  
 
虽然我自己在 2009年转为以 Objective -C来撰写 iOS程序，但 Objective -C
的概念跟许多地方和 Object Pascal 真的极为相似，所以我想忘也忘不掉，只
是随着 Embarcadero 对这两个工具的用心加强，在 2012至今，我还是能够
用它来开发许多跨行动装置的程序与小工具。  
 
在学界的教学当中，从 1996到2015之间的 15年，Java可以说是完全制霸，
但我正好最不想碰 Java，从1995年到 2015年之间， 我曾熟悉 Perl, PHP, Object 
Pascal, 甚至 C++跟Python都拿来开发过许多项目， 唯独 Java是我能不碰就
不碰的，这纯粹是赌气。  
 
在这 15年当中， 学界的主流是 Java， 但在这 15年当中， 随着我在元智大学、
长庚大学、中台科技大学 (感谢李桂春老师的引介 )等学校的兼任、演讲，让
我保持与信息教学不间断的接触，也让我深感到这 15年当中台湾在软件开 
 6 发的成长极为缓慢，甚至比 15年前更为落后，同学们的热情不再，当然每
一届都有很优秀的同学，只是比例越来越低，也让我在教学上的热忱逐年降
低，都快熄灭了。不过我仍放不下 Delphi的开发，所以从 2014年开始，我
时不时的把一些开发的心得写成部落格文章，跟大家分享，我的部落格网址
是: http://firemonkeylessons.blogspot.tw/  
 
在这 20年左右的从业生涯中，我熟习的概念不少，最常接触、称得上精通
的有两大部分，一个是面向对象程序的概念，另一个则是网络协议的订定与
制作。  
 
对面向对象程序概念的熟习要感谢陈恭老师， 陈恭老师目前 (2015年)仍任教
于政治大学资讯 科学系，我在就读大同工学院 (现改为大同大学 )时，修习陈
恭老师开设的『高等面向对象程序设计』 ，以及『程序语言结构』等课程，
在课程中对面向对象的概念奠下完整的基础，当时并没有 Java编译程序，
但唯其不透过编译程序 的协助，锻炼出来的对象概念更为深刻。  
 
对研发的执着，要深深感谢鲁立忠老师的教导，鲁立忠老师目前服务于台积
电，两位老师对于我在大学时代奠定对研发的基本功都有深切的影响。  
 
另外也要感谢捷康科技跟 Embarcadero ，让我不断有机会对 Delphi跟Object 
Pascal有深入研究的机会。 这几年我以 Delphi开发的程序从 Windows 到iOS
到Android都有，从 2007年Hinet SafeBox, 2009 年FalconStor 的FileSafe 
Express到2014年SGS的云端质量查验系统 ，从数据库到 iPad各项功能整
合，从文件系统到网络协议，再到 2015年以 iBeacon为主体的物联网监控
系统，都是以 Delphi为主体进行开发的，涉猎范围不可谓不广，然而在台
湾的软件开发成不了一个产业，这是事实，也是悲哀，期许哪一天在台湾写
软件可以像在硅谷那样受到重视。  
 
感谢捷康科技方总经理，让我有机会翻译我心目中偶像 -Marco Cantù 的书，
我在 2006年间从 Macro的Mastering Delphi 2005, Mastering Delphi 2006 启
发许多，早希望能有机会翻译 Marco的著作，感谢方总让我圆梦。  
 
最后，仅以此译作献给我的家人们，尤其这是我成家之后的第一本书，在译
作的期间，太太辛苦的帮我多分担了照顾女儿们的责任，感谢如馨，也希望
两个女儿长大后，有机会看到这本书，但不要受到影响，以你们的喜好选择
你们长大后的工作，颐荷，颐芊，愿你们平安长大，平安喜乐。  
 
张子仁  2015于台北   
 7 目录 
begin  ................................ ................................ ................................ .........................  1 
一本介绍现代程序语言的书  ................................ ................................ .......................  1 
从做中学  ................................ ................................ ................................ ......................  2 
本书的网站  ................................ ................................ ................................ ..................  3 
致谢  ................................ ................................ ................................ .............................  3 
关于我自己  ................................ ................................ ................................ ..................  4 
{.译者的话 } ................................ ................................ ................................ ...............  5 
目录  ................................ ................................ ................................ ..........................  7 
第一部 : 基础篇 ................................ ................................ ................................ ...... 18 
第一部的章节列表 :................................ ................................ ................................ ........  18 
01:用Pascal写程序 ................................ ................................ ................................  19 
我们开始来看程序代码吧  ................................ ................................ .............................  19 
第一个文本模式的应用程序  ................................ ................................ .....................  19 
第一个可视化程序  ................................ ................................ ................................ .... 21 
语法和程序代码 样式  ................................ ................................ ................................ ..... 23 
程序批注  ................................ ................................ ................................ ....................  24 
识别符号（ Symbolic Identifiers ） ................................ ................................ ..............  26 
使用空格符  ................................ ................................ ................................ ................  28 
程序代码内缩  ................................ ................................ ................................ ............  29 
强化语法标示  ................................ ................................ ................................ ............  31 
程序语言的关键词 ................................ ................................ ................................ .........  32 
程序结构  ................................ ................................ ................................ ........................  36 
单元与程序名称  ................................ ................................ ................................ ........  37 
程序文件  ................................ ................................ ................................ ....................  42 
编译程序设定  ................................ ................................ ................................ ................  43 
条件化定义 (Conditional Defines)  ................................ ................................ ...............  44 
编译程序版本 (Compiler Versions)  ................................ ................................ ..............  45 
引入檔  (Include Files)  ................................ ................................ ................................  46 
02:变量与数据型别  ................................ ................................ ................................  47 
变数与指派 (Assignments)  ................................ ................................ ..............................  47 
实际值（文字值、字面意义： Literal Value ） ................................ ..........................  49 
指派叙述句（ Assignment Statements ） ................................ ................................ .... 50 
指派（ Assignment ）与转换（ Conversion ） ................................ .............................  50  
 8 为全局变量进行初始化  ................................ ................................ .............................  51 
常数  (常量， Constants)  ................................ ................................ ............................  52 
资源字符串常数（ Resource String  Constants ） ................................ ........................  53 
变量的生命周期 (Lifetime) 与可视范围 (Visibility) ................................ .......................  54 
资料型别  ................................ ................................ ................................ ........................  55 
有序与数值类型别  ................................ ................................ ................................ .... 55 
布尔值 ................................ ................................ ................................ ........................  61 
字符  ................................ ................................ ................................ ...........................  61 
浮点数型别  ................................ ................................ ................................ ................  64 
简单的使用者自定型别  ................................ ................................ ................................ . 67 
命名与非命名型别  ................................ ................................ ................................ .... 68 
次范围型别  ................................ ................................ ................................ ................  69 
列举型别  ................................ ................................ ................................ ....................  70 
集合型别  ................................ ................................ ................................ ....................  71 
表达式和运算 方法 ................................ ................................ ................................ .........  73 
使用运算方法  ................................ ................................ ................................ ............  73 
运算方法与其优先性  ................................ ................................ ................................ . 75 
日期与时间  ................................ ................................ ................................ ....................  77 
型别切换 (Typecasting) 与转型 (Type  ................................ ................................ ...............  80 
conversions)  ................................ ................................ ................................ ....................  80 
03:语言叙述句  ................................ ................................ ................................ .......  83 
简单与复合叙述句 ................................ ................................ ................................ .........  83 
IF叙述句  ................................ ................................ ................................ ........................  84 
Case 叙述句 ................................ ................................ ................................ ...................  86 
For 循环 ................................ ................................ ................................ .........................  88 
For-in 循环  ................................ ................................ ................................ ................  91 
While和Repeat 循环  ................................ ................................ ................................ .... 92 
循环的范例程序代码  ................................ ................................ ................................ . 93 
04:程序与函式  ................................ ................................ ................................ .......  98 
程序与函式  ................................ ................................ ................................ ....................  98 
预先宣告  ................................ ................................ ................................ ..................  101 
递归函数  ................................ ................................ ................................ ..................  102 
方法 (Met hod)是什么 ? ................................ ................................ .............................  104 
参数与回传值  ................................ ................................ ................................ ..............  104 
附带回传值离开  ................................ ................................ ................................ ...... 105 
引用参数 (Reference Parameters)  ................................ ................................ .............  107 
常数参数  (Constant Parameters)  ................................ ................................ .............  109  
 9 函式的多载  (Function Overloading) ................................ ................................ .........  109 
多载与呼叫混淆  (Ambiguous call) ................................ ................................ ...........  112 
预设参数  (Default Parameters)  ................................ ................................ ................  113 
内嵌程序代码  (Inlining) ................................ ................................ ...............................  115 
函式的进阶功能  ................................ ................................ ................................ ..........  118 
Object Pascal 呼叫函式的约定 (Conventions)  ................................ ...........................  118 
程序型别  (Procedural Types)  ................................ ................................ ...................  119 
宣告外部函式  ................................ ................................ ................................ ..........  121 
延迟加载动态链接函式库的函式  ................................ ................................ ...........  122 
05:数组与记录  ................................ ................................ ................................ ..... 125 
数组数据型别  ................................ ................................ ................................ ..............  125 
静态数组  (Static Arrays)  ................................ ................................ ..........................  125 
数组的大小跟边界  ................................ ................................ ................................ .. 127 
多维度静态数组  ................................ ................................ ................................ ...... 128 
动态数组  ................................ ................................ ................................ ..................  129 
开放数组参数  ................................ ................................ ................................ ..........  134 
记录数据型别  ................................ ................................ ................................ ..............  138 
使用记录数组  ................................ ................................ ................................ ..........  141 
变异记录  (Variant Records)  ................................ ................................ .....................  142 
字段对齐  (Fields Alignments)  ................................ ................................ ..................  142 
With叙述句是什么 ?................................ ................................ ................................  144 
带有方法的纪录  ................................ ................................ ................................ ..........  146 
Self: 记录神奇的地方  ................................ ................................ ..............................  148 
运算符号的新纪元  (Operators Gain New Ground)  ................................ ..................  151 
变异型别 (Variants)  ................................ ................................ ................................ .......  156 
变异型别没有型别 (Variants Have no Type)  ................................ ..............................  156 
深入探讨变异型别 (Variants in Depth)  ................................ ................................ ..... 158 
变异型别很慢 (Variants Are Slow)  ................................ ................................ .............  159 
指标的两三事 (What About Pointers) ................................ ................................ ............  160 
文件型别 , 还有谁有提供 ?(File Types, Anyone?)  ................................ .........................  164 
06:关于字符串  ................................ ................................ ................................ ..... 165 
Unicode:全世界的字母  ................................ ................................ ................................  165 
旧的文字编码 :从ASCII到ISO编码  ................................ ................................ .........  166 
Unicode 字码跟字形  ................................ ................................ ...............................  167 
从字码到字节  (UTF)  ................................ ................................ ................................  168 
位序列记号  (BOM)  ................................ ................................ ................................ .. 169 
看清楚 Unicode  ................................ ................................ ................................ ........  170  
 10 再度介绍字符型别 ................................ ................................ ................................ .......  173 
使用 Character 单元来处理 Unicode  ................................ ................................ ........  173 
Unicode字符常数  (Unicode Character Literals)  ................................ .......................  175 
字符串数据类型  (String Data Type)  ................................ ................................ .............  177 
把字符串作为参数传递  ................................ ................................ ...........................  181 
[]的使用，以及字符串中对字符计数的模式  ................................ ..........................  181 
字符串连接  ................................ ................................ ................................ ..............  184 
字符串助手的处理程序  ................................ ................................ ...........................  186 
更多字符串的运行时间函式库 (RTL)  ................................ ................................ .......  189 
格式化字符串  ................................ ................................ ................................ ..........  190 
字符串的内部结构  ................................ ................................ ................................ .. 192 
观察在内存里面的字符串  ................................ ................................ .......................  195 
字符串与编码  ................................ ................................ ................................ ..............  196 
其他的字符串型别 ................................ ................................ ................................ .......  199 
UCS4String 型别  ................................ ................................ ................................ .......  200 
旧版的 , 只能在桌面版编译程序用的字符串型别  ................................ ..................  200 
第二部 : 用Object Pascal 做OOP  ................................ ................................ ......... 202 
第二部的章节列表 :................................ ................................ ................................ ...... 203 
07:物件  ................................ ................................ ................................ .................  204 
介绍类别 (Class)与对象 (Object)  ................................ ................................ ....................  204 
定义一个类别  ................................ ................................ ................................ ..........  205 
在其他 OOP语言的类别 ................................ ................................ ..........................  206 
类别方法  ................................ ................................ ................................ ..................  207 
建立对象  ................................ ................................ ................................ ..................  208 
对象参考模型 (Object Referenc e Model)  ................................ ................................ ...... 209 
释放对象与自动参考计数 (ARC)  ................................ ................................ ..............  210 
什么是 Nil ................................ ................................ ................................ ................  212 
在内存里面的记录与类别  ................................ ................................ .......................  212 
私有、保护、公开 ................................ ................................ ................................ .......  213 
私有区数据字段的范例  ................................ ................................ ...........................  214 
当私有区并不是真的私有  ................................ ................................ .......................  217 
封装与窗体  ................................ ................................ ................................ ..............  217 
Self关键词  ................................ ................................ ................................ ...................  219 
动态建立组件  ................................ ................................ ................................ ..........  220 
建构函式  ................................ ................................ ................................ ......................  222 
以建构函式跟解构函式来管理区域类别数据  ................................ ........................  224 
多载方法以及建构函式  ................................ ................................ ...........................  226  
 11 完整的 TDate类别  ................................ ................................ ................................ ... 228 
嵌套类型与巢状常数  ................................ ................................ ................................ ... 231 
08:继承  ................................ ................................ ................................ .................  235 
从既存的型别中继承  ................................ ................................ ................................ ... 235 
常用的基础类别  ................................ ................................ ................................ ..........  238 
保护区字段与封装 ................................ ................................ ................................ .......  238 
使用受保护的黑客  (Protected Hack)  ................................ ................................ .......  239 
从继承到多型  ................................ ................................ ................................ ..............  241 
继承与型别兼容性  ................................ ................................ ................................ .. 241 
延迟绑定与多型  ................................ ................................ ................................ ...... 244 
重载 (Override)、重新定义 (Redefine) 、重新介绍      (Reintroduce) 方法  .............  246 
继承和建构函式  ................................ ................................ ................................ ...... 249 
虚拟与动态方法  ................................ ................................ ................................ ...... 249 
把方法跟类别抽象化  ................................ ................................ ................................ ... 251 
抽象方法 (Abstract Methods)  ................................ ................................ ....................  251 
弥封类别 (Sealed Classes) 跟最终方法 (Final Methods) ................................ ..............  253 
安全的型别转换指令  ................................ ................................ ................................ ... 254 
可视化窗体继承  ................................ ................................ ................................ ..........  257 
从基础窗体进行继承  ................................ ................................ ...............................  258 
09:例外处理  ................................ ................................ ................................ .......... 261 
Try-Except区块 ................................ ................................ ................................ .............  262 
例外类别架构  ................................ ................................ ................................ ..........  264 
触发例外  ................................ ................................ ................................ ..................  267 
例外与堆栈  ................................ ................................ ................................ ..............  267 
Finally区块  ................................ ................................ ................................ ..................  269 
真实世界的例外  ................................ ................................ ................................ ..........  271 
全局例外处理  ................................ ................................ ................................ ..............  272 
例外与建构函式  ................................ ................................ ................................ ..........  273 
进阶例外  ................................ ................................ ................................ ......................  275 
巢状例外与内部例外机制  ................................ ................................ .......................  275 
拦截例外  ................................ ................................ ................................ ..................  279 
10:属性与事件  ................................ ................................ ................................ ..... 281 
定义属性  ................................ ................................ ................................ ......................  281 
和其他程序语言的属性做比较  ................................ ................................ ...............  283 
在宣告属性时使用代码自动完成的功能  ................................ ................................  284 
为窗体加入属性  ................................ ................................ ................................ ...... 285 
为TDate类别加入属性  ................................ ................................ ...........................  288  
 12 使用数组属性  ................................ ................................ ................................ ..........  290 
以参考设定属性  ................................ ................................ ................................ ...... 291 
发布 (Published) 存取关键词  ................................ ................................ .........................  293 
设计时间属性  ................................ ................................ ................................ ..........  294 
发布 (published) 与窗体  ................................ ................................ ............................  295 
自动 RTTI  ................................ ................................ ................................ ..................  296 
事件驱动程序写作 ................................ ................................ ................................ .......  297 
方法指标 (Method Pointers)  ................................ ................................ .....................  298 
委任的原理  ................................ ................................ ................................ ..............  300 
事件也是属性  ................................ ................................ ................................ ..........  303 
为TDate类别加入一个事件 ................................ ................................ ....................  304 
建立 TDate组件  ................................ ................................ ................................ ...........  307 
在类别中 实作对于列举功能的支持  ................................ ................................ ............  309 
结合 RAD开发环境跟 OOP的15个小提示  ................................ ................................  312 
提示一 :窗体是个类别 ................................ ................................ ..............................  312 
提示二 :为组件命名  ................................ ................................ ................................ . 313 
提示三 :为事件命名  ................................ ................................ ................................ . 313 
提示四 :使用窗体的方法  ................................ ................................ ..........................  313 
提示五 :建立窗体建构函式  ................................ ................................ ......................  313 
提示六 :避免使用全局变量  ................................ ................................ ......................  314 
提示七 :绝不要在 TForm1的方法中使用 Form1  ................................ .....................  314 
提示八 :少在其他窗体里面用 Form1  ................................ ................................ .......  314 
提示九 :去除全局的 Form1变数  ................................ ................................ ..............  314 
提示十 :加入窗体属性 ................................ ................................ ..............................  315 
提示十一 :把组件属性披露  ................................ ................................ ......................  315 
提示十二 :适时的在需要使用数组属性  ................................ ................................ ... 315 
提示十三 :使用属性的副作用  ................................ ................................ ..................  316 
提示十四 :隐藏组件  ................................ ................................ ................................ . 316 
提示十五 :使用 OOP窗体精灵  ................................ ................................ .................  317 
提示结论 (延伸阅读 ) ................................ ................................ ................................  317 
11:界面  ................................ ................................ ................................ .................  318 
使用接口  ................................ ................................ ................................ ......................  318 
宣告界面  ................................ ................................ ................................ ..................  319 
实作界面  ................................ ................................ ................................ ..................  320 
界面与参考计数  ................................ ................................ ................................ ...... 322 
混和参考的错误  ................................ ................................ ................................ ...... 324 
进阶接口科技  ................................ ................................ ................................ ..............  325 
接口的属性  ................................ ................................ ................................ ..............  326  
 13 界面委任  ................................ ................................ ................................ ..................  327 
多个接口以及方法别名  ................................ ................................ ...........................  329 
界面的多型  ................................ ................................ ................................ ..............  331 
从接口参考解析出对象  ................................ ................................ ...........................  332 
透过接口来实作转换器模式 (Adapter Pattern)  ................................ ............................  334 
12:操作类别  ................................ ................................ ................................ .........  338 
类别方法跟类别数据  ................................ ................................ ................................ ... 338 
虚拟类别方法跟隐藏的 Self参数 ................................ ................................ ............  339 
类别静态方法  ................................ ................................ ................................ ..........  339 
类别数据  ................................ ................................ ................................ ..................  342 
类别属性  ................................ ................................ ................................ ..................  343 
具有实体个数计数器的类别  ................................ ................................ ...................  343 
类别建构函式 (以及解构函式 ) ................................ ................................ .....................  345 
在RTL里的类别建构函式  ................................ ................................ .......................  346 
实作单一实体模式 (Singleton Pattern)  ................................ ................................ ..... 347 
类别参考  ................................ ................................ ................................ ......................  348 
在RTL里面的类别参考  ................................ ................................ ...........................  350 
用类别参考来建立组件  ................................ ................................ ...........................  350 
类别与记录助手  ................................ ................................ ................................ ..........  353 
类别助手  ................................ ................................ ................................ ..................  354 
类别方法跟继承  ................................ ................................ ................................ ...... 356 
现有型别的记录助手  ................................ ................................ ...............................  357 
型别别名的助手  ................................ ................................ ................................ ...... 359 
13:对象与内存  ................................ ................................ ................................ ..... 361 
全局数据、堆栈以及 Heap  ................................ ................................ ..........................  361 
全局内存  ................................ ................................ ................................ ..................  362 
堆栈  ................................ ................................ ................................ .........................  362 
Heap (堆) ................................ ................................ ................................ ..................  363 
对象参考模型  ................................ ................................ ................................ ..............  363 
把对象当成参数来传递  ................................ ................................ ...........................  364 
传统的内存管理小技巧  ................................ ................................ ...............................  365 
释放我们建立的对象  ................................ ................................ ...............................  366 
只能把对象释放一次  ................................ ................................ ...............................  367 
欢迎到 ARC(Automatic Reference Counting) 的世界  ................................ .....................  369 
ARC程序风格  ................................ ................................ ................................ ..........  370 
在ARC底下的 Free跟DisposeOf 方法  ................................ ................................ .... 372 
总整理：在 ARC与非 ARC编译程序中对象的建立与消灭  ................................ .... 375  
 14 Weak参考  ................................ ................................ ................................ ................  377 
unsafe标注  (The unsafe Attribute)  ................................ ................................ ..........  380 
在参考计数的背后  ................................ ................................ ................................ .. 381 
在ARC环境中混用接口跟类别  ................................ ................................ ...............  382 
追踪与检测内存  ................................ ................................ ................................ ..........  383 
内存状态  ................................ ................................ ................................ ..................  383 
FastMM4  ................................ ................................ ................................ ..................  384 
追踪泄漏以及其他全局设定  ................................ ................................ ...................  384 
在完整版 FastMM4 上的缓冲区溢出  ................................ ................................ ...... 386 
在Windows 以外的平台的内存管理  ................................ ................................ ...... 389 
追踪每个类别的配置  ................................ ................................ ...............................  389 
撰写强健的应用程序  ................................ ................................ ................................ ... 390 
建构函式 , 解构函式 , 以及例外  ................................ ................................ .............  390 
巢状 Finally区块  ................................ ................................ ................................ ...... 392 
动态型别检查  ................................ ................................ ................................ ..........  393 
这个指针是对象参考吗 ? ................................ ................................ .........................  394 
第三部 : 进阶功能  ................................ ................................ ................................  398 
第三部的章节列表 :................................ ................................ ................................ ...... 398 
14:泛型  ................................ ................................ ................................ .................  399 
通用的键 -值对  (Key -Value Pairs)  ................................ ................................ .................  399 
泛型的型别规则  ................................ ................................ ................................ ...... 403 
Object Pascal 里面的泛型 ................................ ................................ .............................  404 
泛型型别兼容性规则  ................................ ................................ ...............................  405 
标准类别的泛型方法  ................................ ................................ ...............................  407 
泛型型别实体化  ................................ ................................ ................................ ...... 408 
泛型函式  ................................ ................................ ................................ ..................  411 
泛型类别的类别建构函 式 ................................ ................................ .......................  414 
泛型的约束 (Generic Constraints)  ................................ ................................ .................  416 
类别约束  (Class Constraints)  ................................ ................................ ...................  416 
特定的类别约束  ................................ ................................ ................................ ...... 418 
界面约束  ................................ ................................ ................................ ..................  419 
界面参考 v.s.泛型界面约束  ................................ ................................ .....................  422 
预设建构函式约束  ................................ ................................ ................................ .. 422 
泛型约束的总整理以及组合应用  ................................ ................................ ...........  424 
预先定义的泛型容器  ................................ ................................ ................................ ... 425 
使用  TList<T>  ................................ ................................ ................................ ...........  426 
对TList<T>进行排序  ................................ ................................ ................................  428  
 15 以匿名方法进行排序  ................................ ................................ ...............................  429 
对象容器 (Object Containers)  ................................ ................................ ....................  431 
使用泛型字典 (Dictionary)  ................................ ................................ ........................  432 
Dictionary v.s. StringList  ................................ ................................ ............................  436 
泛型界面  ................................ ................................ ................................ ......................  437 
预先定义的泛型接口  ................................ ................................ ...............................  440 
在Object Pascal 里面的智能指标 (Smart Pointer)  ................................ ........................  441 
智能指针的泛型记录  ................................ ................................ ...............................  441 
用界面来救援  ................................ ................................ ................................ ..........  442 
使用智能指标  ................................ ................................ ................................ ..........  444 
加入隐晦转换 (Addin g Implicit Conversion)  ................................ ..............................  444 
加入自动建立  ................................ ................................ ................................ ..........  446 
完整的智能指标程序代码  ................................ ................................ .......................  446 
以泛型处理协同变异 (Covariant) 回传型别  ................................ ................................ .. 447 
属于 Animals, Dogs, 跟 Cats  ................................ ................................ .....................  447 
回传泛型结果的方法  ................................ ................................ ...............................  449 
回传不同类别的衍生对象  ................................ ................................ .......................  450 
15:匿名方法  ................................ ................................ ................................ .........  451 
匿名方法的语法和语意  ................................ ................................ ...............................  452 
匿名方法变量  ................................ ................................ ................................ ..........  452 
匿名方法的参数  ................................ ................................ ................................ ...... 453 
使用局部变量  ................................ ................................ ................................ ..............  454 
展延局部变量的生命周期  ................................ ................................ .......................  454 
在背景里的匿名方法  ................................ ................................ ................................ ... 456 
(潜在的 )漏掉括号  ................................ ................................ ................................ .... 457 
匿名方法实作  ................................ ................................ ................................ ..........  458 
预先准备好的参考型别  ................................ ................................ ...........................  459 
实战上的匿名函式 ................................ ................................ ................................ .......  461 
匿名事件处理程序  ................................ ................................ ................................ .. 461 
计算匿名方法的时间  ................................ ................................ ...............................  463 
线程的同步  ................................ ................................ ................................ ..............  464 
Object Pascal 里的 AJAX  ................................ ................................ ...........................  467 
16:镜射与标注  ................................ ................................ ................................ ...... 472 
延伸的 RTTI  ................................ ................................ ................................ ..................  473 
第一个范例  ................................ ................................ ................................ ..............  473 
编译程序产生的信息  ................................ ................................ ...............................  474 
强型别与弱型别连结  ................................ ................................ ...............................  476  
 16 RTTI单元文件  ................................ ................................ ................................ ..............  477 
在Rtti单元文件里面的 RTTI类别  ................................ ................................ ...........  479 
RTTI对象的生命周期管理以及 TRttiContext 记录  ................................ ..................  480 
显示类别信息  ................................ ................................ ................................ ..........  482 
套件中的 RTTI  ................................ ................................ ................................ ..........  484 
TValue结构  ................................ ................................ ................................ ..................  485 
以TValue读取一个属性  ................................ ................................ ..........................  487 
呼叫方法  ................................ ................................ ................................ ..................  488 
使用标注  (Using Attributes)  ................................ ................................ .........................  489 
标注是什么？  ................................ ................................ ................................ ..........  489 
标注类别与标注宣告  ................................ ................................ ...............................  490 
浏览标注  ................................ ................................ ................................ ..................  492 
虚拟方法拦截器  ................................ ................................ ................................ ..........  495 
RTTI 个案研究  ................................ ................................ ................................ .............  499 
在ID跟描述上使用标注  ................................ ................................ .........................  500 
XML串流 ................................ ................................ ................................ ..................  505 
其他以 RTTI为基础的函式库  ................................ ................................ ..................  513 
17:TObject 与System单元文件  ................................ ................................ ...........  515 
TObject类别 ................................ ................................ ................................ .................  515 
建立与毁灭  ................................ ................................ ................................ ..............  516 
物件的二三事 (Knowing About an Object)  ................................ ................................  516 
更多 TObject类别的方法  ................................ ................................ ........................  517 
TObject的虚拟方法  ................................ ................................ ................................ . 519 
总结 TObje ct类别  ................................ ................................ ................................ .... 523 
Unicode跟类别名称  ................................ ................................ ................................  525 
System单元  ................................ ................................ ................................ .................  525 
被选上的系统型别  ................................ ................................ ................................ .. 526 
System单元里面的接口  ................................ ................................ ..........................  527 
被选上的系统函式  ................................ ................................ ................................ .. 528 
预先定义的 RTTI标注 ................................ ................................ ..............................  528 
18:其他核心 RTL的类别  ................................ ................................ ......................  530 
Classes单元  ................................ ................................ ................................ .................  530 
在Classes单元中的类别  ................................ ................................ .........................  531 
TPersistent 类别  ................................ ................................ ................................ .......  532 
TComponent 类别  ................................ ................................ ................................ .... 533 
现代文件存取  ................................ ................................ ................................ ..............  536 
输入 /输出工具单元  ................................ ................................ ................................ . 536  
 17 介绍串流  ................................ ................................ ................................ ..................  538 
使用 Reader跟Writer  ................................ ................................ ..............................  540 
建立字符串跟字符串列表  ................................ ................................ ...........................  542 
TStringBuilder 类别  ................................ ................................ ................................ .. 543 
使用字符串列表  ................................ ................................ ................................ ...... 544 
执行时期函式库是相当巨大的  ................................ ................................ ...................  545 
写在最后  ................................ ................................ ................................ ......................  546 
end.  ................................ ................................ ................................ .......................  548 
附录一览  ................................ ................................ ................................ ......................  548 
A: Object Pascal 的演进  ................................ ................................ ........................  549 
Wirth的Pascal  ................................ ................................ ................................ .............  549 
Turbo Pascal  ................................ ................................ ................................ ..................  550 
早期的 Delphi的Object Pascal  ................................ ................................ ....................  551 
Object Pascal 从CodeGear 到Embarcadero  ................................ ................................ . 551 
朝向行动化  ................................ ................................ ................................ ..................  552 
b: 词汇表  ................................ ................................ ................................ .............. 553 
A ................................ ................................ ................................ ................................ ... 553 
B ................................ ................................ ................................ ................................ ... 554 
C ................................ ................................ ................................ ................................ ... 554 
D ................................ ................................ ................................ ................................ ... 556 
E ................................ ................................ ................................ ................................ ... 557 
F ................................ ................................ ................................ ................................ ... 557 
G ................................ ................................ ................................ ................................ ... 558 
H ................................ ................................ ................................ ................................ ... 558 
I ................................ ................................ ................................ ................................ .... 559 
M ................................ ................................ ................................ ................................ .. 560 
O ................................ ................................ ................................ ................................ ... 560 
P ................................ ................................ ................................ ................................ ... 561 
R ................................ ................................ ................................ ................................ ... 561 
S ................................ ................................ ................................ ................................ ... 562 
U ................................ ................................ ................................ ................................ ... 563 
V ................................ ................................ ................................ ................................ ... 564 
W ................................ ................................ ................................ ................................ .. 564 
  
 18 第一部 : 基础篇  
 
Object Pascal 是一个极为强大的程序语言， 奠基在程序结构以及可延伸的数
据结构的良好基础之上。这些基础有一部分是从传统的 Pascal语言衍生而
来，但核心的语言功能已经比早期的功能多了许多延伸功能。  
  
在本书的第一部分里，我们会学到关于程序语言的语法，程序风格，以及
程序结构，变量与数据型别的使用，基础的程序语言叙述据 (像是条件判断
与循环 )，程序和函式的使用，以及核心型别的建构，例如数组、记录与字
符串。  
 
还有许多进阶功能的基础，从类别到泛型型别，我们会在本书的第二部跟
第三部一一介 绍。学习程序语言就像在盖房子，我们必须把基础打好，在
不稳固的基础上所盖的任何结构，可能很亮丽，但也很不稳固。  
 
 
 
第一部的章节列表 : 
第一章 : 用Pascal写程序  
第二章 : 变量与数据型别  
第三章 : 语言叙述句  
第四章 : 程序与函式  
第五章 : 数组与记录  
第六章 : 关于字符串  
 
 
  
 19 01:用Pascal写程序   
 
这个章节会从一些可以用来建立一个 Object Pascal 应用程序的程序片段开
始，会涵盖到一些标准的程序写法，程序批注、介绍关键词与完整程序的
架构。我会开始写一些简单的程序，试着用透过说明这 些程序代码来介绍
并带出接下来几个章节的关键概念。  
 
我们开始来看程序代码吧  
这个章节涵盖了 Object Pascal 语言的基础，但也会花我们几个章节的篇幅
来带领读者们理解整个应用程序作业的一些细节。所以，我们先来快速的
看两个入门的程序吧 (它们的架构会有所不同 )，我们不会看的太仔细。目前
我只想介绍一下我会用来建立范例程序的架构，接着我们才能介绍其他不
同的部分。所以，我希望读者能够尽快开始把书里提到的练习用相关信息
取回，从最开始的练习范例开始看，会是个好主意。  
_________________________ ________________________________________________  
如果您是 Object Pascal 这个语言的初学者，需要逐步操作的指引来协助您
使用本书的范例程序，或者让您可以自己开始动手写程序的话，请参阅本
书的附录 C. 
_________________________________________________________________  
Object Pascal 一开始就被设计成在透过 IDE环境中可以实时上手，经由这
个语言与 IDE的坚强组合， Object Pa scal提供了对程序人员最友善的快速
开发工具与语言。  
 
在IDE里面，您可以设计用户接口、协助您撰写程序代码，执行写好的程
序，还有更多的辅助功能。在本书中，就像我会介绍 Object Pascal 的程序
语言，我也会跟您分享我使用 IDE的方法。  
 
  第一个文本模式的应用程序  
在一开始，我要透过一个文本模式应用程序，只简单的显示 Hello Word 这
样一个字符串，来介绍 Pascal程序语法的一些重要的部分。文本模式的应
用程序，换句话说就是没有窗口画面的应用程序，执行时会以 DOS窗口显
示文字，接受用户透过键盘输入 ，也只以 DOS窗口显示结果。文本模式的
应用程序在现今的 PC上面已经不太实用，但在行动平台上面，有时还是很筆記   
 20 有用处的。  
我暂时不会对以下这些程序代码做太多说明，这也是本书前几章的用途，
以下是 HelloConsole 这个程序项目的程序代码内容：  
program HelloConsole;  
{$APPTYPE CONSOLE}   
var  
    strMessage: string;  
begin   
    strMessage := 'Hello, World';   
    writeln (strMessage );  
    // 以下这个指令，是用来等待使用者输入，直到使用者按下 Enter键为止   
    readln;   
end.   
_________________________________________________________________________  
在一开始的介绍中，我们已经介绍过，本书所有完整的程序代码都可以在
subversion 的repository 里面下载。这些范例的详细介绍则会在本书里面进
行，在前文中，我已经提到项目名称 (在本范例里面叫做 HelloConsole) ，项
目名称也会用来当做文件夹的名称，该文件夹里面还有许多跟这个项目相
关的文件，由于我会把一个章节的范例放在同一个文件夹里面，所以上面
这个项目的文件夹名称会是  01/HelloConsole.  
_________________________________________________________________  
您可以在范例程序第一行看到程序的名字，程序名之后会包含一些指示词
(directives) ：编译程序的设定值 (会以 $这个符号开头，并且用大括号整个包
起来 )、变量宣告的区块（一个字符串变量，命名为 strMessage ） ，以及被
begin跟end所包起来的三行程序代码跟一行说明用的批注。  
 
这三行程序代码会把一段文字复制到一个字符串变量里面去，呼叫一个系
统函式来把这个字符串变量里面的内容输出在文本模式窗口里面，并且呼
叫另一个系统函式，等待用户输入（在这个范例中，只是用来等待使用者
按下 Enter键） 。我们接下来就可以自行定义我们需要的函式，不过 Object 
Pascal已经帮我们附上了数百个常用的函式了。  
 
再强调一下，我们很快就会开始介绍这些程序内容，在一开始的章节，我
们只是给您一个简单的印象，让您大概 知道 Pascal完整的程序大概长什么
样子而已，当然您也可以直接打开、执行这个程序，程序执行的画面，会
像图 1.1的DOS窗口一样，窗口的内容文字如下：  
 
Hello, World  筆記   
 21 _________________________________________________________________________  
图1.1: HelloConsole 范例在 Windows 上面执行
的结果：  
   
 
 
第一个可视化程序  
现在的应用程序，都已经不像上面这个范例，长得像很传统的文本模式窗口，通
常会有许多 可视化的元素（在 Object Pascal 里面我们称之为控制组件）显示在窗
口画面中。在本书中，我们大部分的范例都会是用 FireMonkey 组件库来制作的可
视化程序（即使大多数案例我都会把它简化到只显示简单的文字） 。  
_________________________________________________________________________  
在Delphi里面， 视觉组件库已经区分成两个不同的类别了： 一个是 VCL (专
属Windows 平台上面使用 )，以及 FireMonkey （支持多种不同 的平台、装
置，包含桌面应用程序跟行动装置都支持）在 Appmthod 当中，则只提供了
FireMonkey ，支持多种装置的开发。但要把这些范例改为 VCL版本也都非
常容易。  
_____________________________________________________________________  
要了解一个可视化程序结构的细节，您必须把本书大多数的篇幅都读过，例
如一个 form是一个特定类别的对象实体， 它包含了许多方法、 事件处理程序，
以及属性。刚刚这句话所提到的每个部分，在本书中都会介绍到。但要建立
一个应用程序，您不需要先成为专家，您只需要透过选单上面的选项，就能
轻松的建立一个新的桌面应用程序或行动装置应用程序了。 我在本书前面几
个章节要介绍的，都会是以 FireMonkey 的范例为基础（两种 IDE都支持） ，
简单的介绍如何透过 form的选单跟鼠标点击操作来完成这些动作。一开始，
请您先建立任何一种 form（桌面或行动应用程序均可，通常我会建立一个空
白的行动应用程序项目，这个项目在 Windows 环境也可以执行的） ，然后放
一个 button组件在上头，以及一个多行的文字组件 (或者 Memo也可以 )来显示
输出的结果。 图1.2就是让您看一下在 IDE里面，预设情形下，这个行动应用
程序的 form会长什么样子。在附录 C里面，您可以读到建立这个范例程序的
每个步骤。  
 
筆記   
 22 您如果想要制作一个类似的应用程序， 只需要先建立一个空白的行动应用程
序，然后在空白的 form上面加入一个 button组件即可。现在，我们来加入程
序代码吧。这也是目前我们要接着介绍的，请用鼠标左键双击 form画面上的
按钮，您就会看到以下的程序代码在画面上显示出来 (也可能是很类似的其
他程序代码 )。 
procedure TForm1.Button1Click (Sender : Tobject) begin   
end;   
 
即使您都还不知道类别的方法是什么 (就是上面这段程序的 Button1Click 啦)，
你也已经可以在上面的程序代码的 begin跟end之间加入一些程序代码了，这
些程序代码就会在项目执行时，当我们用鼠标左键点选按钮的时候被执行
到。  
我们的第一个可视化程序， 会有一些程序代码跟第一个文本模式程序完全相
同，只是在可视化程序里面，我们呼叫了不同函式库里面的不同函式，在这
个范例程序中，我们呼叫的是 ShowMessage 。这个范例的程序代码，您可以
在名为 HelloVisual 的文件夹里面找到，您可以试着直接编译它，就可以发现
执行编译的动作真的是非常的简单：  
procedure TForm1.Button1Click (Sender: Tobject)   
var  
    strMessage: string;  
begin   
  strMessage := 'Hello, World';   
    ShowMessage (strMessage);   
end;   
 
_________________________________________________________ ________________  
图1.2: HelloVisual 范例在 IDE环境中显示的画面 ： 
 
 
 
 
  
  
 
 23  
请留意到  strMessage 这个字符串变量的宣告，是写在  begin 这个保留字之
前，而真正执行的程序代码则是写在它之后，再说一次，如果对于任何部分
觉得不太清楚，别担心，所有程序都会随着您读到越后面，而有更详细的说
明。  
_________________________________________________________________________  
您可以在名为 01的目录中找到本章所有范例的原始码，为了容易辨认，在
这个范例的文件夹里面有一个名称跟项目档很相似的 文件，我把这个文件
名的前面加上了 ”Form”，以利区分，这也是我在本书当中用来为 文件命名
的标准规则，项目的结构将会在本章的后面篇幅介绍 。 
_____________________________________________________________________  
在图 1.3里面，您可以看到这个简单程序的 Windows 上面执行的结果，但您也
可以把这个范例程序拿到 Android或者 iOS上面执行，结果也会 相同的。  
现在我们已经介绍怎么撰写、测试一个范例程序了，让我们回头仔细看一下
细节，一如我们在本章开始的时候我提到的顺序。我们要介绍的第一件事，
就是如何阅读程序，各个不同部分的程序代码要如何撰写、以及我们刚建立
这个项目是怎么组成的。 （这个项目会包含有 PAS文件跟DPR文件） 
_________________________________________________________________________  
图1.3: HelloVisual 范例只有一个简单的按  
钮执行的画面：  
 
 
 
 
语法和程序代码样式  
在我们开始介绍 Object Pascal 程序指令之前， 我们要先来看一些 Object Pascal
程序代码的样式 ，我在这里想要点出的问题是：在程序语法之外（我们还没
开始介绍） ，我们要怎么来撰写程序代码呢？这个问题并没有固定的标准答
案，每个人都有自己习惯的写法，不同的习惯写法就会让程序代码看起来有
不同的样式。然而，还是有一些固定的规范必须先介绍给大家知道，例如批
注、大小写、空格符，以及多年以前曾经被称为 美观打印 的排列样式（这里筆記  
 
 24 指的美观当然是让人来阅读，跟计算机没有关系） ，而这个名词现在也已经
很少听到人提起了。  
通常程序代码样式是为了让人在阅读程序代码的时候可以更简洁、 更快速的
了解程序代码，这些样式跟格式就是您可以决定的一些程序代码的排列方
法，好让程序看起来更整齐。而要让程序代码看起来整齐，就必须要坚持相
同的程序代码样式，不管您选择了哪一种样式，记得要在整个项目的所有 文
件当中都用同样的程序代码样式，不然反而会让程序代码看起来更难懂。  
_________________________________________________________________________  
IDE(Integr ated Development Environment ，整合开发环境，可以简称为开发
环境 )已经支持自动格式化程序代码的功能（可以选择针对单一 文件或者整
个项目） ，您可以按下快捷键 Ctrl+D要求 IDE对目前的 文件进行程序代码
样式重新格式化，这个格式化的功能可以让我们自己对 40几个程序代码样
式的细节做设定。 (请从 Options选单当中找到这个设定画面 )，您也可以把
这西设定汇出，让同一团队的其他开发人员共享这些设定值，这样可以让
整个团队的程序样式更为一致。  
 
  程序批注  
虽然程序代码通常已经很容易被读懂，但如 果加上一些批注的话，其他人就
更容易看的懂（如果过了一段时间之后，我们又回头看一些自己也的程序的
话，有批注也更容易看的懂）为什么当时这段程序要这样写，以及当时写这
段程序的前提是什么。  
传统的 Pascal程序批注，是以两个大括号、或者小括号带星号来标注某段文
字为批注的，而近期版本的 Object Pascal 程序语言则是把 C++的批注语法，
也就是用两个斜线来标注其后的文字为批注，所以，以下的三种写法，都是
目前的 Pascal语言可以辨识的批注写法：  
{ 这里面的文字都是批注  }  
(* 这是第二段批注  *)  
// 从左边出现了两个斜线以后，到本行的末端都会被视为批注   
 
第一种批注的写法最为常见，第二种写法则比较常出现在欧陆，因为许多欧
洲国家的键盘上面没有大括号的符号，第三种批注的语法则是从 C跟C++借
来的， C跟C++里面也会用 /*批注 */这样的语法来标注跨行的批注文字，这在
C#, Objective -C, Java跟JavaScript 里面都可以看见。  筆記   
 25 单行批注的语法很有用，常用来写短短的批注，或者把特定一行程序代码先
暂时标注掉， 这个语法也渐渐的成为在 Object Pascal 最常被使用的批注语法。  
______ ___________________________________________________________________  
在IDE的编辑器里面，您可以按下 Ctrl+/这组快捷键，来把单一一行程序代
码，或者选择多行程序代码进行批注或者解除批注，这组快捷键在英文键
盘里面可以直接使用，但如果是其他语系的键盘或输入法，就要先确定一
下/这个符号的位置，实际的按键，可以从编辑器的功能选单 (按鼠标右键就
会显示了 )来清楚的看到。  
 
我们介绍了三种不同语法的批注文字， 这些语法可以帮助我们把单行或者多
行的程序代 码先变成批注文字。 如果您希望把程序代码或程序 文件里面的部
份文字变成批注， 则您可以套用前述三种语法的不同排列来达成批注文字当
中还有其他批注文字这种设定，但多行批注如果要包含其他批注的话，两个
批注文字的语法不能用同一种喔：  
{ code...   
         {comment, 这段批注底下的其他文字会不被当成批注喔 } 
code... }   
 
上面这段程序代码会被编译程序当成错误语法， 因为第一个大括号在第二行
遇到了结束的大括号，因此第三行已经不会再被视为批注文字，所以编译程
序就会判定语法有错，我们可以把它改 写如下：  
{ code...   
         // this comment is OK  
code... }   
 
这样的写法，由于两种批注语法不互相冲突，所以我们如果要把整段文字或
程序代码的批注状态取消，就只要把前后两个大括号拿掉就行了，第二行还
是可以保持批注文字的状态。  
_________________________________________________________________________  
在大括号之后如果出现一个钱字号 $，就不再代表是批注，而是编译程序的
设定代码，例如在我 们介绍的第一个范例程序当中，程序代码里面有一行
写着 {$APPTYPE CONSOLE} 。编译程序设定代码会让编译程序去执行特定
的一些动作，我们在本章后段加以介绍。  
 筆記  
筆記   
 26 其实，编译程序设定代码说到底也算是批注，例如 {$X+ 这是一个批注 }这
样写也不会造成语法错误，这种写法同时扮演两个角色，不过大多数的程
序人员都还是会把编译程序跟批注给分开来写就是了。  
   
  识别符号（ Symbolic Identifiers ） 
一个程序是由许多个不同的识别符号所构成的， 我们会用这些识别符号来为
不同的程序区段命名（例如数据型别 、变量、函式、对象、类别等等）即使
我们可以几乎可以使用我们想用的任何一个识别符号， 仍然需要遵守一些规
则：  
 识别符号不能包含空格符（空格符会用以区分不同的识别符号）  
 识别符号可以包含英文字母与数字，包含字符与所有 Unicode的文字，
所以我们已经完全可以用任何一种语言的文字（当然用中文也行）来做
为识别符号的名称了。  
 在传统的 ASCII符号之外，识别符号只能包含底线 (_)，其他的 ASCII符
号则不可以用在识别符号上，不可以使用的符号，包含有 +, -, *, /, = 以
及所有标点符号跟括号、特殊字符 (像是 @ # $ % ˆ & \ | )，我们只能用
Unicode的字符，例如  ☼ 或 ∞ 都可以。  
 识别符号必须用底线或字符来开头，不可以用数字开头（所以数字当然
可以当成识别符号的一部分，只是不能当成第一个字）我们在这里提到
的数字是指 0-9的阿拉伯数字，至于 Unicode里面的其他语言数字，例如
国字的一或壹则没有问题 。 
以下是很常见的一些识别符号命名方法，我把他们列在名为 IdentifiersTest
的范例程序中 ： 
MyV alue  
 V alue1  
 My_V alue  
 _V alue  
 V al123  
 _123  
 
以下则是一些合法的 Unicode识别符号：   
 27 Cantù (拉丁文 )  
结 (简体中文 )  
画像  (日文汉字 ) 
 ☼ (Unicode 里面的太阳符号 )  
 
接下来我们也介绍一些不合法的识别符号：  
       123 (数字开头 ) 
       1V alue  (数字开头 ) 
       My V alue ( 内含空格符 ) 
       My-V alue (内含特殊符号 ) 
       My%V alue  (内含特殊符号 ) 
_______________________________________________ __________________________  
如果您在程序执行状态中想要检查识别符号是否合法 (需要这样做的情境
很少发生，除非您撰写的是帮助其他开发者的工具 )，在运行时间函式库
(Runtime Library) 当中有提供这样的一个函式，名为 IsValidIdent 。 
   使用大写字母  
跟许多其他的程序语言不同，许多以 C语言为基础的程序语言 (像C++, Java, 
C#, 跟 JavaScript) 都是把英文字母大小写视为相异，英文称为
Case -Sensitive，Object Pascal 是把英文 字母大小写视为相同的，英文称为
Case -Insensitive 。 
因此， 对 Object Pascal 的编译程序来说， Myname, MyName, myname, myName, 
以及 MYNAME 这五个大小写各有不同的字符串，编译程序会把他们全部当
做完全一样的字符串 。在我的观点中，把英文字母大小写视为相同，绝对是
正面的功能，因为这样一来，因为拼字错误或者打字一时打错而造成语法错
误的机会，会比其他语言发生的机会来的低。  
如果我们把 Unicode当成识别符号的情况也采计进来，事情就会变得更为复
杂了，当我们把大小 写视为相同时，只有一个字母大小写相异的关键词就会
被视为完全 相同， 因此也就可以避免在语意上完全相同而只有大小写拼法不
同的情形发生了。  
cantu: Integer;   
Cantu: Integer; // 错误 : 因为与前一个名称重复  
cantù: Integer; // 正确 : 这是完全不同的名称了   
_________________________________________________________________________  
在Object Pascal 的大小写视为相同的规则中，只有 一个情形例外，就是组提示  
筆記   
 28 件函式库套件 (component package) 的Register函式，这个函式一定必须写成
第一个字母大写的 Register, 因为必须兼容于 C++。 
 
当然，当我们在引入由其他语言制作的函式库时，也必须随着该函式库制
作时所使用的字符大小写，才能正确的呼叫、使用这些函式库。  
 
在字母大小写的规则当中还是有一些问题的， 所以我们首先要意识到不同大
小写的识别符号实际上是完全相同的， 所以一定要避免在不同的地方使用相
同的识别符号，其次，我们也要适当的使用大写字母，让我们的程序代码更
容易被阅读。  
编译程序并没有强制我们要在项目当中使用持续的规则， 但使用持续的规则
真的是个好习惯。通常大家会很习惯把第一个字母大写，当我们要用连续几
个英文字作为识别符号的命名时， 通常会让每个有意义的英文字的第一个字
母大写，例如：  
MyLongIdentifier  
MyV eryLongAndAlmostStupidIdentifier  
这样的习惯通常被称为 Pascal -casing, 相对于 Java以及其他以 C语言语法为
基础的程序语言所使用的 Camel -casing：第一个英文字的首个字母小写，其
他的英文前缀个字母均大写：  
myLongIdentifier  
实际上， 目前也越来越常在 Object Pascal 的程序里面看到 Camel -casing的规则
了，目前仅剩 Class宣告、参数宣告以及其他全局变量的范畴内还会使用
Pascal -casing，在本书中，还是会尽量在所有的识别符号中都使用
Pascal -casing的规则的。  
  使用空格符  
空格符、 tab跟换行符号在程序代码里面，几乎是完全被编译程序所忽略掉
的。这三个字符对于编译程序来说都被当成空格符。空格符只用来让程序代
码在阅读上更为舒服，在编译作业上完全没有作用。  
跟传统的 BASIC不同， Object Pascal 允许我们把一个程序叙述句（ statement ）
用很多行的程序代码来表达。 允许用多行程序代码来表达一个程序叙述句的
缺点，是我们自己必须记得在叙述句的最后加上一个分号，让编译程序知道
这是一个程序叙述句的完结点。 Object Pascal 的多行叙述句的唯一限制，是
不能把字符串用多行来表示。   
 29 以下这几段程序虽然看起来奇怪，但他们都描述了同一件事情：  
a := b + 10;   
a := b   
+ 10;   
a :=  
// 在程序代码当中夹一行批注 , 也是可以的  
 b + 10;  
再次强调，在程序代码里面使用空格符跟换行符号并没有一定的规则，但有
几个常用的写法 ： 
 编辑器画面通常在每行达到 80个字符之后，就会切行，如果你的程序代
码超过了这个长度，就会被推到下一行去，这是为了让你的程序代码看
起来更容易阅读，因为这样就不用横向卷动，在比较小的屏幕上也能够
很快的把程序代码阅读完毕。原本每行 80个字符的用意，只是让程序代
码打印出来的时候比较好看， 而近年来也很少看到程序代码打印的需求
了。  
 当函式或程序有多个复杂的参数时， 我们通常会让每个参数放在单独一
行里面，这个习惯是从 C语言而来的。  
 我们也可在批注前后留下一行空白行， 这样可以让我们的程序读起来更
清楚易懂。  
 记得在呼叫函式的时候，在每个参数之间加入一个空白，甚至是在不需
要参数时，也在括号当中留一个空格符，我也会在表达式里面，让每个
运算符号前后多放一个空白，看起来好读多了。  
  程序代码内缩  
关于空格符使用上的 最后一个建议， 是跟典型的 Pascal语言格式相关的议题，
原本是为了让打印出来的程序代码比较美观， 但目前已经都统整为程序代码
内缩来呈现了。  
这个规则非常简单：每当我们需要写一段复合的程序叙述句，就把整段程序
代码内缩两个字符（不是 tab字符， tab字符是 C语言的开发人员常用的） ，如
果这段程序代码当中还有其他复合的程序叙述， 则该段程序代码再多内缩两
个字符，依此类推：  
if ... then  
   statement;   
 30  if ... then  
 begin  
statement1;   
   statement2;  
 end;  
 if ... then  
 begin  
   if ... then  
     statement1;  
   statement2;  
 end;  
重申一次，不同的程序人员在这个常用的规则上会有自己惯用的作法，有些
程序人员会 把begin到end之间的程序代码内缩， 而有些程序人员则会把 begin
这个关键词放在前一段程序代码的最后（ C语言大多都是这样做，译者也是
习惯如此） ，这是因为个人习惯而有些许不同而已。  
相似的规则也常用在变量列表跟数据型别的定义上：  
type   
  Letters = ('A', 'B', 'C');   
  AnotherType = ...   
var  
   Name: string;  
   I: Integer;  
在以往的作法，常常会在 type宣告新的型别名称时，让所有的 等号都放在同
一个位置对齐， 以及让变 量宣告时的冒号都对齐起来， 但现在已经很少见了，
上述的程序代码如果用以往的规则来编排，就会变成：  
type   
  Letters      = ('A', 'B', 'C');   
  AnotherType = ...   
var  
   Name : string;  
   I     : Integer;  
内缩的排列也常用在跨行的程序叙述句上面，通常第二行以后的程序代码，
就会被内缩，而函式的参数如果长过一行，也会被用内缩的方式来显示：  
MessageDlg ('This is a message',   
   mtInformation, [mbOk], 0);    
 31    
 
  强化语法标示  
为了让 Object Pascal 的程序更容易被阅读与编写， IDE的编辑器具备了一个
名为强化语法标示的功能。根据我们所缮打的程序代码语法跟关键词，这些
程序代码会被以不同的颜色跟字体加以标注。默认设定中，关键词会以粗体
显示、字符串跟批注会以不同的颜色显示（而且通常会是斜体） 等等规则。  
保留字、 批注跟字符串这三个类型的程序元素绝对是这个功能中对程序人员
帮助最大的，透过这个功能，我们可以一眼看出程序代码是不是拼错字了？
字符串是不是少打 了一个引号？以及跨行的批注有没有把前后批注的标示
符号正确的标示上去。  
您可以很容易的透过 Editor Colors 这个设定来设定您自己喜欢的语法标示设
定，如果您的开发工作只有自己需要看这些程序代码，则您可以直接设定，
如果您需要跟其他程序开发人员一起工作， 则请您还是先使用标准的颜色布
景吧，我自己也发现一旦习惯了特定的布景颜色以后，一下看到其他颜色跟
样式的画面的确很容易楞住一下，不知所措。  
   错误检知和程序代码检知  
IDE编辑器有许多功能可以协助我们写出正确的程序代码，最直觉的应该就
是错误检知这个功能了，当 我们输入了错误的语法时，编辑器画面上就会立
刻在第一个发生错误那一行标上一串红色的书名号， 让我们知道编译程序无
法辨识该段程序代码， 目前已经连文本编辑器跟文书软件也都有相同的功能
了。  
_________________________________________________________________________  
在您第一次试着撰写 Object Pascal 程序的时候，请务必记得也要先把适当
的unit引入，这样可以避免您的程序 文件最上方被标注许多的错误，  
正确的引入其他的 unit, 可以解决掉 不少错误标示。  
 
其他功能，例如程序代码自动完成，会协助您显示当时我们输入的可能程序
描述句，它会列出许多符合我们输入的函式名称或者属性名称，我们只要用
下拉选单选择我们适用的 fucntion即可。又或者是一个函式的参数，也会被
以下拉式选单的方式呈现。又或者我们可以按着 Ctrl按键，用鼠标左键点选筆記   
 32 某一个程序代码里面的文字，就可以直接跳到该变量 /型别被宣告的地方了。
接下来我们就不再赘述关于 IDE编辑器的功能了。我们还是把主要篇幅用来
介绍 Object Pascal 语言本身吧。  
程序语言的关键词  
这里所指的关键词，就 是由程序语言特别保留下来的识别符号。这些符号都
是在程序语言里面已经预先赋予了功能， 所以我们在整个程序的任何部分都
不能拿来当成我们自己写的程序的符号（例如变量名、 Class名等） 。而基本
上，指示词（ directives ）跟关键词是有所不同的 :关键词是不能拿来当做变
量、类别名称等标识符的，但指示词只要不被放在 {$}这个符号组合中，就
没有影响，所以指示词可以有其他的用途，但实务上，建议还是不要拿任何
关键词（包含指示词）来做为标识符比较好。  
如果您写了以下这样的程序代码（ property这个字是关键词喔） ：  
var  
    property: string  
编译程序就会给您这样的错误讯息：  
E2029 Identifier expected but 'PROPERTY' found   
警告您使用了关键词作为标识符，这是不被允许的。通常当您误用到关键词
的时候，您会在编辑器或者编译程序的时候得到错误讯息，当然用到不同的
关键词会有不同的错误讯息出现。当编译程序发现到关键词出现了，而觉得
这个关键词出现的位置不对，就会依照错误关键词出现的地点回报错误。  
在这里，我不打算把完整的关键词列表列出来，仅列出我们在写程序的时候
比较常用到的关键词，并把他们依照功能分组列出，即使如此，要完整的涵
盖到这些关键词仍旧需要用掉好几个章节来说明。  
_________________________________________________________________________  
请注意，部分关键词会在不同的地方出现，在这里我谨列出最常见的部分，
有些关键词可能会被列到两次。  
原因之一，是经过了这么多年以后，编译程序的团队希望不要再导入新的
关键词，以免旧有的程序反而失效了，所以他们把其中一些关键词再度回
锅了。  
那么，我们就开始关键词的 旅程吧，这些关键词有一些可能在您过去写程序
时或者在前面的章节当中有见过，他们就是构成整个应用程序项目的骨干：  筆記   
 33 另一组关键词则是跟一些基础数据型别的宣告与变量相关的，兹列出如下 : 
_________________________________________________________________________  
在后面的章节中，我还会介绍更多 Object Pascal 的资料型别 。 
 
第三组关键词则是介绍  Object Pascal 程序语言的基础叙述句，例如条件判
断式跟循环，也包含了函式 (function) 跟程序(Procedure):  program 标明应用程序项目的名称  
library 标明函式库专案的名称  
package 标明套件函式库专案的名称  
unit 标明单元文件的名称，单元文件也就是程序代码的原
始档 
uses 指示当前这个单元文件会参考到哪些单元 文件 
interface  单元文件的区段，用来进行宣告  
implementation  单元文件的区段，用来放置实作的程序代码  
initialization  当程序启动时 ，要先被执行的程序代码区段  
finalization  当程序结束前，最后要被执行的程序代码区段  
begin 宣告一个程序代码区块的开始  
end 宣告一个程序代码区块的结束  
type 标明开始进入数据类型声明区段  
var 标明开始进入变量宣告区段  
const 标明开始进入常数宣告区段  
set 定义一个集合变量  
string 定义一个字符串变量，或者自定的字符串型别  
array 定义一个数组型别  
record 定义一个复合数据型别  
integer 定义一个整数变量  
real 定义一个浮点数型态的变量  
file 定义一个 文件变量 
record 定义一个复合数据型别  
筆記   
 34 以下则是跟类别 、对象相关的关键词：  if 标明一个条件判断式  
then 将条件判断式与符合条件时执行的程序代码分隔的符
号 
else  标明条件判断式中，不符条件时要执行的程序代码  
case 标明一个多重选项的条件判断式  
of 把多重选项判断式的条件与各个选项分隔的符号  
for 标明一个固定次数的循环开始  
to 标明  for 循环将变量递增计算时的最终数值  
downto 标明  for 循环将变量递减计算时的最终数值  
in 标明在列举循环当中，用来表示要被列举的组合变量  
while 标明一个条件化的循环 开始  
do 把 while  循环的条件式与要执行的程序代码做分隔
的符号  
repeat 标明一个具终止条件的循环开始  
until 标明 repeat循环的终止条件  
with 标明要针对特定的数据结构进行处理  
function  标明一个会回传执行结果的子程序（名为函式）  
procedure  标明一个不会回传执行结果的子程序（名为程序）  
inline 要求编译程序对函式或程序进行优化  
overload  允许同名的函式或程序被重复使用（称为多载）   
 35  
还有一小群跟例外处理 (我们在第 11章里面会介绍 )有关的关键词 ： 
 
另外还有一小群关键词是用来作为运算用的，我们会在本章稍后的篇幅『算
式与运算符』的部份介绍到（有一些进阶的运算符则会在后面的章节介绍） ： class 标明一个新的类别型别  
object 用来标明一个就的类别型别（目前已不再使用）  
abstract  标明一个抽象类，表示该类别还没有完全被定义  
sealed 标明一个已封锁类别，该类别不能再被继承  
interface  标明一个接口型别（这个关键词也在第一组当中出现
过）  
constructor  一个类别或对象的初始方法  
destructor  一个类别或对象的清除方法  
virtual 一个虚拟方法，在衍生类别中需要被实作出来  
override  在衍生类别中，实作虚拟方法的关键词  
inherited  直接呼叫、引用父类别的方法  
private 宣告类别中不能被外界存取的属性、事件或方法  
protected  宣告类别中有条件供外界存取的属性、事件或方法  
public 宣告类别中可以完全被外界存取的属性、事件或方法  
published  宣告类别中特别为了用户建立的属性、事件或方法  
strict 比private跟protected限制更为严格的类别区段  
property  被对应到变量或方法的一个符号，称之为类别的属性  
read 属性的数据源  
write 属性的变更方法  
nil 表示空对象， 在许多有指针类型的语言当中也都有乡
对应的特别符号，在 C里面称为 NULL  
try 标明例外处理区块开始  
finally 表示不管例外发生与否，都要被执行的区块  
except  表示当例外发生时，要被执行的程序代码区块  
raise 用来触发一个例外事件  
as and div 
is in mod 
not or shl 
shr xor   
 36  
最后，我们列出一些比较不常用的关键词，包含一些不建议使用的旧的关键
词，在本书的附录，或者在 IDE的协助文件中都可以找到，如果您对这些关
键词有兴趣的话 ： 
 
请注意，近几年来 Object Pascal 的关键词已经很少有新增的了，因为任何新
增的关键词都有可能会使得已存在的程序代码在使用新版的编译程序进行
编译时，导致旧有的程序发生编译错误，因为谁也不敢保证程序人员一定不
会用到什么英文字。 Object Pascal 最近新增的功能都不需要透过关键词来达
成，例如泛型（ generics）与匿名方法 （anonymous methods ）。 
程序结构  
您可能曾经把所有的程序代码写在同一个 文件里面， 就像本章的第一个简单
的文本模式应用程序一样。而当我们越常开发可视化程序，就越有机会在项
目档之外使用到第二个原始码 文件。这『第二个 文件』就被称为 单元文件 ，
通常它的扩展名会是 PAS（Pascal 原始档的意思） ，项目档的扩展名则会用
DPR(Delphi 项目档的意思 )，这两种 文件都会内含有 Object Pascal 的原始码。  
Object Pascal 透过了单 元文件或者程序模块的使用提供了延伸性。事实上，
单元文件就提供了模块化以及数据封装的功能，即使没有使用到对象也一
样。 Object Pascal 的应用程序通常都是由好几个单元文件所建立的，包含用
来储存画面与数据模块的单元文件。事实上，当我们加入一个可视化的画面
窗体到项目里面， IDE就会帮我 们加入一个单元文件，这个单元文件正是对
应所加入的可视化画面的程序代码。  
单元文件无需定义画面窗体， 两者之间会自动被关联起来， 两者之间的类别、
属性、方法、事件处理程序，都已经被自动连结好，无需我们额外做什么处
理了。如果您要加入一个新的空白单元文件到项目里面，这个空白单元文件
只需要几个简单的关键词来宣告几个必要的区段即可，如下所示：  default  dynamic export 
exports external  file 
forward  goto index 
label message name 
nodefault  on out 
packed reintroduce  requires   
 37 unit Unit1;  
interface  
implementation  
end.  
 
单元文件的结构极其简单，就像上面的范例一样：  
 首先，单元文件要有一个整个项目不能重复的名字为之 命名，同时也当
作主档名（所以上面这个例子存档时，档名就会是 Unit1.pas ） 
 其次，单元文件一定要有一个 interface区段，用来宣告让其他单元文件
可以使用、存取的资料。  
 第三，单元文件要有 implemention 区段，用来实作这个单元文件里面真
正的程序代码，这里的程序代码也可以比 interface区段所宣告得来的更
多，只是在 interface区段没有宣告的，就只有同一个单元文件的其他程
序代码可以使用，不管是方法或属性都一样。  
  单元与程序名称  
如同我提过的，单元的名称必须跟单元文件的文件名一致，程序 名也一样，
要为单元重新命名的话， 我们可以用 IDE里面的 Save As（另存新档） 来处理，
另存的新文件名跟单元名称也会自动同步变更。 当然您也可以直接从 文件总
管把文件直接改名，但是如果改名后，您没有到单元文件里面把第一行的单
元名称也一起做修改的话，在编译程序的时候，就会看到一个错误发生（或
者只在加载项目的时候， IDE就会告诉你有错误了） ，以下的讯息就是当我
们只改了档名，却没有同步修改单元名称时会发生的错误：  
[DCC Error] E1038 Unit identifier 'Unit3' does not m atch file name   
 
这表示单元名称也必须符合 Pascal识别符号规则， 以及文件系统的命名规则，
例如像我们前面提到过的，不能包含空格符、不能有特殊符号（除了底线） 。
只要我们使用了符合规范的名称来为单元命名， 就会自动被储存为合法的文
件名，所以这一点我们不用太过担心。当然凡事都有例外，就是 Unicode的
符号，有些符号并不是文件系统允许我们拿来作为档名的，就别故意挑战文
件系统了。  
单元名的规则还有一个延伸的规则，就是单元名可以包含 . 所以以下列出的
单元名称也都是合法的：  
     unit1   
 38      myproject.unit1  
     mycompany.myproject.unit1  
这个延伸规则的由来，是因为单元名称必须是唯一的，而随着 Embarcadero
跟第三方开发商所提供的单元文件越来越多，单元文件的名称就变复杂了，
所以目前随着 Delphi开发工具所预载提供的 RTL单元以及各种不同功能的单
元文件，都可以看到有许多用 .来构成单元名称的情形，例如：  
_________________________________________________________________________  
您经常都会在单元文件的全名里面使用到名称里面有 .的单元，或者函式库
的单元文件 。不过也可以只在程序的参考单元当中使用到整个单元名称的
最后部分（这也是为了让旧版的程序能够兼容新版的编译程序） ，您只需要
设定项目选项中的对应项目即可，这个设定选项的名称是 ”Unit scope 
names”，它是一个以分号做项目区隔的列表 。不过请注意，使用这个功能
相对的会让编译的速度比使用完整单元名称的时候变慢许多 。 
   
  更多关于单元文件的结构  
除了  interface 跟 implementation 这两个区段之外，每个单元还可以有
initialization 跟 finalization 这两个非必要的区段。 Initialization 是用来处理
该单元被执行时最开始的程序代码，而  finalization 则是用来处理该单元在
程序结束时要处理的程序代码。  
____________________________________ _____________________________________  
您也可以在类别的建构方法 (constructor) 当中加入 initialization 程序代码，
Object Pascal 的许多最新功能在第 12章会介绍到，使用类别的建构方法可
以帮助链接程序移除非必要的程序代码，这也是为什么建议大家使用类别
的建构方法跟解构方法 (destructor) ，而比较不建议使用 initialization 跟
finalization 区段的原因。在过去的历史中， initialization 区段还是需要依靠
begin这个关键词来进行宣告的， begin的类似用法仍然是项目程序代码的
标准。  
 System 代表核心 RTL的单元  
Data 代表数据库存取与相关的单元  
FMX 代表 FireMonkey 平台与跨装置组件的单元  
VCL 代表 Windows 平台视觉组件库的单元  
筆記  
筆記   
 39 换句话说，单元的结构，包含了所有可能的区段与一些简单的元素，应该
长得像下面这个范例程序代码：  
unit unitName;  
interface   
// 其他我们在本单元会引入的单元名称，在  interface 这个区段中宣告   
uses   
    unitA, unitB, unitC;  
// 要公告周知的型别定义   
type   
    newType = TypeDefinition;  
// 要公告周知的常数   
const   
   Zero = 0;   
// 全局变量   
var  
   Total: Integer;  
// 要公告周知的函式与程序   
procedure MyProc;   
implementation  
// 其他在 implementation 区段我们会引入的单元名称  
uses   
   unitD, unitE;  
// 不对其它单元文件告知的全局变量   
var  
   PartialTotal: Integer;  
// 所有被公告的函式都必须在此被实作   
procedure MyProc;  begin   
// ... MyProc 这个程序的程序代码  
end;   
 initialization  
// 非必要的 initialization 区段的程序代码   
 finalization  
// 非必要的  finalization 区段程序代码  
end.   
 
一个单元的  interface 区段存在的意义，是为了告知其它单元，这个单元
包含什么，能为其它单元或项目提供什么。而  implementation 区段则包 
 40 含了所有其它单元都无法得知的程序代码。这也是 Object Pascal 之所以可
以提供信息封装，而不需要靠类别或对象就能达成 该功能的原因。  
 
我们可以发现，单元的  interface 区段可以宣告不少型别各异的元素，包
含程序、函式、全局变量，以及数据型别。数据型别当然是最常出现在这
个程序区段中的。 IDE环境会自动放一段新的类别宣告，当我们建立一个
新的可视化画面窗体，然而，宣告窗体定义并不是 Object Pascal 当中包含
单元这个功能的唯一理由。我们也可以在单元当中只有程序代码，只有函
式与程序（就像传统  Pascal 程序的作法），甚至在单元里面有新的类别，
但不用参考其它的窗体的或者可视化组件。  
 
  Uses 条文 
Uses条文位于 interface区段的开头部分，是用来标示我们在该单元中需要
参考的其它单元名称 。 是标明我们在这个单元当中， 为了定义数据型别时，
需要参考的其它单元，而参考的程序也限于那些单元的数据型别，例如我
们在画面窗体当中定义的组件。  
 
第二个 uses条文是出现在 implementation 区段的开头， 是标明我们只在程序
代码实作阶段需要参考的单元文件。当您只需要参考其它单元的程序代
码，例如子程序、方法，我们就得在 implememtation 区段当中的 uses来标
明这些单元的名称。在 uses条文中被标明要参考的单元文 件，都必须位于
项目目录当中，或者 IDE环境的搜寻路径当中，这样编译才不会出问题。  
_________________________________________________________________________  
您可以在 Project Options 的选单当中设定搜寻路径， 系统也会先搜寻已经位
于Library Path 里面的文件，这个设定算是 IDE的全局设定值。  
 
C++的程序人员们请注意， uses叙述跟 C++的include叙述句并不对等， uses
叙述句的效应只会把预先编译的单元的 interface部分引入。 Implementation
区段的程序代码会在该单元实际被编译程序处理的时候才被考虑， 被引入
的单元文件， 可以以原始码的格式 (PAS檔)或者编译过的二进制文件 (DCU
文件 )的形式存在前述的目录或路径中。  
 
虽然在 Object Pascal 当中并不常用到， 但 Object Pascal 的编译程序设定当中
也有一个类似 C/C++ include 的编译程序设定，名为 $INCLUDE ，这些特别
的引入档会被部分需要共享编译程序设定 的函式库或者在许多单元文件
要共享其它设定的时候才被用到的，而且通常会使 用INC这个特别的扩展
名，这个编译程序设定会在本章的最后介绍。  提示   
 41 _________________________________________________________________________  
请注意， Object Pascal 的二进制编译文件 (DCU)只会在使用相同版本的编译
程序与系统函式库时兼容。用旧版的编译程序编译的二进制文件，通常无
法与后来版本的编译程序兼容，这一点不可不察。  
 
  单元与界限  
在Object Pascal 当中，单元正是数据封装与程序代码界限的关键，在这个
规范下， 单元能提供的程序代码界限甚至比类别中 private或public关键词
能提供的还更重要。一个标识符 (例如变量、程序、函式或数据型别 )的界
限，是表示这个标识符能够被其它程序代码存取的范围，所以也被称为该
标识符的可视范围。基本规则就是只有在该标识符的界限中，它才是有意
义的，因此只有在这个单元当中的程序、函式才能使用这个标识符，我们
无法在标识符的界限之外使用它。  
_________________________________________________________________________  
请注意， Object Pascal 跟C、C++都不一样， Object Pascal 在一般程序代码
区块里面不允许变量、常数的宣告。当我们已经进入了 begin -end的程序代
码区块范围之后，在这里面就不能够再宣告任何变量了 。 
 
通常一个标识符只有在它被定义之后才能使用。但在 Object Pascal 当中，
也有方法在一个标识符被完整定义之前先进行宣告， 但我们在完整考虑了
定义与宣告的规则后，应该可以发现其实他还是遵循着 Object Pascal 的基
本规范的。  
 
假设把整个程序的程序代码写在单一一个 文件里面是有意义的， 那么，这
个规则会怎么修正好让我们在使用多个单元文件的时候能够遵循呢？简
单的说， 当我们透过 uses条文把其它单元引入的时候， 在被引入的单元中，
interface区块所宣告的所有标识符也在新的单元文件里面变成可以被存取
的了。  
 
反向理解一下，如果您在 interface区段宣告了一个标识符（可能是型别、
函式、类别、变量等等），所有引用现在建立的这个单元的其它所有程序
代码也都可以看到这个刚宣告的标识符了。但如果您是在 implementation
区段中宣告这个标识符的话， 则这个标识符就只能在自己这个单元文件中
被看见， 其余引用这个单元的程序代码都无法看见了，我们可以把它理解
成区域标识符，就像局部变量那样。  
 
 筆記  
筆記   
 42   把单元文件当成命名空间来使用  
我们已经看过了 uses叙述句，它是让单元文件能够看见其它引入的单元文
件相关标识符的标准技术。这时您可以存取这个单元中的所有定义，但有
时在两个单元文件里面可能宣告了相同的标识符，例如您可能有两个类
别，或者两个子程序使用了完全相同的名字。  
 
在这种情形下， 我们可以简单的把单元名称前置在这个被重复使用的标识
符之前。举个例子来说，您可以引入在 Calc这个单元当中名为
ComputeTotal 的程序，这时我们可以把它写成 Calc.ComputeTotal ，IDE不
常要求我们一定要这么写，但当我们在两个不同单元中有相同的标识符
时，这样写可以避免重复，以及让编译程序不会误解。  
 
然而如果您曾经深入看过系统或第三方组件的程序， 您应该会发现许多函
式跟类别的名称重复，最常见的例子就是在不同平台的可视化组件中，常
常有相同命名的组件，当您深入看到 TForm或TControl的程序代码时，里
面有很多类别或函式会依据您所引入的单元来决定要执行哪一个函式。  
 
如果使用了相同名称的两个单元，正好都被您的单元文件引入了 ，最后被
引入的那个单元会抢到该名称的使用权， 编译程序也就会把该名称直接对
应到最后被引入的单元文件的标识符去，如果您无法避免这种情形的话 ，
请一定在重复标识符名称的前面加入该单元文件的完整名字， 这样编译程
序就不会弄错了。  
_________________________________________________________________________  
在Delphi XE5 之后， FireMonkey 平台提供了一个名为 TPath的类别，让我
们可以处理跨平台的常用路径，因此我们可以透过 TPath. GetDocumentPath
来取得各平台上面的文件路径。  
但TPath就是一个重复名称的标识符，我们要使用的这个功能，是由
System.IOUtils 这个单元当中的 TPath所提供的， 因此译者最近在用到 TPath
的时候，都会自己写成 System.IOUtils.TPath ，这样编译程序就不会混淆了。  
 
  程序文件 
我们在前面的篇幅已经看过了， Delphi的应用程序文件会包含两种程序代
码文件：一个是会出现多次的单元文件，而另外一个是只会出现一次的程
序文件， 或者我们也可以叫它项目档。 单元文件可以看成是第二层 的文件，
所有单元文件都会被扮演主要阶层角色的项目档所引入。  
 筆記   
 43 理论上这是对的，在实务上，项目档通常是自动产生出来的 文件，而且有
其被局限的角色。项目文件只用来启动这个应用程序、通常会建立、执行
主要的画面窗体（如果应用程序是可视化应用程序时）。项目档的内容也
可以手动编辑，但是当我们修改项目设定的时候，这个 文件的内容就会被
自动修改（就跟应用程序当中的其它对象跟画面窗体一样）  
 
项目文件的结构通常比其他单元 文件来的简单， 以下就是一个简单的项目
档，这个内容会是由 IDE帮我们自动产生：  
program Project1 ; 
uses   
   FMX.Forms,   
   Unit1 in ‘Unit1.PAS’ {Form1};   
begin   
   Application.Initialize;  
   Application.CreateForm (TForm1, Form1);  
   Application.Run;  
end.   
 
从上面的程序代码我们可以看到，它只有一个简单的 uses区段，以及透过
begin -end标明的应用程序主要程序代码，这个程序的 uses叙述句非常重
要，因为它们会被用来进行编译、链接成应用程序执 行文件。  
_________________________________________________________________________  
在项目文件里面的单元列表 对应了在 IDE当中项目管理员画面的单元列
表，当我们在 IDE里面加入一个单元到这个项目里面的时候，这个单元的
名称也会自动被加入到这个项目档的 uses区段里面。 当然， 如果我们从 IDE
里面删除了一个单元文件，项目文件的 uses区段也会立即有反应。  
反之如果我们直接编辑项目档， 从里面直接删除某个 uses里面的单元文件，
在IDE里面的设 定画面也会同时立即有反应。  
 
编译程序设定  
程序结构里面另一个特殊的部分（跟其他实际的程序代码相比），就是编
译程序设定了， 我们稍早曾经提到过， 这些特殊的指令是给编译程序用的，
会以以下的格式撰写：  
{$X+}   
 筆記   
 44 有些编译程序设定只是一个简单的字符，就像上面这个例子，用加号或减
号来表示该设定是有效或者无效， 大多数的设定会有一个长一点或者能够
被判读的写法，使用 ON与OFF来表示有效或者无效，而部分设定值则只
有较长的写法，没有像上例这种简写。  
 
编译程序设定通常不是直接把程序代码编译成二进制，而是告诉编译程
序，这个设定值出现之后，要把编译程序当中的部分设定进行调整以后再
行编译之后的程序代码，大多数的时候，我们可以透过修改 IDE当诸的项
目设定值来调整这些设定，即使有些情况下，我们只需要对一个单元或一
部分的程序代码进行编译程序设定值的调整。  
 
在后续的篇幅中，只要提到相关的程序语言功能，我也会介绍一下相关的
编译程序设定，在这个章节中，我只稍微介绍一些跟程序流程相关的编译
程序设定，例如条件化定义 (Conditional Defines) 与引入 (includes)  
 
  条件化定义 (Conditional Defines)  
条件化定义会透过 $IFDEF让我们可以告诉编译程序使用哪一部分的程序
代码，或者忽略它。通常我们会在定义标识符或者引入单元的时候用到这
个功能。它们可能会基于部分已经被定义过的标识符或者常数。这些被定
义的标识符可能是系统预先定义的（例如各平台的变量），可能是一个特
殊的项目设定值，也可能是我们用另一个编译程序设定句： $DEFINE 来定
义的：  
{$DEFINE TEST} ...   
{$IFDEF TEST}   
// 这部份的程序代码会被编译   
{$ENDIF}   
{$IFNDEF TEST}   
// 这部份的程 序代码不会被编译   
{$ENDIF}   
 
我们可以加上 $ELSE把一个条件的两种情形做出区隔， 比较弹性的作法是
使用 $IF这个句子，记得结束时要加上 $IFEND，这样可以把编译程序设定
的叙述句写的比较像一般 Object Pascal 程序代码。所以我们也常定义一个
常数，然后用一个参考该常数的判断式来搭配编译程序设定的判断句，以
下就是以编译程序版本作为范例的写法， 让不同版本的编译程序使用一些
通用的系统定义。  
  
 45   编译程序版本 (Compiler Versions)  
每个版本的 Delphi编译程序都有一个特别的定义 值，我们可以依此进行判
断，检查我们的程序是否能使用特定版本的编译程序。这有赖我们使用了
后面介绍的一些功能， 但希望在编译时先检查一下编译程序是否能够处理
这些功能的程序代码。  
 
如果我们需要最近几版的 Delphi来处理特定的程序代码，我们可以在
$IFDEF后面判断以下的版本代号 ： 
 
后面的数字是该版的编译程序版本代号（例如 26就是 Delphi XE5 ），这个
号码并不会区分 Appmethod 或Delphi， 但回推到第一版的 Pascal编译程序则
是由 Borland所推出的。  
 
我们也可以在 $IF判断式里面使用这些内部的代号常数，这样我们就可以
直接用 >=来判断编译程序是否符合特 定版本的需求，版本的常数名称是
CompilerVersion ，在Delphi XE5 里面， 这个常数是一个浮点数， 数值是 26.0，
所以范例如下：  
{$IF CompilerV ersion >= 26}}   
  // 需要 Delphi XE5 或更新的版本编译程序才能编译的程序代码   
{$IFEND}   
举一反三，我们也可以使用一些系统常数 ，例如用来判断是哪个操作系统
平台，万一我们需要使用到该平台特定的程序功能：  
 Delphi 2007  VER180 
Delphi XE  VER220 
Delphi XE2  VER230 
Delphi XE4  VER250 
Delphi XE5  VER260 
Appmethod 
Spring 2014  VER260 
Delphi XE6  VER270 
Appmethod  
June 2014  VER270 
Delphi XE7  VER280 
Appmethod 
September 2014  VER280  
 46  
以下是简单的程序片段，使用了上述的操作系统定义，它们是
HelloPlatform 范例的部份程序：  
{$IFDEF IOS}   
  ShowMessage ('Running on iOS');   
{$ENDIF}   
{$IFDEF ANDROID}   
  ShowMessage ('Running on Android');   
{$ENDIF}   
 
  引入檔  (Include Files)  
我在此想介绍的另一个编译程序设定指令，是 $INCLUDE 这个指令 ，我们
在前面介绍 uses的时候已经提到过了，这个指令让我们可以参照、引入特
定程序文件中的一部分程序代码， 通常这个用法会被用来在不同的 文件中
引入相同的程序代码，例如某段程序代码定义了一些编译程序设定，而我
们在使用一个单元时，只需要引入一部分的程序代码，当我们引入一个 文
件时，该文件所引入的所有单元都会一起被编译（这就是为什么我们应该
避免在引入档里面加入新的识别符号的原因）  
 
换句话说， 我们应该不要在引入文件里面加入任何程序相关的元素与定义
（这跟 C语言的例子正好相反），相关的程序元素与定义都应该在单元文
件里面来处 理， 所以我们到底该如何使用引入档呢？好的例子是在引入档
里面写入一些我们希望在大多数的单元文件中都要用到的编译程序设定，
或者特殊的额外定义。  
 
大型函式库通常会使用引入档来达成前述的目的，例如 FireDAC函式库，
这是已经成为系统默认函式库之一的用来处理数据库相关的函式库， 另一
个例子则是系统的运行时间函式库 (RunTime Library, 又简写成 RTL)也在
各个操作系统中使用了独立的引入文件， 而在编译程序中会随着我们所选
择的作业平台单独套用该平台的设定。  
 
 Windows 系统（32或64位都一样）  MSWINDOWS  
Mac OS X  MACOS 
iOS IOS 
Android Android  
 47 02:变量与数据型别   
 
Object Pa scal是一个强型别的程序语言，在写程序的时候，变量被宣告时就
需要标明其所属的资料型别（也可以是用户自定的数据型别） 。所谓的资料
型别，所指的是该变量当中可以储存什么样的资料内容，而我们又能对它
做些什么运算。这同时让编译程序可以用更快的速度处理我们的程序代码，
也更容易发现哪些程序代码有错误。  
 
这就是 Pascal语言的型别理论强于其它语言（例如 C或C++）的地方，后
来发展出的很多语言都在语法承袭了 C语言，但却打破了与 C语言的兼容
性，例如 Java跟C#，就承袭了 C语言，也学习了 Pascal对数据型别强故
的概念。 举例来说，在 C语言中，连算数型别都几乎可以互相交换。相对
之下，原始的 BASIC语言，就没有这样的概念，而今日的许多脚本式语言，
（例如 Javascript 就是最好的例子） 对型别的概念跟 Pascal都是大相径庭的。  
_________________________________________________________________________  
事实上，虽然 Object Pascal 是强型别语言，但仍然有一些技巧可以用来避
开型别安全的规范，像是使用可变记录型别，这个作法我们强烈建议大家
别用，且 今日已经很少被使用了。  
 
一如我提过的，所有可变动的程序语言，从 JavaScript 以降，对于数据型别
都没有很确切的描述，或是只有很概略性的描述 。在这些程序语言当中，
变量的型别大多取决于我们赋予什么数据进去。 而该变量的型别可能在执
行当中随着执行状态而改变。值得正视的是，数据型别在大型的应用程序
的编译作业时，是可以用以判断程序正确性的关键，所以不能在运行时间
才加以检查。数据型别需要更多的规范与结构，并在程序代码撰写前就应
该要加以规划，这些地方很明显的都有其优缺点。  
______________________ ___________________________________________________  
我比较喜爱强型别的程序语言，这一点已经不用再多说了，不过本书的目
标还是在说明程序语言是怎么运作的，这比提倡我的想法里什么才是一个
伟大的程序语言还要来的强烈。不过我确定您应该会在读完本书之后能够
真切的知道程序语言的优劣之别。  
 
变数与指派 (Assignments)  
跟任何一个强型别的程序语言相同， Object Pascal 也要求所有变量在被使用筆記  
筆記   
 48 之前要先行宣告，每次我们宣告一个变量，都必须明白的说明它属于哪 种
数据型别，以下就是几个变量宣告的样子：  
 
var  
   V alue: Integer;  
   IsCorrect: Boolean;  
   A, B: Char;  
 
上面范例程序代码里面的 var关键词， 可能在一个程序代码的好多个地方会
出现，例如在程序与函式开头的部份，我们都会宣告一些局部变量，好在
程序、函式这些『子程序』当中使用，或者在一个单元文件中宣告整个单
元的全局变量。  
_________________________________________________________________ ________  
和C以及与 C相似的程序语言相比，在 Object Pascal 里面，我们不允许在
程序代码当中夹杂着变量宣告，但是我们可以把这些宣告统整起来放在特
定的程序区段中（例如方法、函式、程序的开头部分） 。因为每次要这样宣
告，在输入程序代码的时候并不顺手，所以 IDE的程序代码编辑器会让我
们在撰写程序代码的时候，只要在程序或函式、方法的程序代码当中输入
var这个关键词，在 var后面宣告的变量就会自动被搬到正确的位置去了。
这是预先定义好的程序模版，这也是 IDE当中允许我们自定内容的另一个
很强大的功能。  
 
在var这个关键词后面，我们可以宣告一连串的变量名称，以分号来区隔变
量名称和其所属的资料型别。我们可以在一行里面输入多个变量名称，例
如上面范例中最后的 A跟B，多个变量名称之间以逗点来做为区分。  
 
我们定义好一个特定型别的变量之后，就可以用该型别的运算来处理这个
变量了，例如我们可以用布尔值来检查条件是否符合，以及把整数值用在
数字的运算上。我们不能把布尔值跟整数拿来混用，也不能把不兼容的各
种变量值拿来互相处理（即使它们内部处理的数据兼容也不行，例如布尔
值跟整数，它们的数据格式是兼容的，但还是不能把布尔值跟整数混 在一
起运算） 。  
 
最简单的数据指派指令，就是把一个实际的值指派进该型别的变量里面，
例如我们现在有个变量名为 Value，我们希望在 Value这个变量里面存放 10
这个数字，但是我们要怎么直接撰写实际的值？接下来就让我们来看一下
这个实作的方法，以及当中所蕴含的细节。  
 筆記   
 49   实际值（文字值、字面意义： Literal Value ） 
Literal Value 就是在程序代码当中直接输入一个数据，例如我们需要一个整
数20，就可以在程序代码当中直接输入：  
 
20 
 
相同的数值也可以用十六进制来表示：  
$14 
 
以上就是一些 在程序代码当中直接输入表示整数的方法， 如果我们想用浮点
数表示的话，可以直接在上面加上小数点，例如表示 2.0: 
2.0 
 
在程序代码的字面意义，不限于数字，我们也可以输入字符跟字符串，字符
与字符串的字面意义，只要用单引号包起来即可：  
//字符  
‘K’ 
#55 
//字符串  
‘Marco’  
 
如我们上面所介绍的，我们也可以用数值来表示字符（起初这个方式是用来
表示 ASCII字符，但目前已经可以用来表示 Unicode了） ，只需在数字前面
加一个井字号即可，例如 #32就代表空格符。透过这个方法，我们就可以不
用实际输入字符 ，只要直接透过数值就可以处理许多控制用的字符了，例如
tab或者删除键。  
 
万一我们在这个字符串当中必须包含单引号这个字符， 就直接输入 两个单引
号字符即可：  
‘Marco Cantu’’’;  // 这样就代表了  Marco Cantu’  
 
在上面的范例字符串当中，最后三个单引号当中，前面两个重复的单引号用
来表示单引号字符，最后一个单引号则是用来表示字符串结束。另外也要注
意到，字符串必须要在单行当中输入完毕，如果字符串太长，会超过一行，
我们就必须要把它写成两行，然后两行之间用加号  + 来把两个字符串连接
在一起。如 果我们希望在字符串中加入换行符号，不要把他们写成两行，而
是要在字符串当中加入一个换行符号： sLineBreak 这个系统常数：   
 50 ‘Marco’+ sLineBreak +’ Cantu’’’  
 
  指派叙述句（ Assignment Statements ） 
在Object Pascal 里面，要进行数据指派的符号，是冒号加上等号 (:=)，这个
符号对于只熟悉其他语言的开发人员来说，是一个很奇怪的符号。而单纯一
个等号  =, 在其他程序语言当中大多用来作为指派数据的运算符，而在
Object Pascal 里面则是用来进行 比对两个数据是否相同。  
_________________________________________________________________________  
:= 这个符号，是从 Pascal的前身， Algol语言来的，这个程序语言对现在
的程序开发人员来说都已经是很少听到的，更遑论用过，大多数目前的程
序语言都不再使用 :=这个符号，而比较常用 =了。 
 
也因为用了不同的符号来处理数据指派跟数据比对， Pascal的编译程序 (就
像C的编译程序一样 )处理程序代码的速度就更快，因为无需花时间把整段
程序代码 判读过后才去判断等号在出现的时候是代表什么意义。而使用不
同的符号也让程序人员在阅读程序代码的时候更容易读懂。 Pascal语言选择
的这两个符号跟 C相关的语言 (从C取经而来的语言包含有 Java, C#, 
JavaScript) 不同， C相关的语言是用 =作为指派数据的符号，而用 ==作为判
断数据内容是否相同的运算符号。  
_________________________________________________________________________  
为了完整性，我得 再多提一下 JavaScript 还有个===符号，这个符号是用来
判断两个变量或数据的数据型别与内容是否一样，因为除了判断型别是否
相同，还会把两个数据先转成相同型别再去判断其内容，所以这个运算符
号所花的时间会比较久，而且就连 JavaScript 的程序人员都常被搞混。  
 
在指派叙述句当中的双方，我们通常称之为左值 (lvalue)跟右值 (rvalue)，所
谓的左值，就是在叙述句的左方的家伙，它必须是个内容可以被改变的识
别符号，例如变量、指针、对象，在这个叙述句当中，右值的内容会被复
制一份到左值的内存空间当中。  
 
另一个规则则是左值与右值的数据型别必 须一致，或者两者之间能够有自
动的型别转换，这我们会在接下来的篇幅中介绍。  
 
  指派（ Assignment ）与转换（ Conversion ） 
单纯的指派动作中，我们可以写出以下的程序代码： (您可以在 variableTest
这个测试项目档中，找到这个章节里面的范例程序代码 ) 筆記  
筆記   
 51 V alue := 10;   
V alue := V alue + 10;   
IsCorrect := True;   
 
透过适当的变量宣告，这段范例程序代码的三个叙述句都是正确的，而以
下这个叙述句就是错的了：  
 
V alue := IsCorrec t; 
 
如果我们试着编译上面这句程序叙述句，编译程序会回报一个如下所述的
错误：  
 
[dcc32 Error]: E2010 Incompatible types: 'Integer' and 'Boolean'   
 
编译程序会告诉我们，在程序代码当中有错误，错误的描述则是不兼容的
资料型别（ Incompatible data types ） ，当然，我们也可以把一个变量的型别
转换成另一种型别。在某些情形下，这样的转换是自动的，例如我们如果
把一个整数值指派给一个浮点数型别的变量，就会自动转换（当然了，反
之要把浮点数 指派给整数型别的变数则不行） 。有时我们也需要呼叫一些特
定的系统函式来做数据转换的动作 。 
 
  为全局变量进行初始化  
我们可以在宣告全局变量的时候顺便把初始值指派给它，用的是 定义常数
内容时候的符号 (=)，而不是指派变量内容时所使用的 (:=)，所以我们可以写
成以下范例程序代码：  
 
var  
    V alue: Integer = 10;  
    Correct: Boolean = True;  
这样的初始化动作，只能对全局变量使用，在子程序，也就是程序或者函
式当中的变量宣告，是不能够使用这个语法的，子程序的变 量初始化，必
须在子程序的程序代码当中进行：  
 
var  
   V alue: Integer;  
begin   
   V alue := 0; // 初始化   
 52 再强调个 100次、10000次，如果局部变量不经初始化就直接使用它，变量
里面的内容是完全无法预料的，它将会是内存被变量取得的当下，内存里
头的随机数据，在许多情形下，编译程序都会警告说这会有潜在的错误发
生。例如我们如果这么写：  
var  
   V alue: Integer;  
begin   
   ShowMessage (V alue.ToString); // Value 就没有初始化  
执行的结果，显示的数字内容将会完全无法预料，因为显示的内容将会是
内存被配置成 Value这个变量时，该段内存里面的随机数据。  
 
  常数 (常量， Constants)  
Object Pascal 也允许我们宣告常数，常数的存在，让我们可以把特定的数据
赋予名称，在程序执行的过程中，常数的内容是不能被变更的。同时常数
的存在，也会让我们的程序代码在编译之后的 Size小一点。  
 
要宣告常数，我们可以不用指定资料型别，只要直接指定初始值就行了，
编译程序会由 我们指定的初始值内容，自动辨识该内容应该 使用的数据型
别，以下就是一些简单的常数宣告（这些程序代码仍然可以从 VariablesTest
项目中找到） ：  
 
const   
Thousand = 1000;   
Pi = 3.14;   
AuthorName = 'Marco Cantu';   
 
编译程序会依照数据的内容自动判断常数的数据型别，上述的程序代码中
Thousand 这个常数的型别会被指派为 SmallInt，这是所有整数型别中占用
最小空间就能储存 1000这个数字的。如果我们要告诉编译程序，我们要用
特定的型别来储存该数值，那就可以改写为如下的程序代码：  
 
const   
Thousand: Integer = 1000;   
 
当我们宣告了一个常数，编译程序会决定要把这个数据储存在内存的哪个
地方，或者在每次使用到这个常数的时候，把内容复制过去。第二个目标
在处理简单的数据内容时尤其有用。   
 53 一旦我们宣告了常数，我们就可以把常数像其他变量一样使用，只是我们
不能企图变更常数里面的数据，如果我们在指派叙述句里面把常数放在左
值的位置，编译程序就会回报错误。  
__________________________________________________________ _______________  
够奇怪的了， Object Pascal 居然允许我们在运行时间变更常数的内容，等于
把常数当成变量来用，只是我们必须先设定 $J这个编译程序设定，或者透
过适当的编译程序选项，名为 Assigned typed constant 。这个选项的规则是
为了兼容于旧版的编译程序，这作法很明显的，不是我们建议的程序风格，
而我在这里介绍这个功能，也只是为了完整的呈现 Pascal的历史，以及曾
经有过这样的程序技术而已。  
 
  资源字符串常数（ Resource String Constants ） 
虽然这是一个稍微进阶的 主题，当我们定义一个字符串常数，而不是写一
个标准的常数宣告，我们可以使用特定宣告方法：资源字符串常数
（resourcestring ） ，它会告诉编译程序和链接程序要对待该字符串常数如同
对待 Windows 的资源一样。（或在非 Windows 平台上 Object Pascal 对等的
数据结构 ）： 
 
const   
    sAuthorName = 'Marco';  
resourcestring  
    strAuthorName = 'Marco';  
begin   
    ShowMessage ( strAuthorname);  
 
在上述的两个宣告中，我们都是宣告一个常数，在程序执行过程中不能变
更里面的内容，差别只在于程序内部是怎么实作而已。透过 resourcestring
区段定义的常数都会被储存在程序的资源字符串表里面。  
 
简单的说，使用资源的好处就是在 Windows 应用程序处理内存的时候可以
节省更多空间，在其他平台也有类似的机制，这个方法也是在处理多国语
系应用程序时比较好的作法（只需要翻译不同语系的文字内容即可） ，程序
代码的内容就不用做任何修改了。实际执行时，我们需要把所有在程序当
中要显示的文字全 部都以 resourcestring 来宣告，这样一来所有的文字都会
被以 Windows 资源字符串表被储存起来， 我们只需要用 Windows 资源编辑
工具，把资源字符串表的内容进行翻译、另存成另一语系的资源文件，那
么当使用者在不同语系的 Windows 上面执行这个程序的时候，就会加载该筆記   
 54 语系对应的资源字符串表，也就会用该语系的文字内容来显示程序接口跟
讯息，应用程序的文件名也无须修改了。  
____________________________________________________________________ _____  
IDE环境的编辑器有自动 重构 (refactoring) 的功能，我们可以用它来把我们
程序代码里面的字符串取代成对应的 resourcestring 宣告。只要把编辑光标
移到我们要修改的字符串标识符上， 然后按 Ctrl+Shift+L 就可以启动重构功
能了。  
 
  变量的生命周期 (Lifetime) 与可视范围 (Visibility)  
依照我们定义一个变量的方式，变量使用内存的空间与时间都会不一样 (通
常这段时间我们称为变量的生命周期 )，同时也会在程序代码当中不同的地
方对该变量有可辨识与不可辨识的分别（这个界 限我们称之为变量的可视
范围） 。  
 
在这么前面的章节里，我们还没办法完整的把所有可能的选项都介绍完，
但我们可以先试想最常用的几种案例：  
 
 全局变量 ： 如果我们在一个单元的 interface部分宣告了一个变量（或者
其他识别符号，例如类别、常数） ，这个变量的可视范围将会扩及所有
参照 (或叫使用 )了这个单元的所有单元程序代码。程序一开始执行后，
就会尽快为这个变量配置内存空间， 直到程序结束为止都维持这个内存
空间的存在。 我们可以在单元的 initialization 区段指派一个初始值给这个
变数。  
 全局隐藏变数 ：如果我们在一 个单元的 implementation 区段宣告一个变
量，则我们在整个程序的其他单元是无法看到这个变量的，但在这个宣
告变量的单元中的任何一个函式、方法、程序当中则都可以使用这个变
量，这样的变量使用了全局的内存，并且与刚介绍过的全局变量拥有相
同的生命周期， 相异者只有可视范围， 初始化的方法也跟全局变量相同。  
 局部变量 ：如果我们在 任何一个函式、方法、程序当中宣告一个变量，
我们只能在该段子程序当中使用这个变量，一离开该段子程序，就无法
再存取这个变量了。这个变量的可视范围涵盖了该段子程序，以及其下
的其他所有子程序 （除非其 下的子程序当中有用到相同名称作为其他识提示   
 55 别符号之用） 。在内存当中，这个变量是在该段子程序被呼叫的时候由
操作系统配置空间给当时所在的内存堆栈里面， 而该段子程序执行完成
时，配置给这个变量的空间也会自动被回收给系统。  
任何在单元的 interface区段当中宣告的识别符号，在整个程序中都是可视
的，只要该单元有被其他单元使用到。画面窗体类别的变量就是用这个方
法宣告的，所以我们可以在整个程序的任何其他画面窗体中，随时取用任
何一个画面窗体（当然也包含其下的 public范围的方法、属性、以及组件） 。
把所有东西都宣告成全局可视 ，绝对是很糟的程序技巧。除了会占用内存
空间之外，使用全局变量也会使一个程序项目很难维护、更新下去，换句
话说，我们在使用全局变量的时候，应该要尽量精简。  
资料型别  
在Pascal当中，有一些 数据型别 是预先定义好的，我们可以将之区分为三个
组别：有序型别 (ordinal types) 、实数型别，以及字符串。我们会在接下来
的篇幅当中讨论前两个，然后在第六章里面特别介绍字符串。  
Delphi也包含了 未特定型别 的资料型别，称之为 variant，还有另一些有弹性
的数据型别，像是 TValue (是进阶的 RTTI功能的一部分 ，RTTI是RunTime 
Type Information ，运行时间型别信息 的缩写 )。这类进阶的数据型别我们会
在稍后第五章里面加以介绍。  
  有序与数值类型别  
有序型别是根据顺序的概念而来的，我们不只能够算出两个资料之间的大
小，而且还可以得知数据的下一个或前一个数据是什么，当然也能够算出
该数据的最大值与最小值。  
这组类别当中，最重要的三个型别分别是： Integer(整数 ), Boolean( 布尔值 ), 
以及 Char(字符 )。当然，还有其他相同意义的型别，与这三个相异者只在内
部实作的方式，以及可表示的数值范 围，以下的表格列出了有序型别可表
示的数字范围：  
大小 有正负号之分  无正负号之分  
8 bits  ShortInt: -128到127 Byte:0到255 
16 SmallInt: -32768到32767  Word:0到65535 (0 到64K)   
 56 bits (-32K到32K)  
32 
bits Integer: -2,147,483,648 到
2,147,483,647 ( -2G到正 2G) Cardinal:0 到4,294,967,295 
(0到4G) 
64 
bits Int64: -9,223,37 2,036,854,775,808
到9,223,372,036,854,775,807  Uint64:0 到
18,446,744,073,709,551,615  
我们可以发现，这些数据型别各有其可表示的数字范围，端视其所使用的
内存空间大小，以及其表示的数字是否包含正负号。要表示负数的型别，
就会比使用同样空间但不表示负数的型别少了一倍的数字可以表示。  
例如 Int64这个型别可以表示十进制的 18位数数字，函式库中对于这个型别
也支持有序类别的一些子程序 (例如 High跟Low)，以及用来计算的子程序
（像是 Inc跟Dec） ，以及字符串转换的子程序 (例如 IntToStr)。 
    整数类型型别的别名  
有时候我们会很难记住 ShortInt跟SmartInt之间的差异， 例如到底哪一个型别
可储存的数字比较小，这时候我们就可以参考在 System这个单元当中预先
定义的类别别名：  
type   
Int8 = ShortInt;   
Int16 = SmallInt;   
Int32 = Integer;   
UInt8 = Byte;   
UInt16 = Word;   
UInt32 = Cardinal;   
 
请记得，这些型别并没有新增新 的型别，而只是为了容易记忆，例如 Int16
当然比 SmallInt更容易从字面上知道它比 ShortInt(也就是 Int8)来得大。这些
型别别名也让从 C或其他程序语言转换过来 Object Pascal 的程序开发人员
更容易上手。  
    整数型别 , 64位与 NativeInt  
在64位版本的 Object Pascal 里面，我们会觉得很惊讶，因为它的整数型别仍
然还是 32位。这么做的原因，是因为这样对于数字运算最有效率。   
 57 指标型别（我们在稍后的篇幅当中会加以介绍）与其他与内存地址相关的
数据型别都是 64位，如果我们需要 一个值类型转换成指标的大小，并想要
符合 CPU原生平台使用，我们可以使用两个特别的型别： NativeInt 跟
NativeInt 的别名类别。这两个类别会依照操作系统的类型自动调整长度，
在32位系统中，他们就是 32位，在 64位系统中，就会变成 64位。  
    整数型别助手  
整数型别在 Object Pascal 里面是享有特殊待遇的型别， 我们可以在处理整数
变量，甚至于整数型别的常数时，在识别符号后面加上一个 . 就会有跟其
他类别相似的法可以使用喔。  
___________________________________ ______________________________________  
从技术上来说，对原生数据型别的这些操作，都是被定义为要使用『内建
的纪录助手』 （ intrinsic record helpers ） 。 类别与记录的助手会在第 12章介绍，
简单的说，我们可以对核心的数据型别自定操作方法。有经验的开发人员
会发现到，型别的操作方法会被定义为类别的固定方法，以符合内建记录
助手。  
 
我们可以在下面的范例当中看到许多从 IntegersTest 范例项目撷取出来的实
例：  
var 
   N: Integer;  
begi n 
    N := 10;  
    Show (N.ToString);  
    // display a constant  
    Show (33.ToString);  
    // type operation, show the bytes required to store the type   
    Show (Integer.Size.ToString);   
___________________________________________________________________ ______  
上面的范例中， show这个函式是用来把数据显示在一个 Tmemo组件里面的
简单函式，使用这个函式，我们可以先避免太靠近 ShowMessage 对话框，
而顺带的好处， 则是我们可以把执行的结果从 Tmemo组件上直接复制下来，
如下面的执行结果所示，在本书中的大多数范例也都会用这个方式来处理
执行结果 。 筆記  
筆記   
 58  
上面的程序代码执行结果如下：  
10 
33 
4  
这些操作方法的确很重要 (比其他被列在运行时间函式库当中的更重要 )，所
以值得被我们列在这里：  
ToString  把数值转成字符串，以十进制表示  
ToBoolean  把数值转换成布尔型别  
ToHexString  把数值转换成字符串，以十六进制表示  
ToSingle  把数值转换成单精度浮点数型别  
ToDouble  把数值转换成倍精度浮点数型别  
ToExtended  把数值转成 extend浮点数型别  
第一和第三个操作方法会把数值转换成字符串， 分别使用十进制与十六进制
格式来显示，第二个操作方法则是转换为布尔型别，后面三个则是把数值转
成浮点数型别，这个型别我们稍后会介绍。  
整数型别还有一些操作方法我们可以使用的（大多数其他值类型也有） ，例
如：  
Size 该型别使用多少个字节 来存放数据  
Parse  把一个字符串转换成字面上显示的数值  
TryParse  试着把字符串转换成数值， 如果字符串不是合法的数字，
则会回传 0 
  标准的有序型别函式  
除了由整数型别助手定义的方法，以及前列的这些方法，还有一些标准、古
典的函式我们可以用来处理任 何有序型别的（不一定只有数值类的型别） 。
最简单的例子， 就是查询该型别的大小 (SizeOf)、 最大值 (High)、 最小值 (Low)。
SizeOf这个系统函式回传的值（我们可以在任何型别上使用这个函式） ，会 
 59 是一个整数，告诉我们这个型别会使用多少个字节来储 存数据（很像前面提
到的 Size这个方法所做的）  
系统的子程序中，可以用来处理有序型别的函式，我们以下表列出：  
Dec 把参数一的数据递减，如果有参数二，则把参数一递减
参数二所述的数值  
Inc 把参数一的数据递增，如果有参数二，则把参数一递增
参数二所述的数值  
Odd  回传参数数据是否为奇数，如果要测试是否为偶数，请
直接加个  not 在前面做反向运算即可： not Odd 
Pred  回传参数数据的前一个数值，系统会依据参数型别来判
定前一个数值应该是什么  
Succ  回传参数数据的 后一个数值，系统会依据参数型 别来判
定后一个数值应该是什么  
Ord 回传参数的数值在该型别中的序列编号（通常用在非数
字型的有序型别）  
Low 回传参数数据的型别中的最小值  
High  回传参数数据的型别中的最大值  
_________________________________________________________________________  
C和C++语言的程序人员应该要注意， Inc函式这里有两种版本，有一个参
数的版本，也有两个参数的，分别对应 C语言语法里面的 ++和+=(Dec当然
也有两种版本，分别对应 --和-=)，Object Pascal 编译程序会对这些函式进行
优化，就像 C和C++编译程序所做的一样。  
 
请注意，这些函式当中，有些是由编译程序自动计算好，然后直接替换掉其
中的数值的，例如，如果我们呼叫了 High(X)，这里的 X是一个整数型别的
变量，编译程序会自动把该段程序代码直接替换成整数型别的最大值。  
在IntegersTest 范例程序中，我已经为一些有序型别函式加入了一个事件：  
var  
  n: UInt16;   
begin    筆記   
 60    n := Low (UInt16);  
   Inc (n);  
   Show (IntToStr (n));   
   Inc (n, 10);   
   Show (IntToStr (n));  
   if Odd (n) then  
     Show (IntToStr (n) + ' is odd');   
执行结果如下：  
1 
11 
11 is odd  
您可以把上述程序代码里面的 Uint16修改成 Integer或者任何其他的有序型
别，观察看看结果会有什么改变。  
  超过范围的运算  
一个变量都有其有效范围的数值，就像上面这个范例里面的 n一样。如果我
们指派了太大的数值，或者一个 负数给它，上面的执行结果就会是错误的，
事实上一共有三种不同的错误可能会发生在这种超过范围的运算当中。  
第一种是编译错误，会发生在我们指派一个超过范围的常数数值时，例如我
们如果在上面的范例里面加入这行程序代码：  
n := 100 + High(n)  
 
编译程序就会回报错误如下：  
[dcc32 Error] E1012 Constant expression violates subrange bounds   
 
第二种情况，则是编译程序不会回报错误，因为还得看程序执行的时候会不
会导致错误，假设我们在上面的程序片 段中改写成：  
Inc (n, High(n));  
Show(IntToStr(n));  
 
编译程序不会在编译的时候告诉我们程序代码有错， 因为编译程序也无法在
程序执行前预先知道错误可能发生（因为会不会有错，得看 n这个变量的初
始值才知道） 。万一有两种可能性：假如我们编译了，并执行了这个程序， 
 61 我们最后指派了不合逻辑数值给这个变量，则这行程序的动作将会是减法，
这也是最糟的情形，我们不会得到错误，但这个程序也不正确。  
我们能做的（也建议大家这么做）就是把编译程序选项当中的 Overflow 
checking（溢位侦测） 这个选项设成打开，这样一来编译程序就会对类似的
溢位错误进行防御并加以阻拦，在 IntegersTest 范例项目中，我就已经把溢位
侦测的编译选项开启了，所以我们可以在执行的时候看到错误回报。  
  布尔值  
逻辑上的是 (True)与非 (False)被以布尔型别加以表示，这个型别也用来作为
条件判断叙述句， 我们在下一章就会介绍， 布尔值只有两种可能的数值内容，
也就是 True或者 False。 
__________________________________________________________________ _______  
为了跟微软的 COM以及 OLE automation 兼容， ByteBool, WordBool, 以及
LongBool 都以 -1表示 True, 以0表示 False。 然而我们应该可以忽略这三种
特殊的型别，也避免直接用系统定义的数字来表示布尔值，除非绝对必要
的情形。  
 
跟C语言或其他 C阵营的语言不同，布尔值在 Object Pascal 当中是以枚举数据
类型来实作的，所以没有其他数字可以直接被用来表示布尔值。而且我们绝
对要避免把布尔值转换为其他值类型， 即使布尔值的型别助手当中也包含了
ToInteger 跟ToString这两个方法。我会在本章稍后的篇幅当中介绍枚举数据
类型。  
请注意，布尔值的 ToString方法会把布尔值的内容以数值回传，就像我们用
另一个函式 BoolToStr 的结果一样，当我们把第二个参数的内容设成 True，来
表示要在输出中以字符串 (True或者 False)来回传 (请见下面介绍字符型别操
作的范例程序 ) 
  字符 
字符变量是以字符型别来定义的，今日的字符型别已经是以双字节的
Unicode字符来储存数据了，和旧版的单字节是完全不同的。  
_____________________________ ____________________________________________  
Windows 和Mac版的编译程序仍然提供了单字节的字符型别，以 AnsiChar
这个型别来储存单位元的 ANSI字符， 而用 wideChar 来储存 Unicode字符，
Char型别的定义则只是一个型别别名，我们建议只要是处理字符，都一律筆記  
筆記   
 62 使用 wideChar ，如果要处理单字节的数据，别再像以往很多人会用 Char来
处理，现在请改用 Bytes这个类别吧。  
 
如果您需要关于 Unicode字符的定义，包含字符代号与显示关系（当中有不
少深入的主题） ，请阅读第六章，而 在目前这个章节中，我将只 聚焦于字符
类型的核心概念。  
一如稍早在介绍实际值的时候我所提到的， 常数字元可以用文字符号直接来
表示，像 ’k’这个符号，也可以用数值来表示，写作 #78。字符也可以透过 Chr
这个系统函式来表示，例如 Chr(78)，而相对的要把文字内容以数值来表示，
则要透过 Ord这个函式，通常直接用文字符号来表示字符、数字、标点符号
是比较好的。  
当我们在使用特殊字符，例如在 #32以下的控制字符，我们也只能用数值来
表示，以下的列表包含了最常使用的几个控制字符：  
 
  字符型别的运算  
跟其他的有序数据型别一样，字符型别也有几个原生的运算方法，可以让我
们透过在该型别的变量之后加个 .就能直接使用，也就是透过内建记录助手
来处理。  
然而，使用的情境已经相当不同，首先，我们必须在要使用这个功能的单元
当中先 use Character 这个单元，跟其他的转换函式不同，字符型别的助手包
含了一二十个跟 Unicode专属的处理函式，例如 IsLetter, IsNumber 以及
IsPunctuation 这几个查验用的函式，以及 ToUpper, ToLower 这两个转换用的
函式，以下是从 CharsTest 范例当中节录的一些程序代码：  
uses   
  Character;   
...  
var  #8 删除键 
#9 tab定位键 
#10 换行符号 
#13 回到行首 
#27 esc键  
 63    ch: Char;   
begin   
    ch := 'a';  
    Show (BoolToStr(ch.IsLetter, True));  
    Show (ch.ToUpper);  
 
这段程序代码的的结果会是：  
 
True   
A  
_____________________________________ ____________________________________  
字符型别助手当中的 ToUpper 处理函式，已经完全支持 Unicode了，这表
示如果我们传了 Unicode字符的 ù 就会回传大写的 Ù，部分传统的运行时
间函式库当中的函式就没有这么聪明， 而只能处理一般的 ASCII字符而已。  
 
  Char - 有序型别  
Char型别涵盖的范围相当大，但它仍旧是有序型别，所以我们就可以对 Char
型别使用 Inc, Dec这样的函式来取得前一个、下一个字符，就像我们在前面
介绍基础有序型别的章节所介绍的那样。也 可以写个 for循环，把 Char当成
里面用来记录顺序的元素。  
底下是一个简单的范例，用 for循环来显示一些字符，以开始值到结束值的
数字作为要显示的字符数值：  
var  
ch: Char;   
   str1: string;  
begin   
   ch := 'a';  
   Show (ch);  
   Inc (ch, 100);  
   Show (ch);  
 
   str1 := '';  
   for ch := #32 to #1024 do  筆記   
 64      str1 := str1 + ch;  
   Show ( str1)  
在CharsTest 范例的  for 循环当中，把很多文字加入了字符串中，使得执行
结果相当的长，这个字符串是以底下的文字开头的：  
a 
Å  
!"#$%&'()*+, -./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[ \]^_`abc 
defghijklmnopqrstuvwxyz{|}~   
  以Chr函式进行转换  
我们之前已经介绍过 Ord这个函式，可以把字符的数值数据回传，同样的我
们也有另一个函式 Chr可以把数值转换成字符。  
  32位的字符  
虽然目前默 认的字符型别已经对应成 WideChar ，我们还是需要知道 Delphi
也同时提供了一种使用 4个字节来定义字符数据的型别 UCS4Char ，在System
单元当中，定义如下：  
type  
   UCS4Char = type LongWord;  
和UCS4Char 对应的字符串型别是 UCS4String( 定义成 UCS4Char 的数组 )，虽
然这组型别不常用到，但一样定义在 Character 单元里，也是这个程序语言运
行时间函式库的一部分。  
浮点数型别  
不同型态的整数能够表示有序的数据集合，而浮点数则是不具顺序的（虽然
可以进行数值大小的比较，但却不具顺序，因为无从决定下一个数值与目前
的数值要差距多少） ，浮点数型别可以用来表示一些数字的近似值，依据这
些型别的表示范围，会多少有些误差。  
浮点数依照不同型别使用不同长度记录数据，而有不同的格式，以下是在
Object Pascal 里面浮点数型别的列表：   
 65  
以上就是所有不同精确度的浮点数型别， 分别对应了 IEEE定义的标准浮点数
表示方法， 且 CPU都可以直接支持， 指令周期也最快 （精确的说， 应该是 FPU，
也就是浮点运算器才对）  
另外还有两个很特别的不具顺序的数字型别，我们可以用来记录精确，而非
近似值的型别：  
 
所有不具顺序的型别，都没有 High, Low, Ord 这些函数，因为实数型别在理
论上，是可以用来表示不具上限的数值的，有序型别只能储存一定数量的数
据，也就有了边界值。  
 Single 浮点数里面使用空间最小的就是 Single，这个型别
使用4个字节来储存数值， Single这个名字，正意指
着它使用单精度浮点数，这个型别也正对应了其他语
言里面的float型别 
Double 使用Double的型别，就会使用 8个字节来储存数据，
Double这个名字指的就是它使用倍精度浮点数来储
存数据，其他语言中也有使用 Double这个型别，其
他语言的Double也是使用8个字节来储存数据，在旧
版的Pascal当中，这个型别则是被称为 Real。 
Extended  这个型别使用 10个字节来储存数据，但这个型别并不
是所有操作系统都能使用的，在部分的操作系统上，
例如Win64，就被转回了 Double，而其他的语言则
称这个数据型别为 long Double  
Comp 使用8个字节来表示非常大的整数（可以记录到 18位
数的十进制数），由于是整数，透过这个型别来记录，
就可以记录完全准确的数值，不像浮点数只能记录近
似值。 
Currency  同样使用8个字节来记录数字，但固定使用十进制的
四位数来记录小数点数值。跟型别的名字一样，
Currency 型别是用来处理货币数值的，必须精确到
小数点以下四位数， 而且不能有所误差。   
 66   为何浮点数的数值特别不同  
我们来深入讨论一下，当我们观察整数 23的时候，我们可以确切的知道下一
个数字是多少，整数是有限的，因为整数是有序的数值，每次向前或向后的
变化量都是整数 1。 
而浮点数则是用来表示连续的数字， 即使只是表示很小的区段， 请想象一下，
浮点数，也就是实数，就像是一条线，是由无限个点组成的，例如在 23到24
之间到底有几个数？或者说 23.46的下一个数值是多少？是 23.47?23.461? 或
23.4601?由于实数是连续的，所以是完全无法得知的。  
同样的道理，我们可以知道 char型别数值中， w的下一个字符是什么，但完
全无法得知 7143.1562 的下一个数字是什么？我们当然可以判别两个实数之
间孰大孰小，但无法从一个实数推测知道它的下一个数值是什么。  
另一个对于浮点数数值的关键概念， 则是浮点数无法精确记录所有数字的数
值，通常有些数字只能记录其近似值，例如从范例程序 FloatTest摘录的以下
程序代码：  
var  
   s1: Single;   
begin   
         s1 := 0.5 * 0.2;  
         Show (s1.ToString);  
以上的程序执行后， 我们可能会预期屏幕上出现的结果是 0.1, 但事实上它可
能会出现 0.100000001490116 这个接近 0.1的数字， 但结果仍旧不是 0.1， 当然，
如果我们对小数二位作四舍五入，结果就会是 0.1，如果我们把范例中的 s1
型别改成 Double,输出结果就会变成 0.1，FloatTest 也会这样显示。  
____________________ _____________________________________________________  
目前我们还没有时间作对浮点数在计算机的处理进行数学上的深入讨论，
所以我会再这里暂时不再作更多的说明，如果您对于 Object Pascal 语言的
这方面处理有兴趣，我推荐给您 Rudy Velthuis 的精辟文章，您可以从这个
网址看到： http://rvelthuis.de/articles/articles -floats.html.  
 
 
 筆記   
 67   浮点数类别助手与 Math单元 
从前一个程序范例可以看出，浮点 数资料型别也提供了类别助手，我们可以
透过助手直接对特定变量的转换作处理，就像把它当成一个类别实体一样。
事实上，对浮点数型别的处理可是相当多种的。  
以下是对 Single型别的一些处理：  
Exponent  Fraction  Mantissa  
Sign  Exp Frac  
SpecialType  BuildUp  ToString  
IsNan  IsInfinity  IsNegativeInfinity  
IsPositiveInfinity  Bytes  Words  
运行时间函式库也提供了一个名为 Math的单元，在这里面定义了许多进阶
的数学函式，包含了三角函数函式（例如 ArcCosh） ，财务用的函式（例如
InterestPayment ） ，以及统计用的函式（例如 MeanAndStdDev 程序） 。里面包
含了许多数学函式，很多我们可能都没听过，例如 MomentSkewKurtosis （我
想让大家去搜寻一下这个函式的用途）  
Math这个单元在功能上已经非常多元了，但我们还是可以找到许多额外的
Object Pascal 的数学函式库。  
  简单的使用者自定型别  
随着类型的概念，由 Wirth带入 Pascal语言的伟大想法之一， 就是在程序中定
义新数据型别的能力。我们可以透过型别定义，在程序中引入我们自定的数
据型别，例如次范围型别、数组型别、记录型别、列举型别、指针型别，以
及集合型别，最重要的使用者自定型别就是类别（ Class） ，这是 Pascal这个
程序语言面向对象能力的一部分，将在本书的第二部分介绍。  
您或许会觉得型别定义在许多程序语言里面都是很常见的， 没有错， 但 Pascal
是第一个正式以精确定义的方式把它作为一个基本功能的程序语言。 Object 
Pascal仍有一些很独特的功能，例如次范围的定义、列举功能、集合等，将
在接下来的章 节里介绍。更复杂的数据型别（像数组或记录）则在第五章进
行介绍。   
 68   命名与非命名型别  
我们可以为使用者自定型别取个名字，好在后面的程序代码里面使用，或者
直接用在变量上面。在 Object Pascal 的惯例中，是在任何数据型别的名称前
面加个 T开头，包含类别也是如此，但这规则并不只限于使用在类别上。我
会强烈的建议您遵守这个规则，如果您原来是习惯写 JA VA或C#的程序，或
许您会不太习惯，但还是建议您遵守它。  
当您为一个数据型别命名时，您必须在程序代码的 type区段当中宣告（我们
可以在每个单元当中加入数据型别，不限 数量） ，以下则是一个简单的程序
片段，示范宣告几个新的数据型别：  
type   
  // subrange definition   
  TUppercase = 'A'..'Z';   
  // enumerated type definition   
  TMyColor = (Red, Y ellow, Green, Cyan, Blue, Violet);   
  // set definition   
  TColorPalette = set of TMyColor;   
有了这些数据型别，我们就可以宣告一些变量 ： 
var  
       UpSet: TUpperLetters;  
       Color1: TMyColor;  
在上述的情境中，我们使用了命名型别，在另一种情形下，也可以不为这个
新的数据型别命名，如下面的程序代码所示：  
var 
       Palette: set of TMyColor;  
在一般的情形下，我们应该避免使用非命名的数据型别，就像上面这个范例
中所写的，因为这样写，我们没办法把它作为其他函式或者程序的参数。由
于这个语言最后在进行型别比对的时候，会直接以型别名称来比对，而不会
用型别当中 的每个字段定义一一比对， 所以为每个数据型别赋予一个名称就
格外的重要。也要记得在一个单元文件的 interface区段所做的型别定义，将
会让所有使用该单元的其他程序代码都可以辨识它。  
上面的型别定义是什么意思呢？我会用一些篇幅为不熟悉传统 Pascal型别定
义宣告的读者介绍，也会试着把 Pascal的型别定义跟其他语言不同的地方特
别点出来，所以大家不论如何，都可能对以下的篇幅感到有兴趣。   
 69   次范围型别  
次范围型别是把特定范围的数据特别取个名字，所以称为次范围型别。举例
来说，我们可以把一个小范围的整数，例如 1到10，或者 100到1000定为一个
新的型别，或者也可以定义英文字母的大写部分成一个新的型别：  
type   
       TTen = 1..10;  
       TOverHundred = 100..1000;  
       TUppercase = 'A'..'Z';   
在使用次范围定义新型别的时候，我们不用特别写出原始型别的名字，只需
写出该型别的上下限即可，原始型别必须是有序型别，定义出来的新型别则
会是另一个有序型别。当我们把变量宣告为任一个次范围型别时，就只能指
派其范围中的任一数值给该变量，例如这样的写 法就是正确的：  
var  
    UppLetter: TUpperCase;  
begin   
    UppLetter := 'F';   
而以下的写法则是有误的：  
var  
    UppLetter: TUpperCase;  
begin   
    UppLetter := 'e'; // 编译时期会发生错误   
以上这段程序代码会在编译的时候，造成编译程序错误，讯息则会是：
Constant expression vio - lates subrange bounds." 但如果改成以下写法：  
var  
    UppLetter: TUpperCase;  
    Letter: Char;  
begin   
    Letter := ‘e’;  
    UppLetter := Letter;   
编译程序就会接受，如果在运行时间，我们有启用范围检查的编译程序设定
(在Project Option 对话框的 Compiler 分页中 )，就会得到 Range check error 的错
误讯息。这也类似我们前面介绍过的整数型别溢位错误的问题。  
我假设大家在开发程序的时候都会把这个编译程序选项开启， 这样一来在开
发程序的时候就更容易及 早发现问题， 即使有些问题是在程序复合状况下才 
 70 会出错。 我们可以在最后要建立正式版本的程序代码时再把这个编译程序选
项关闭，这样会让最后发布出去的程序执行速度快一些。然而关闭这些选项
后能让程序增加的速度也少到几乎可以忽略， 所以我会建议把这些运行时间
检查的选项都开启，即使已经到了最后要发布阶段的编译作业也一样。  
  列举型别  
列举型别 (通常被缩写成 enums)可以构成另一个使用者自定有序型别。在列
举型别中， 我们不指定特定型别的范围， 而是直接列出其中几个可能的数值，
换句话说，我们只把我们需要的特定数值列出即可，举例如 下：  
type   
   TColors = (Red, Y ellow, Green, Cyan, Blue, Violet);   
   TSuit = (Club, Diamond, Heart, Spade);   
列表当中的每个值都对应一个序号，从 0开始。当我们透过 Ord函式来寻找列
举型态中的特定数值，函式会回传该数值在列举型态中的顺序，以 0为第一
个元素的编号，因此 Ord(Diamond) 会回传 1。 
列举型态有不同的内部表示方法，预设情形下， Delphi使用 8位来表示它，
除非有超过 256个数值被列在列举型 别当中，才会使用 16位来表示，当然也
有32位的表示法，这方法会在需要跟 C或C++的函式库兼容时使用。  
_________________________________________________________________________  
我们可以改变列举型别的预设表示法，可以要求编译程序给一个大一点的
数值范围，只需使用 $Z这个编译程序设定。  
 
  范围列举  
列举型别的特殊常数值可以从其效应将之视为全局常数， 有时在不同的列举
型别当中，也有一些元素的名称会出现冲突，这就是为什么这个语言有支持
范围列举，这个功能可以透过编译程序设定 $SCOPEENUMS 来启用，而要
使用特定列举型别的内容时，就需要把该列举型别的名称写在 前头：  
// classic enumerated value   
s1 := Club;   
// "scoped" enumerated value   
s1 := TSuit.Club;   
_________________________________________________________________________  筆記   
 71 这正是目前 C#一直使用的方法，但在该语言里面，列举的 规则稍微有些不
一样， C#里面可以在列举型别当中留下一个空格，然后再把特定的常数值
指派进去。  
当这个功能被引入时，默认的规则仍沿用了传统的规则，以免使已经写好的
程序代码无法执行。事实上范围列举已经改变了传统列举型别的规则，它使
得列举型别必须强制使用一个型别名称作为前导描述。  
给每个列举值一个绝对的名称，消除了名称重复的风险，有了型别名称作为
列举值的前导描述， 也可以让程序代码更容易阅 读， 不管程序代码写的多长，
都不容易认错。  
举例来说， IOUtils单元当中定义了这个型别：  
{$SCOPEDENUMS ON}  
type  
   TSearchOption = (soTopDirectoryOnly, soAllDirectories);   
这表示我们不能直接使用当中的第二个值 soAllDirectories ，需要使用它的时
候，需要写出它的全名：  
TSearchOption.soAllDirectories  
在FireMonkey 平台的函式库当中使用了许多范围列举型别， 因此我们需要使
用到这些型别的列举值时，就需要写出其完整的名称。  
___________________________________________ ______________________________  
在Object Pascal 的函式库里面，通常会在列举型别的列举值里面名称的前
导字符，例如在前一个例子里，用 so代表 Search Option ，但有了完整的型
别名称作为前导，以字符作为名称前导字符就有些多余了，目前在
FireMonkey 里面的许多列举型态都已经取消原有的字符前导了，例如
alClient 已经改为 TAlignLayout.Client 了。  
 
  集合型别  
集合型别指的是一群数据的集合， 这群数据会以其顺序作为整个型别的有序
基础。这些 有序型别通常是有限个数，而且通常会以列举型别或者次范围来
表示。如果我们以次范围 1..3来表示一个集合型别，则这个集合当中可能的
数值就只会包含 1, 2, 3、1和2, 2和3, 3和1, 或者 1和2和3，或者完全不包含其
中任何一个元素这几种组合，我们可以用数学里的组合来想象它，会是完全
一致的。  筆記  
筆記   
 72 集合型别的变量通常会储存一个集合当中任一个可能的数值组合， 以上面的
例子来说，这个变量可能储存的内容会是：没数据、 1或2或3，或是前述的
组合当中的任一种情形， 也可能包含所有元素， 以下是一个组合型别的范例：  
type   
  TSuit = (Club, Diamond, Heart, Spade);  
  TSuits = set of TSuit;   
现在我们可以定义一个这个型别的变量， 然后存放一些数据到这个变量里面
了。要定义一个集合型别里面的元素，我们得用逗点来分隔每个元素，做成
一个列表，然后以方括号把这些元素括起来，以下的程序代码就示范如何把
多个元素、 一个元素、 没有元素的这几种集合储存到一个集合型别的变量里：  
var  
   Cards1, Cards2, Cards3: TSuits;   
begin   
   Cards 1 := [Club, Diamond, Heart];   
   Cards2 := [Diamond];   
   Cards3 := [];   
在Object Pascal 里面，一个集合通常用来储存几个不重复的数值，例如用来
储存字体样式的变量，就是使用集合型别，这个变量可能包含粗体、斜体、
底线、删除线等样式。所以字体样式当然可以同时包含粗体、斜体，或者没
有包含任何样式。 因此这个变量就使用集合型别来储存，我们可以在程序代
码当中指派任何值给这个集合型别变量，举例如下：  
Font.Style := []; //  没有特别样式  
Font.Style := [fsBold]; // 只有粗体  
Font.Style := [fsBold, fsItalic]; // 同时具备粗体与斜体   
  集合型别的运算方法  
我们已经介绍了集合型别，这是只有 Pascal特有的使用者自定型别，所以也
必须介绍一下集合型别的运算方法。 集合型别的运算方法有连集 (+)、 差集 (-)
以及交集 (*)、是否属于该集合 (in)，以及一些相关的运算方法。要把一个元
素加入集合中，我们可以使用连集 (+)方法，把两个集合进行连接，以下是
用来处理字体样式的相关范 例：  
// 加入粗体  
 Style := Style + [fsBold];   
// 加入粗体和斜体，移除底线（如果底线存在 Style变量当中的话）   
Style := Style + [fsBold, fsItalic] - [fsUnderline];    
 73 当然我们也可以使用 Include跟Exclude这两个程序，这样会比较有效率（但
无法使用在组件的集合型别属性上面） ：  
Include (Style, fsBold);   
Exclude (Style, fsItalic);   
 
表达式和运算方法  
我们已经介绍过， 可以把兼容型别的数据指派给变量、 或把常数指配给变量，
甚至把一个变量的内容指派给另一个变量。在许多情形里，我们也可以把一
个表达式的结果指配给变量储存，包含一个或多个数据的运算，也可能是一
个运算或多个运算的结果。表达式是 Pascal这个语言的另一个核心元素。  
  使用运算方法  
建立表达式并没有一定的规则，表达式只端赖运算方法的使用，在 Object 
Pascal里面有许多运算方法，包含了逻辑运算、数学运算、布尔、实数、以
及集合运算，以下是一些简单的例子：  
//简单的表达式  
20*5 // 乘法  
30+n // 加法  
a<b // 小于（比较判别式  ） 
-4 // 负数  
c=10 // 检验两个数是否相等  (等同于 C语法的  == 符号 )  
 
表达式在绝大多数的程序语言里面都很常见， 且大多数的运算方法与符号也
大同小异。 一个表达式可以是常数、变量、文字数据、运算符号、或者函式
回传结果的任意合法组合，表达式可以用来决定要指派给变量的数据内容，
计算函式或程序的参数，或者检查是否合于特定条件。我们只要有对任一个
识别符号做处理，而不是单纯使用该符号，我们就是在使用表达式了。  
___________________ ______________________________________________________  
表达式的结果通常都会储存为该型别的临时变量，这动作会由编译程序自
动处理好。我们可能会希望用特定的变量来储存这些结果，这样就不用一
直重复同样的运算了。请记得，复合运算就会需要多个临时变量来存放计
算结果，而这些动作已经都由编译程序自动处理好了。  
 筆記   
 74   显示表达式的结果  
如果您想对某些表达式进行实验，直接写个简单的程序最为直接了当，就相
本书大多数的范例， 就是以窗体画面程序建立简单的程序，然后透过自定的
Show函式把某些执行结果显示给用户看。万一我们想显示的内容不是字符
串，而是数字或者布尔逻辑值，我们就必须要做一些转换，例如呼叫 IntToStr
或者 BoolToStr 函式。  
_________________________________________________________________________  
在Object Pascal 里面，所有传给函式或者程序的参数都会以小括号括起来，
有些其他的程序语言，例如 Rebol与Ruby，则会要求我们直接把参数写在
函式或者程序的后面。而 Object P ascal如果遇到重复呼叫程序或函式的情
形时，就只要把第二层或第三层的函数调用写在参数的字段即可，如以下
的范例程序代码：  
 
以下是从 ExpressionsTest 范例中节录的一些程序代码：  
Show (IntToStr (20 * 5));   
Show (IntToStr (30 + 222));   
Show (BoolToStr (3 < 30, True));   
Show (BoolToStr (12 = 10, True));   
执行结果如下：  
  100 
  252 
  True  
  False  
我提供了这个范例作为架构，让您尝试不同型别的表达式与运算方法，并且
可以看到对应的输出结果。  
_________________________________________________________________________  
我们在 Object Pascal 里面所写的表达式，会被编译程序处理，并产生汇编
程序码，如果您想要变更其中一个表达式，就必须修改原始码并重新编译
整个应用程序。然而系统函式库支持动态表达式，可以在运行时间进行计
算，这个功能会在第 16章进行介绍。  
 
 
 筆記  
筆記   
 75   运算方法与其优先性  
表达式是由运算符号和数值所组成的。前面曾提到过，在大多数的程序语言
里面，大多数的运算符号都很相似，例如基本的比对符号。在这个章节里，
我会就 Object Pascal 里面特有的运算符号做介绍。  
以下是 Object Pascal 的运算符号列表， 我们以运算优先级分组， 并和 C#，Java，
Objective -C(以及大多数以 C为基础的程序语言 )的运算符号做一些比较。  
关联与比较运算符号 (优先级最低 ) 
 
相加或相减运算符号  = 测试运算符号两边的识别符号内容是否相同 (C语言
是使用==) 
<> 测试运算符号两边的识别符号内容是否不同 (C语言
是使用!=) 
< 测试运算符号左方的内容是否小于右方的内容  
> 测试运算符号左方的内容是否大于右方的内容  
<= 测试运算符号左方的内容是否小于等于右方的内容，
或左方的运算符号内容是否为右方的子集合。  
>= 测试运算符号左方的内容是否大于等于右方的内容，
或右方的运算符号内容是否为左方的子集合。  
in 测试运算符号左方的内容是否为右方集合的元素之一  
is 测试运算符号左方的内容是否为特定的型别（将在第
八章里面介绍），或实作了特定的 interface( 将在
第11章里面介绍 ) 
+ 数学运算的相加、集合的连集、字符串的连接、指针
内容的相加  
- 数学运算的相减、集合的差集、指针内容的相减  
or 布尔或位数值之间的 or运算(任一者成立即成立 )，在
C语言则是||或| 
xor 布尔或位数值之间的 xor运算(奇数个内容为 true的
时候即成立 )，在C语言的位运算 xor是使用ˆ符号。   
 76  
乘除以及位运算符号  
 
二元运算符号  
 
跟许多其他的程序语言不同， and跟or运算符号的优先级比比对符号来得高，
所以如果我们这么写：  
a < b and c < d  
编译程序会先执行 b and c，所以通常会先出现编译程序错误。所以如果我们
要进行两个比对， 我们得用小括号把两个比对的表达式先包起来， 写成这样：  
(a < b) and (c < d)  
在数学运算中，通则是先乘除后加减，所以前两个表达式是相同的，而第三
个则不一样：  
10 + 2 * 5 // 结果等于  20  
10+(2*5) // 结果等于 20  
(10+2)*5 // 结果等于 60  
有些运算符号在使用到不同数据型别变量的时候，会有不同的意义，例如运
算符号 +，可以把两个数字相加，可以把两个字符串相连，也可以把两个集
合变成连集，甚至可以把两个指标的内容连在一起（如果特定的指标型别有
启用指针 数学功能的时候） ：  * 数学运算的相乘、集合的交集  
/ 浮点数的相除  
div 整数的相除 (在C语言里这个运算也是用 /符号) 
mod 取余数(这个运算只对整数有效，在 C语言是用%) 
as 在运行时间 进行型别确认的转换 (第八章会介绍 ) 
and 布尔或位运算的 AND运算(在C语言则是用 &&和&) 
shl 位向左位移  (在C语言是用<<) 
shr 位向右位移  (在C语言是用>>) 
@ 变量或函式的内存地址，在 C语言则是使用 & 
not 布尔或位计算的 not(在C语言是使用 !)  
 77 10 + 2 + 11   
10.3 + 3.4   
'Hello' + ' ' + world'   
但我们不 能对两个字符做相加，在 C语言里面也不行。  
比较不常见的运算符号是 div，在 Object Pascal 里面，我们可以把任意两个数
字（实数或整数都行）相除，可以直接使用 /这个符号，但用这个符号计算
所得到的结果一定会是实数。如果我们希望两个整数相除，结果也得到整数
的话，就得使用 div这个运算符号。以下是两个简单的数据指派程序代码 (等
我们下一章介绍数据型别之后，这段程序代码就会更容易读懂了 )： 
realV alue := 123 / 12;  
integerV alue := 123 div 12;  
 
要确定整数除法是否有余数，我们可以使用 mod计算，检查看看计算结果是
不是 0，如以下的程序代码：  
(x mod 12) = 0   
 
日期与时间  
早期的 Pascal语言并没有提供原生的日期与时间型别， Object Pascal 则有提供
原生的日期时间型别， 是透过使用浮点数来记录日期与时间信息。 准确的说，
是在 System单元里面，提供了 TDateTime 这个型别来处理日期与时间。  
使用浮点数的原因，是需要足够 的字段来记录年、月、日、时、分、秒，甚
至精确到千分之一秒，这些都记录在一个 Sinlge变量当中：  
 TDateTime 的日期部分是以一个整数数值来记录与 1899 -12-30的差别
（如果是负数的话，则代表该日期是早于 1899年的日期）  
 TDateTime 的时间部分则是以小数部分来记录当时是当天的哪个时间  
_________________________________________________________________________  
如果我们觉得该日期很奇 怪，在这个表示法之后，有着跟 Excel以及
Windows 应用程序用来处理日期的数据处理方式一个很长的故事。因为原
本是以 1来当做 1900年一月一日，所以 1899年的最后一天就是以 0来表
示。然而当时定义这个表示法的开发人员可能忘了 1900年不是闰年，所以
又把起始日向后调了一天，所以 1900年的一月一日又变成了以 2来表示。  
 筆記   
 78 刚刚提到过， TDateTime 不是一个编译程序中定义的预先定义型别，它是在
System单元里面定义的：  
type  
   TDateTime = type Double;   
___________________________ ______________________________________________  
System单元已经几乎可以视为 Object Pascal 语言的一部分了，因为它几乎
会自动被所有的单元文件引入， 即使不写在 uses区段里面 （其实如果在 uses
区段里面写了 System，反而还会引起编译错误） 。技术上来说，这个单元可
以被视为是运行时间函式库的核心，我们会在第 18章介绍它。  
 
还有两个跟 TDateTime 一起用来处理时间与日期的型别，分别是 TDate跟 
TTime，这两个型别只是 TDateTime 型别的别名，但他们常被系统函式用来
去除掉日期或时间当中没有使用到的部份。  
在Delphi里面使用日期或时间型别是相当容易的，因为 Delphi为这个型别提
供了许多处理的函式与方法。这些函式大多都放在 SysUtils单元里面，或者
是放在 DateUtils 单元里面 (其中还有不少是用来处理时间的函式 )。 
以下列出一些常用的日期 /时间函式：  筆記   
 79  
为了示范怎么使用这个数据型别以及其相关的一些函式，我建立了一个范
例，名为 TimeNow ，当范例程序 执行时，会自动把目前的时间与日期显示出
来：  
var  
   StartTime: TDateTime;  
begin   
   StartTime := Now;   
 Show ('Time is ' + TimeToStr (StartTime));   
 Show ('Date is ' + DateToStr (StartTime));   
 
第一行程序是呼叫了 Now函式，然后把目前的日期与时间存放在 StartTime
变量里面。  
 
_________________________________________________________________________  Now 回传内容为现在日期时间的值  
Date 回传现在日期  
Time 回传现在的时间  
DateTimeToStr  把一个时间日期的值转换为字符串， 使用默认的格式。
如果需要更多控 制选项，请使用  FormatDateTime
函式  
DateToStr  把日期时间变量的日期部分转换为字符串  
TimeToStr  把日期时间变量的时间部分转换为字符串  
FormatDateTime  用特定的格式对日期时间进行限定格式显示，我们可
以只选择我们想要显示的日期时间部分数据来显示，
只需要透过格式字符串来设定即可  
StrToDateTime  把一个字符串转换为日期时间值，如果字符串没有符
合格式字符串的设定，系统会传出一个例外。对应的
函式StrToDateTimeDef 则会在遇到系统例外时，
回传预设的值。 
DayOfWeek  回传我们以参数传入的日期时间值是当周的星期几。  
DecodeDate  从日期时间值取出年、月、日各个部分。  
DecodeTime  从日期时间值取出时、分、秒各个部分。  
EncodeDate  把年月日转换成日期时间值。  
EncodeTime  把时分秒转换成时间值。   
 80 当Object Pascal 的函式被呼叫，而没有传递参数时，是不需要多打一组小
括号在上面的，这一点跟 C语言阵营的程序语言不同。  
 
接下来的两行程序代码，则是把 TDateTime 的时间部分显示出来，当然要把
它转换成字符串，我们才看的懂，然后是显示日期部分，执行结果如下：  
Time is 6:33:14 PM   
Date is 10/7/2014   
要编译这个程序，我们需要引入 SysUtils单元（是 System Utilities 的缩写） ，
除了 TimeToStr 跟DateToStr 这两个函式，我们也还可以用更强的
FormatDateTime 函式。  
请留意，日期跟时间值在转换成字符串的时候，会根据系统的语言与地区设
定(Windows Vista/Windows 7/Windows 8) 。这个设定会从系统读取，而后储
存为 TFormatSettings 这个型别的数据结构中。如果我们想要自己设定显示的
样式，我们就得自己依照这个结构的规定，设定好要显示的样式，然后把它
当成参数传给大多数的日期与时间函数。  
_________________________________________________________________________  
TimeNow范例程序当中，还有第二个按钮，我们可以透过它启动一个定时
器。定时器组件可以依照我们的设定，每隔我们设定的时间间隔驱动一次
事件。在这个范例中，如果您按了这个按钮，就会每隔一秒钟更新一次画
面上的时间字符串。更有用的用户接口会是每秒钟更新时间的内容，我们
也可以根据这个逻辑来做出一个时钟程序。  
 
型别切换 (Typecasting) 与转型 (Type  
conversions)  
如我们介绍过的， 在程序代码当中不能把一种型别的内容指派给另一种型别
的变量去。原因是如果每次都要依照数据实际表示的方法来判断，我们可能
会花上许多时间纠结在没有意义的环节上。  
现在对每一种数据型别来说，这倒不一定正确。举例来说，数字型别就永远
可以被标示为向上指派安全型别， 因为我们永远可以把较短的数字型别指派
给较长的型别， 例如我们可以把 Word指派给 integer， 或把 integer指派给 Int64。
但另外一种指派，也就是把较长的数值指派给较短的数值时，编译程序就会
提出警告，因为我们可能只能把部分数值存到新的变量里面，举例来说，我
们可以把整数数值指派到浮点数变量里面，但反之就不行了。  筆記  
筆記   
 81 有些时候我们会想要改变数据型别，使得当时的数据处理合法。当 我们需要
这样做的时候， 我们有两个选择， 第一种是直接进行型别切换 (Type casting) ，
这个作法会把数据复制一份，进行适当的转换。当我们要进行型别切换的时
候，等于是在告诉编译程序说 ”我知道我自己在做什么，让我执行它吧 ”。所
以，在进行型别切换的时候，我们最好真的知道自己在做什么，因为编译程
序不会在这时提出警告了。  
型别切换使用了简单的写法，像是在写呼叫数学函数一样，把要切换过去的
数据型别当成这个数学函数的名称：  
var  
   N: Integer;  
   C: Char;  
   B: Boolean;  
begin   
   N := Integer ('X');   
   C := Char (N);   
   B := Boolean (N);   
在使用同样长度数据储存数据的型别之间进行型别切换是安全的 (因为数据
会完整的被复制到被切换过去的型别数据空间， 上面的范例程序代码就不是
这样喔，那三个型别并不是使用相同长度的空间来储存数据的 )。在有序型
别之间的型别切换通常是安全的，但我们也可以在指标型别（当然，对象也
可以）进行切换，只要我们自己真切的知道这些切换会有什么效应。  
直接进行型别切换，对程序撰写来说是很危险的 ，因为这使得我们可以用另
外一种表现方式来对数据进行处理。 由于不同型别的内部数据储存常常是不
一致的（且在不同平台上也有不同的处理方式） ，我们在这个动作上可能埋
下日后难以找寻的问题，也因为如此， 建议大家应该尽量避免型别切换 ！ 
第二种选择，是在把数据指派给另一种不同数据型别的变量之前，先透过型
别转换函式处理。 以下是我们在不同的几个基本型别上进行转换的常用函式
（在本章的范例中，我也已经使用了其中的几个作为例子） ：   
 82 _________________________________________________________________________  
Round这个函数的实作，是以 CPU的内建功能来处理的 。现代的处理器通
常都会内建一个称为 ”Banker’s Rounding” 的功能， 这个功能会把两个整数之
间的数值 (例如 5.5或者 6.5)向上或向下取为整数，端看他们的整数部分是
奇数还是偶数。或者我们可以使用 RoundTo 这个函数，这个函数就赋予我
们控制权，看是要向上还是向下，不用由 CPU决定了。  
 
在本章前 面的篇幅曾经提到， 这些转换函式有些是直接在数据型别当中就提
供了的（感谢型别助手这个功能） 。当然有些从旧版 Pascal语言就一直存在的
转换程序，例如 IntToStr，我们也已经可以透过大多数数值的型别助手的
ToString来处理了。大多数的型别助手都提供了这些转换功能，但我们可以
自己决定要用哪种方式来做转换， 毕竟我们还是可以决定自己的程序代码风
格要怎么走的。  
有些型别的转换函式我们会在后面的章节里面介绍， 请注意上面的列表并没
有把一些特殊型别包含进去， (例如 TDateTime 或者 Variant)，也没有对一些
对转换的功能提供许多延伸处理的函式做介绍，例如 Format与FormatFloat
这两个函式。  
 
 Chr 把有序的数字转换为字符  
Ord 把有序型别的数值转换为其序号  
Round 把实数型别转换为 整数型别，以四舍五入进行  
Trunc 把实数型别转换为整数型别，以无条件舍去进行  
Int 把浮点数的整数部分转换为整数表示  
FloatToDecimal  把浮点数的内容转换为 10进位表示 
FloatToStr  以默认的数据格式，把浮点数转成字符串  
StrToFloat  把一个字符串转换为浮点数  
筆記   
 83 03:语言叙述句   
 
假如说资料型别的概念是 Pascal程序语言被发明时的创举之一，则另一个
值得相提并论的 ，就是这个程序语言的叙述句了。在当时，这个概念是由
Nicklaus Wirth 的巨作”Algorithm+Data Structures = Programs”( 算法 +数据结
构=程序 )所提出的，这本书是 1976年二月由 Prentice Hall 出版社所出版，
是一本程序概念上的巨作，至今仍有再版。 这本书比面向对象程序设计的
概念早上许多年，可以被视为是现代程序概念的基础之一。以强型别为概
念，并以此为理论基础，最后衍生出了面向对象程序语言的发展。  
 
这个程序语言是以关键词作为叙述句的基础（我们在第一章介绍过了） ， 搭
配其他元素，让我们能够让编译程序得知我们要执行的一系列程序。叙述
句通常会被以程序或函式的方式包装起来，这一点我们会在下个章节介绍，
而目前我们只要先聚焦在我们可以用来撰写程序的一些基本的指令即可。  
 
我们在第一章里面介绍过的（在介绍使用空格符与程序代码样式的篇幅里）
实际上撰写程序是很自由的，我们也介绍了批注与一些特别的元素，但还
没有来得及完整的介绍其他核心概念，像是程序的叙述句。  
 
简单与复合叙述句  
程序指令通常会被称为 叙述句 (Statements) 。一段程序区块可能会由好几个
叙述句组成，叙述句可以分为两种 ：简单与复合叙述句。当一个叙述句没
有包含其他子叙述句的时候，我们称之为简单叙述句，最简单的例子， 就
是指派叙述跟呼叫程序，在 Object Pascal 里面，简单叙述句式以分号来做
分隔的：  
X := Y + Z;  // 指派叙述  
Randomize;  // 呼叫程序  
 
要定义一段复合型的叙述句， 我们可以在 begin跟end之间引入一个或多个
的叙述句。 begin跟end在此扮演着程序代码区块的括号。复合型叙述句可
以出现在任何 Object Pascal 简单叙述句出现的位置：  
begin   
  A := B;   
  C := A * 2;    
 84 end;   
在复合叙述句里面的最后一个叙述句的分号不一定要写：  
begin   
  A := B;   
  C := A * 2  
end;   
 
以上两段程序代码都是正确的，第一段的写法中，最后一句最后结尾的分
号其实是没有用的 （但也无伤大雅） ， 这个分号事实上算是一个空的叙述句，
也就是一句没有程序代码的叙述句，这一点跟其他程序语言是很不一样的，
尤其是对 C语言阵营的程序语言来说，在 C语言阵营的程序语言来说，每
个叙述句结尾的分号都是不可或缺的。  
 
请注意，很多时候，没有程序代码的叙述句，在 内部的循环当中，有时候
也是可以直接出现的，例如：  
while condition_with_side_effect do   
   ; // 没有程序代码的叙述句  
 
虽然最后一个分号并没有特别的作用，大多数的使用者还是习惯写上去，
而我也建议大家要写。因为程序总是需要修改的，常常我们写了一段时间
的程序代码，后来又要在后头加上一些其他的程序代码，这时就不用老是
在寻找最后一行了。但如果多加了一个分号，可是会导致编译程序例外发
生的，最常见的例子，就是在 else前面加上一个分号。  
 
IF叙述句  
条件叙述句是以一个条件来 判断要执行特定区块的程序代码，或者不执行
它（在不符合条件的时候） ，条件判断式的语法关键词有两 个： if跟case。 
 
If叙述句是用来判断符合特定的一个条件，如果符合该条件，就执行该区
块的程序代码  (if-then)，或者合于条件时执行一区块的程序代码，不符合
时执行另一区块的程序代码 (if-then-else)，条件判断需以布尔表达式定义。  
 
我们提供了一个简单的范例 :IfTest来示范如何撰写条件叙述句，在这个程
序中，我们使用了 checkbox 来取得使用者的输入值，透过 checkbox 的
IsChecked 属性（并把它储存在一个布尔变量当中，虽然这么做并不是必要
的，我们可以直接使用该属性的值作为判断式） ：  
  
 85  
var  
   isChecked: Boolean;  
begin   
   IsChecked := CheckBox1.IsChecked;   
   if isChecked then   
      Show ('Checkbox is checked');   
 
如果该 checkbox 有被勾选，程序就会显示一个简单的讯息，不然的话就不
会有任何事情发生，如果上面的这段程序以 C的语法来写的话，就会长得
像这样（C语言的条件判断式一定要用小括号把它包起来） ：  
if (isChecked)   
  Show ("Checkbox is checked");   
 
还有一些程序语言会让 我们用 endif来作为判断叙述句的结尾，好让我们可
以在程序区块当中使用多个叙述句，在 Object Pascal 当中， if后面只能使
用单一叙述句，所以如果我们需要使用多个叙述句的时候，就必须用
begin -end来把带有多个叙述句的 程序区块给包起来了。  
 
如果我们希望 能依照该条件的成立与否分别执行不同的程序代码，就可以
使用 if-then-else这样的语法 (以下的范例中， 我会直接把 checkbox 的属性当
成条件判断式 )： 
// if-then -else statement   
if CheckBox1.IsChecked then   
   Show ('Checkbox is checked')   
else   
   Show ('Checkbox is not checked');   
 
请留意，在 if后面的叙述句，是不可以用分号结尾的，不然编译程序会回
报语法错误，这是因为 if-then-else被当成一个单一叙述句，所以我们不能
在当中使用分号把它切 断。  
 
if叙述句可以很复杂， 当中的条件判断式可以由一连串的条件组合而成 （使
用and, or, not 运算符号） 。而 if叙述句里面也还可以在包含其他 if叙述句，
我们也可以一连串的组合 if-then-else-if-then这样的句子，我们可以任意组
合多个  else-if这样的条件叙述句。  
 
在IfTest范例中的第三个按钮，就示范了这样的情形，透过第一个在 edit 
 86 组件里面输入的字符作为输入判断值：  
var  
   aChar: Char;   
begin   
    // multiple nested if statements  
    if Edit1.Text.Length > 0 then begin   
      aChar := Edit1.Text.Chars[0];  
      // checks for a lowercase char (two conditions)   
      if (aChar >= 'a') and (aChar <= 'z') then   
         Show ('char is lowercase');   
 
      // follow up condit ions   
      if aChar <= Char(47) then   
         Show ('char is lower symbol')   
      else if (aChar >= '0') and (aChar <= '9') then   
         Show ('char is a number')   
      else   
         Show ('char is not a number or lower symbol');   
     end;  
 
要仔细看这段程序代码，然后执行范例程序，看看跟你预期的是否相同，
以类似的程序做练习，我们的程序撰写能力进步的才快。我们也可以用这
个范例当基础，加上多一点条件跟选项，增 加它的复杂度，随我们所想的
去进行程序的改写与测试。  
 
Case 叙述句  
如果我们要判断的条件很复杂，例如对同一个变量的数值要分成多个不同
部分来处理的时候，用 IF叙述句会变得很复杂，这时候我们可以改用 case
叙述句。 Case叙述句可以让我们判断同一个表达式的不同范围的数值，这
些数值必须是常数，而且必须是有序型别的数值，不能重复。最后，我们
也可以在所有列举的范围数值之外，使用 else叙述句，让我们没能预想到
的所有情形都在该段程序代码来处理。 Case叙述句并没有像 endcase这样
的结束关键词，它仍旧使用 end来结尾。  
_________________________________________________________________________  
建立 case叙述句需要使用列举数值，在 case叙述句中是不能使用字符串作
为条件值的，如果要判别不同的字符串内容时，只能用 if叙述句或者不同
的数据结构，例如 dictionary 。 （我们在第 14章会进行介绍）  筆記   
 87  
以下是个简单的范例（是 CaseTest 项目的一部分） ，在这个范例当中，透过
用户输入的整数值来作为 case叙述句的判断资料：  
var  
    number: Integer;  
    aText: string;  
begin   
          number := Trunc(NumberBox1.V alue);  
          case number of  
            1: aText := 'One';  
            2: aText := 'Two';  
            3: aText := 'Three';  
          end;  
          if aText <> '' then  
            Show(aText);  
另一个例子则是前面提到过 的复杂的 if叙述句的延伸，把输入的内容作为
case叙述句的不同判断值：  
case aChar of   
  '+' : aText := 'Plus sign';  
  '-' : aText := 'Minus sign';   
  '*', '/': aText := 'Multiplication or division';   
  '0'..'9': aText := 'Number';   
  'a'..'z': aText := 'Lowercase character';   
  'A'..'Z': aText := 'Uppercase character';   
  #12032..#12255: aText := 'Kangxi Radical';   
else   
  aText := 'Other character: ' + aChar;   
end;   
_________________________________________________________________________  
在上面的范例程序当中，部分的数值范围使用 了次范围数据型别，反之，
大多数的单一数 值则使用了逗点作为分隔符。而超过英数字的字母，则使
用Kangxi Radical 作为显示文字，其中的侦测条件就直接使用数值，因为其
中大多数的文字都无法在 IDE编辑器显示，例如 ”一”，是这个群组的第一
个元素。 （这部份在简体、繁体中文其实是可以正确显示的，只是大多数非
中文用户的操作系统会无法正确显示）  
 
在程序实务上，使用 else来处理未被定义的条件是比较保险的。在 Object 
Pascal里面， case叙述句是用来判定要执行的路径，它并不会自己决定要如筆記   
 88 何选择。 换句话说， 它会执行符合的判断式的分号后面的叙述句或 程序区块，
而不是决定切入点。 换句话说， 它只会执行符合条件的判断式之后的叙述句，
执行完以后就不会执行之后的其他程序代码了。  
 
这跟 C语言系列的程序语言很不一样，在 C系列的语言里面，是用 switch
指令来达成同样的动作 ， 但它是决定了切入点之后， 就从该 点开始执行下去，
除非我们在希望中断的地方写入一个 break叙述句（这个指令在 Java跟C#
跟字面上的指令实作是不太一样的） ， C语言的写法如下：  
switch (aChar) {   
case '+': Text = "plus sign"; break;   
case '-': Text = "minus sign"; break;   
... default: Text = "unknown"; break;   
}  
 
For 循环 
Object Pascal 和其他程序语言一样，都有很传统的重复执行功能，称之为循
环，在 Object Pascal 当中包含了三个循环指令： for, while 跟repeat这三个
叙述句，而后来又加入了 for-in(或者称为 for-each)这个叙述句。 如果您已经
熟悉其他程序语言，那么这些循环您一定不会陌生，所以我会很快的大致
上介绍一下这些循环（ 会点出跟其他程序语言的异同处） 。  
 
For循环在 Object Pascal 里面是以计数器为基础，所以在 For循环执行的时
候，是对计数器做递增或递减处理 。以下是一个简 单的 For循环范例，会
把1-10的数字做加总（是 ForTest范例的一部分） : 
var  
          Total, I: Integer;  
begin   
          Total := 0;  
          for I := 1 to 10 do  
            Total := Total + I;  
          Show(Total.ToString);  
结果当然不奇怪，一定会是 55。Pascal的For循环比其他程序语言没有弹
性(例如每次循环的计数变化量只能是一 )，但这个现象也很容易理解，我们
看看 C语言的 For循环语法就知道：  
  int total = 0;   
   for (int i = 1; i <= 10; i++) {   
     total = total + i;   
 89    } 
在其他的语言中， For循环的变化量是每次执行过之后，由一个表达式来处
理的，所以我们当然可以用我们希望的表达式放在里面来执行 ，要一次跳
两个数字或其他处理法，也都没有问题。但坏处则是有时候会让程序代码
变得比较不容易读懂：  
int total = 0;   
for (int i = 10; i > 0; total += i --) {  
.. }  
而在 Object Pascal 里面，我们对 For循环只能使用单步递增或递减。如果
想要在每次循环执行过后做比较特别的设定或处理，我们可以改用 while
或是 repeat指令。  
 
在For循环当中唯一可以更换的部分，就是递增改成递减，或者称为逆向
循环：  
var  
         Total, I: Integer;  
begin   
         Total := 0;  
         for I := 10 downto 1 do  
           Total := Total + I;  
_________________________________________________________________________  
逆向循环也是很有用的，例如当我们希望对一个列表型的数据结构进行内
容处理，当删除其中的一些元素时，我们通常会逆向而行，以一个正向的
循环，你会影响正在处理到的 元素顺序（例如我们删除了列表中的第三个
元素，原本的第四个元素就变成了第三个元素，而我们本来在第三个元素
的位置，向后移动一个位置（现在的第四个） ，就到了第五个元素 (中间直
接跳过了原本的第四个元素 ) 
在Object Pascal 里面， for循环的计数器不用非得是数字不可，只要是一个
有序型别的数值就行了，例如字符，或者是列举型别都行。这也让我们写
出来的程序代码更容易阅读， 以下就是使用字符型别来做 for循环的一个范
例：  
 
var  
aChar: Char;   
begin  
    for aChar := 'a' t o 'z' do  
       Show (aChar);  
 筆記   
 90 上面这段程序代码 (是ForTest城市的一部分 )会秀出所有英文字母，会以每
行一个字母的方式显示在 Memo组件里面。  
_________________________________________________________________________  
我也提供了一个类似的范例，只是这个范例是使用数字作为计数器，它是
第二章 CharTest 范例的一部分，在该范例中，所有输出的字符会被连接成
一个字符串以后才一次输出。  
 
以下是另一个代码段 ， 用来示范如何使用自定列举型态作为 for循环的计数
器：  
type   
   TSuit = (Club, Diamond, Heart, Spade);   
var  
   ASuit: TSuit;  
begin  
   for ASuit := Club to Spade do  
      … 
这个代码段当中的循环，会把该列举型别的所有数值都处理过一次，我们
也可以透过型别助手进行列举，这样就不用写出该型别的第一个跟最后一
个数值的名称了：  
for ASuit := Low (TSuit) to High (TSu it) do   
在类似的写法中， 用 for循环来让数据结构中的所有元素都跑一遍是很常见
的，在这个案例中，我们可以用以下这段程序片段（它是 ForTest项目的一
部分） ：  
var  
   S: string;   
   I: Integer;   
begin   
   S := 'Hello world';   
   for I := Low (S) to High (S) do   
      Show(S[I]);   
 
这段程序代码是包含着错误的 ，回忆一下，我们要怎么取得这个数据结构
的第一个跟最后一个元素吧。这也是为什 么在类似的情境当中，使用 for-in
循环会比较好的原因，我们在接下来的章节就要介绍 for-in循环，这个 for
循环的特殊用途的叙述句了。  
_________________________________________________________________________  
在Object Pascal 里面， 编译程序是怎么透过 []符号来直接处理字符串当中的
每个元素，在第六章里面我们会再进行介绍，上述的范例，已经可以涵盖筆記  
筆記   
 91 所有可能的情境了。  
_____________________________ ____________________________________________  
  For-in 循环 
微软的 Visual Basic 已经提供了特别的循环结构， 可供一个 list或者 collection
把里面的每个元素都列举一次，称为 for each，后来在 C#里面也加入了类
似的结构，由于 foreach的机制相当开放，也是基于 IEnumerator 这个接口
运作，也是一个标准的程序模式，因此 Java也使用 for这个关键词来提供
两种 for循环。  
 
最近几版的 Object Pascal 也有类似的循环，称为 for-in，在这个 for循环中，
会把整个数组、字符串、 List里面的所有元素都列出来。 Object Pascal 并不
透过 IEnumerator 这个接口，但内部的实作方法也很类似。  
_________________________________________________________________________  
在第 10章里面，您可以在类别中加入 for-in循环来观察这个循环内部的技
术细节。  
_________________________________________________ ________________________  
 
我们用一个非常 简单的容器类别：字符串来作为开始吧，我们可以把字符
串看成是字符的集合 (Collection) ，在前一节的结尾，我们介绍了怎么用一
个for循环来处理字符串中的所有元素。在接下来的范例中，我们也可以用
for-in循环来达到相同的效果，在底下这个名为 Ch的变量，会依序接收到
字符串里每个元素的内容。  
var  
  S: string;   
  Ch: Char;   
begin   
   S := 'Hello world';   
   for Ch in S do   
      Show(Ch);   
 
上面这段程序是 ForTest范例的一部分。 For-in循环比传统的 For循环方便
的地方，就是我们不用花心思去记录字符串的第一个位置、以及最后一个
位置在哪里。因此这种循环更容易撰写与维护。  
 
 For-in循环可以用来读取多种不同数据结构里的元素：  
 字符串里面的字符 (请参考上面的程序片段 ) 
 集合当中的每个元素  筆記   
 92  静态或动态数组里面的元素，也包含二维数组 (将在第五章里面介绍 ) 
 支持 GetEnumerator 的对象类别，包含许多预先定义的类别，像是
StringList 里面的字符串、不同容器类别的元素，处理这些类别的方法
将在第 10章里面介绍。  
 
目前要介绍一些进阶的模式还言之过早，所以我们稍后再回头来看本章节
的这些范例吧。  
_________________________________________________________________________  
在某些程序 语言里面的 for-in循环 (例如 JavaScript) 执行起来特别慢，已经
成了负面口碑了。 但在 Object Pascal 里则不然， 在 Object Pascal 里面的 for-in
循环，效能跟 for循环几乎一样好。为了证明这一点，我在 LoopsTest 范例
程序中加了一些计时用的程序代码，在这个程序中，会先建立一个包含三
千万个元素的字符串，然后再用两种循环来扫描内容。 （循环中的每次作业
都很简单，两种循环所造成的差异不到百分之十，在我的 Windows 机器上
面执行起来，分别用了 62ms跟68ms）而已  
_________________________________________________________________________  
 
While和Repeat 循环 
While -do和repea t-until的意义，是重复执行一个程序区块，直到特定条件
达成。两种写法之间的差异，只在于一个是在执行前检查该条件，而一个
是在执行程序代码之后进行检查而已。换句话说， repeat循环永远会执行至
少一次。  
_________________________________________________________________________  
绝大多数其他的程序语言都只提供一种开放式循环叙述句，大多都像 while
循环。 C语言的语法和 Pascal语法一样，提供了两种语法，分别写成 while
跟do-while两种语法。请注意， C语法的 while判断句是一样的含义，跟
Pascal的repeat -until语法是不同的， until是在条件成立时结束循环喔。  
_________________________________________________________________________  
了解 repeat循环为何至少执行一次是很容易的，请看以下这个简单的范例
程序代码：  
 
while (I <= 100) and (J <= 100) do  
begin  
   // use I and J to c ompute something...   
   I := I + 1;   
   J := J + 1;   
end;   筆記  
筆記   
 93 repeat   
   // use I and J to compute something...   
    I := I + 1;   
    J := J + 1;   
until (I > 100) or (J > 100);  
 
_________________________________________________________________________  
请留意 while跟repeatd当中我用括号括起来的子条件。在这个例子中是必
要的，在编译程序将要执行或进行比较之前 (就像我在第二章里面提到关于
运算符的章节里面提到的 ) 
_________________________________________________________________________  
如果 I或J的初始值比 100大， while循环就会直接结束，但 repeat循环则
会执行一次。  
这两种循环之间另一个关键性的差异，则是 repeat -until的条件是相反的，
又称为反转条件 (符合的时候就脱离循环 )，循环的执行会在 until语句后面
的条件成立的时候，停止执行程序代码。而在 while -do循环里面，则是在
while后面的条件成立的时候才执行其中的程序代码。因此在上面的程序代
码里面，两个循环的判别条件的写法正好是完全相反的。  
_________________________________________________________________________  
反转条件在摩根定律 当中已 经 广 为 周 知  (请 参 考 维 基 百 科 : 
http://en.wikipedia.org/wiki/De_Morgan% 27s_laws)  
_________________________________________________________________________  
  循环的范例程序代码  
要对循环有更多深入的了解，我们得看一些实际案例。在 LoopTest 范例程
序里，点出了固定次数的循环跟开放式条件循环的差异，第一个循环是固
定次数的循环，也就是 for循环，用来依序显示数字：  
var  
I: Integer;   
begin  
    for I := 1 to 20 do  
       Show ('Numb er ' + IntToStr (I));  
end;  
 
同样的输出结果，也可以用 while循环来达成，透过一个内部变量，每次增
加1(记得，我们要在显示数字之后帮这个数字加一 )。透过 while循环，我
们可以自由的设定递增的数值，例如每次加 2: 
var  筆記  
筆記   
 94 I: Integer;   
begin   
    I := 1;  
    while I <= 20 do  
    begin  
       Show ('Number ' + IntToStr (I));  
       Inc (I, 2)   
    end;   
end;   
 
上述的范例程序，会显示从 1到19的奇数。上面这两个循环，作法上是相
同的逻辑，会把程序区块执行固定次数。但执行次数并非在程序代码撰写
的时候就能够预测的，有些程序代码的情形会根据运行时间中变量的变化
或外部条件的变化而有不同。  
_________________________________________________________________________  
在撰写 while循环的时候， 请一定要留意判别条件是不是有可能永远不会成
立，例如以特定变量的大小作为判别条件的时候，要留意该 变量是否记得
在每次执行后有被进行递增或递减，以防变成无穷循环（无穷循环发生时，
会把 CPU完全占用，在多核的操作系统中，会看到特定的一个 CPU使用
率维持着 100%, 直到操作系统把该处理程序删除掉）  
_________________________________________________________________________  
为了示范这种情形，我写了一个 while循环，其判别条件是以计数器为依据
的，但该计数器变量的数值则是随机递增。为了达到这个目的，我使用
Random 函式来建立小于 100的整数。这个程序的执行结果，是会从 0到
99随机选取数字，而这一系列的随机数字则决定 while循环执行的次数：  
var  
I: Integer;   
begin   
    Randomize;  
    I := 1;  
    while I < 500 do  
    begin  
       Show ('Random Number: ' + IntToStr (I));   
       I := I + Random (100);  
    end;  
end;   
 
如果你记得先呼叫 Randomize 这个子程序，它 会重设每次随机数字产生时筆記   
 95 的依据，这样一来每次执行时，所产生的随机数字就会都不一样。以下是
两次执行结果，我们把它并列在一起做对照 : 
Random Number: 1          Random Number: 1  
Random Number: 40     Random Number: 47  
Random Number: 60     Random Number: 104  
Random Number: 89     Random Number: 201  
Random Number: 146    Rand om Number: 223   
Random Number: 198     Random Number: 258  
Random Number: 223    Random Number: 322  
Random Number: 251    Random Number: 349  
Random Number: 263    Random Number: 444  
Random Number: 303    Random Number: 466   
Random Number: 349   
Random Number:  366  
Random Number: 443   
Random Number: 489   
 
请注意，不只是每次建立的随机数字都不一样，也因为 while循环执行的次
数也是透过随机数字产生而决定的，所以每次执行时，会产生几次随机数
字也是每次都不同的，因此上面的执行结果连个数都不同。  
 
  用Break和Continue 指令来中断流程  
尽管循环在语法与执行上有些许不同，但所有的循环都是相同的意义：依
照特定的条件，让程序区块执行许多次。然而有些时候，我们会希望在循
环的逻辑里面加上一些额外的规则。举个例子，我们写了一个 for循环用来
侦测特定字符是否出现（这段程序代码是范例程序 FlowTest 的一部分） ：  
var  
       S: string;  
       I: Integer;  
       Found: Boolean;  
begin   
   S := 'Hello World';   
   Found := False;   
   for I := Low (S) to High (S) do   
      if (S[I]) = 'o' then  
        Found := True;  
  
 96 在程序代码的后段，我们可以藉由检查 found变量的值来得知特定的字符
是否在该字符串里面出现过。这样的写法，程 序会在发现要检查的特定字
符发生后，仍然要把后面所有的字符一一查完才会停止（如果字符串很长，
就会浪费掉许多运行时间）  
 
常用的解决法，是用 while循环来同时检查这两个条件 (循环的计数器跟
Found这个变量的数值 ) 
var  
   S: string;  
   I: Integer;  
   Found: Boolean;  
begin   
   S := 'Hello World';   
   Found := False;   
   I := Low (S);   
   while not Found and (I < = High(S)) do begin   
      if (S[I]) = 'o' then  
        Found := True;  
        Inc (I);   
   end;   
 
上述的程序代码很合逻辑，也很容易读懂，我们还要在上头加一些条件，
如果条件变得越来越多且越来越复杂，要把不同条件合并就会让程序代码
变得更繁复。  
 
这就是为何在 Object Pascal 的语言中，提供了系统层级的子程序让我们可
以在标准的循环执行流程中进行更改的原因了，更改循环执行的指令有两
个：  
 Break指令：让我们 可以中断循环的执行，直接跳到循环外的下一个指
令，中止原本循环还要执行的所有动作。  
 Continue 指令：会从呼叫这个指令的点，跳过以下所有的循环指令，直
接以循环条件的下一个数值从循环开头点继续执行（除非下一个数值
已经超过了循环的终止条件，此情形就会跳出循环了）  
 
使用 Break指令，我们可以把原来检查特定字符是否出现的程序代码改成
以下写法：  
var            
   S: string;   
 97    I: Integer;  
   Found: Boolean;  
 begin   
    S := 'Hel lo World';   
    Found := False;  
    for I := Low (S) to High (S) do              
      if (S[I]) = 'o' then  
      begin  
          Found := True;  
          Break; // jumps out of the for loop   
      end;   
 
另外两个系统函式： Exit跟Halt，则提供了让我们从子程序执行中直接脱
离，以及直接停止整个程序执行 的功能。我们会在下个章节介绍 Exit指令，
通常我们不太会呼叫 Halt（所以这个指令在本书里面将不会加以介绍）  
 
  要介绍 Goto指令了吗 ?绝不！  
事实上除了上述四个指令之外，还有一些方法可以中断程序的执行流程，
在最原始的 Pascal语言里面，有提供了恶名昭彰的 goto叙述句，让我们可
以直接以不同的标签标注在程序代码当中进行跳跃。跟条件判断式跟循环
不同，条件判断式跟循环是让我们在连续的指令中进行特定的中止或排除
部分条件。而 goto这个指令提供的则是不稳定的程序代码跳跃，所以我们
绝不建议在任何程序当中使用它。 我有提过在 Object Pascal 里面不支持这
个指令吗？我可没这么说，但我不会提供任何程序范例，对我来说， goto
指令已经不存在了。  
 
事实上，译者在教授程序写作的时候，也常对学员说，绝对不要使用 goto
这个指令，因为 goto指令的跳跃是毫无判断的，直接用 goto指令跳跃，可
能会让许多变数在未进行初始化之前就被使用，或者造成更多损害，记得，
千万别用这个指令。  
_________________________________________________________________________  
还有一些程序叙述句是我们还没有介绍到的。例如 with叙述句，这个叙述
句是用来处理 record结构的，所以我们会在第五章介绍， With也是另一个
有争议存在的程序功能，不过没有像 goto这么令人深恶痛 绝。  
_________________________________________________________________________  筆記   
 98 04:程序与函式  
 
在Object Pascal 语言里面强调的另一个重要观念（和 C语言的概念极为相
似） ，就是子程序的概念。基本上子程序的概念就是把一系列的指令 集合起
来，并赋与一个独特的名字，子程序可以被呼叫许多次。子程序（或者称
为函式）是透过它们的名字进行呼叫的。透过子程序的存在，我们可以重
复使用相同逻辑的程序代码，不用一再重复撰写相同的程序代码。这样一
来就在整个程序中需要使用该段程序逻辑的地方使用同样版本的程序代
码。从这个观点来看，我们可以把子程序看成是封装机制的基础。  
 
程序与函式  
在Object Pascal 里面，子程序存在两种形式：程序 (procedure) 和函式
(function) 。理论上，程序是我们要求计算机执行的一个动作，而函式是计
算后要把数据回传 的动作。两者之间的差异，是函式会回传结果，这个回
传的结果可能是数值、型别，而程序不会回传任何数据。在 C语言里面，
只提供了单一语法，就是函式，当不回传数据的时候， C语言就要求程序
人员把回传数据的型别写成 void，C语言的这个作法就完全等同于 Object 
Pascal的程序。  
 
两种写法的子程序都可以传递多个相同或不同型别的参数，我们稍后会介
绍，程序跟函式都是类别 (Class)当中用来实作方法 (method)的基础，而在这
个案例中，两种形式的区别仍旧存在。事实上，跟 C, C++, JA VA, C# 或
JavaSc ript都不同，我们在宣告函式或者方法的时候，仍旧会用到 procedure
或者 function这两个关键词。  
 
实务上，除了宣告用的关键词不同，程序跟函式之间的差异微乎其微：我
们可以宣告函式，然后最后不回传数据，或者完全不管回传值，这样就可
以把函式当成程序来用 （这可能会导致一些小错误发生） 。 也可以在程序中，
透过传址（ call by reference ）的参数把最终结果回传给呼叫它的程序代码，
这样也可以把程序当成函式来用（关于传址的参数，在本章稍后会介绍） 。  
 
以下是用 Pascal语法定义一个程序的写法， 会使 用到 procedure 这个关键词，
这段程序片段是范例程序 FunctionTest 项目的一部分：  
        procedure Hello;   
 99         begin  
         Show ('Hello world!');   
       end;   
 
比较一下，如果用 C语言的语法来撰写上面这个子程序的功能，写起来应
该会几乎完全相同。在这里面没有关键词，也不要求参数，且不用回传任
何资料：  
 
void Hello ()  
{ 
   Show ("Hello world!");   
};  
 
事实上 C语言的语法在撰写程序跟函式时完全相同。而在 Pascal语言的语
法中，函式还需要一个特殊的关键词与回传值 (或者回传的型别 )。 
_________________________________________________________________________  
在Object Pascal 的语法中，还有一个地方跟其他语言不同的，就是在函数
声明的时候，结尾处必须用冒号来宣告函式要回传的数据型别 。 
 
在函式的撰写中，有两种写法可以用来定义最后的回传值，一个是直接把
回传值指派给函数名称，另一种则是指派 给Result这个关键词 : 
 
// 传统写法  
function DoubleOld (V alue: Integer) : Integer;   
begin   
    DoubleOld := V alue * 2;  
end;  
// 现代写法  
function Double (V alue: Integer) : Integer;   
begin   
    Result := V alue * 2;  
end;  
 
______________________________________________________ ___________________  
Object Pascal 的语法中，其实还有第三种写法可以用来指派回传值，我们会
在本章的『附带回传值离开』这个小节进行讨论。  
 
透过 Result这个变量， 而不使用函式名称来指派回传值， 是比较现代的作法，筆記  
筆記   
 100 同时也让程序代码比较容易阅读，直接把回传值指派给函数名称，是传统
Pascal的写法，近代已经比较少用了。  
 
我们再以 C语言的语法作为对照，把上面的范例程序代码改写成 C语言，
可以写成这样：  
int Double (int V alue)  
{ 
  return V alue * 2; 
}; 
 
相对于这些子程序的定义撰写法，呼叫这些子程序的语法就相对直觉的多，
我们只需要直接输入子程序的名字，如果子程序需要参数的话，则以小括号
把这些参数括起来即可。如果子程序不需要参数，则在呼叫的时候连空的小
括号都可以省略了（这当然也是跟 C语言作为对照的， C语言就算子程序没
有要求参数，也得输入个空的小括号才行） 。以下的程序片段都是本章范例
项目 FunctionsTest 的一部分：  
// 呼叫程序   
Hello;   
// 呼叫函式   
X := Double (100);   
Y := Double (X) ;  
Show (Y .ToString);   
 
这也是我们已经介绍过的『程序封装』的概念，当我们呼叫 Double这个函
式，我们不用知道里面使用的算法，也不用知道它是怎么被实作出来的，如
果我们事后又找到了另一个把数字做 Double的更好的方法，我们可以再写
另一个 Double函式来替换原本的 Double函式，而呼叫 Double函式的所有
程序代码都不用再改动。  
 
同样的原则也可以套用在 Hello程序上：我们可以直接修改 Hello这个程序
来改善程序输出的作法，而原本呼叫 Hello的程序代码则完全不用更动，只
要修改完 Hello函式，所有原本使用 Hello函式的地方全部一起受益，以下
就是我们修改程序实作的写法：  
 
procedure Hello;  
begin  
   Show ('Hello world, again!');   
end;    
 101  
  预先宣告  
当我们需要使用一个识别符号，编译程序必须预先得知这个符号，并且必须
知道这个识别符号将会指向的参考地址。为了满足这个需求，我们必须在使
用任何识别符号之前先提供完整的定义。然而，有些情况下这个要求很难达
成。如果程序 A呼叫程序 B，而程序 B又呼叫程序 A，当我们开始撰写这
个程序代码 的时候，我们等于是在呼叫一个编译程序还没看到的程序。  
 
在这个情形下 (还有很多情形也会有类似的情况发生 )，我们可以先宣告一个
函式或者程序， 把完整的名称、 参数都宣告好， 但不用提供完整的程序代码。
要做到这一点，我们只要把完整的程序或函数名称宣告写好，最后加上一个
forward关键词即可，例如：  
 
procedure NewHello; forward;   
 
在程序代码后段，我们再把完整的程序代码写好 (这种写法，实作的程序代
码跟预先宣告必须位于同一个单元文件里面 )，这样一来，我们就可以在完
整的程序代码还没出现之前 ，就直接呼叫它了，以下就是这样的例子：  
 
procedure DoubleHello; forward;   
procedure NewHello;  
begin  
    if MessageDlg ('Do you want a double message?',   
       TMsgDlgType.mtConfirmation, [TMsgDlgBtn.mbY es, TMsgDlgBtn.mbNo],  0) = mrYes then   
       DoubleHello   
    else   
       ShowMessage ('Hello');  
end;  
procedure DoubleHello;   
begin   
   NewHello;   
   NewHello;  
end;  
_________________________________________________________________________  
上面的程序片段中所用到的 MessageDlg ，是 FMX框架里所提供的一个简
单的方法，让我们可以透过对话框询问使用者进行确认 (在VCL框架里面
也有类似的方法，也很容易使用 )，其参数是讯息、对话框的种类、我们要筆記   
 102 显示给用户看到的按钮，最后的回传值则是用户点击的按钮种类。   
这样的功能 (上面的程序片段也是范例项目 FunctionTest 的一部分 )让我们可
以写出互相呼叫的递归情形： DoubleHello 呼叫 Hello，但 Hello也可以呼叫
DoubleHello 。换句话说，如果用户一直点选 Yes按钮，讯息就会一直被显
示，而且每次点选 Yes的时候，确认对话框就会再多问两次。在递归的程序
代码里面，一定要有递归的终止条件，以避免相互呼叫直到堆栈溢出 (stack 
overflow) 的情形发生。  
_________________________________________________________________________  
函式在呼叫的时候，是使用堆栈来记录参数、回传值、局部变量等内存空
间的。如果一个函数持续呼叫自己，成为了无穷循环，堆栈所使用的记忆
空间 (通常是预先定义好的固定大小 )将会很快用完，使程序不正常停止，这
种错误情形，就是大家所熟知的堆栈溢出 (stack overflow) 。而最近几年，也
有个很热门的程序开发网站用了这个域名提供给程序人员一个问题交换讨
论的平台，这我想应 该就不用介绍了： http://www.stackoverflow.com/   
 
虽然在 Object Pascal 里面已经不常使用预先宣告， 但有个类似的案例还是很
常见。当我们在一个单元文件的 interface区段宣告程序或函式时，这个宣告
就已经被视为预先宣告了，虽然我们宣告的时候并没有用上 forward这个关
键词。实际上我们本来就无法在 interface区段撰写程序代码，同时我们则必
须要在 interface区段有宣告函式的同一个单元文件里面， 把该函式或程序进
行实作。  
 
  递归函数  
关于之前我提到的递归，我们 先来看一个比较特别的例子 (透过两个函式互
相呼叫 )，然后再观察一个比较传统的递归案例，也就是函数调用自己。使
用递归也常用来当做另类的循环实作方法。  
 
从传统的例子看起，假设我们要计算一个数字的多次方，而手边没有适当的
函数 (其实这个函式在 Object Pascal 的RTL里面就有了 )。 那我们就只能从数
学上的定义来分析了， 例如 2的3次方， 就是 2乘自己乘三次， 也就是 2x2x2.  
 
所以实作这个函式的一个方法，可以是写一个 for循环，执行三次 (或者是几
次方，就乘几次 )，把乘法的计算结果再乘以要计算的基底数字：  
 
function PowerL (Base, Exp: Integer): Integer;   
var  
   I: Integer;   筆記   
 103 begin   
    Result := 1;  
    for I := 1 to Exp do  
      Result := Result * Base;   
end;   
 
另一个替代方案，则是直接乘以该函式的下一次方执行结果，直到下一次方
为0，因为任何数字的 0次方都是 1，所以我们可以把 0次方当成是递归调
用的终止条件，把这个函式以递归方式实作：  
 
function Powe rR (Base, Exp: Integer): Integer;  
var  
   I: Integer;   
begin  
    if Exp = 0 then  
      Result := 1   
    else   
        Result := Base * PowerR (Base, Exp - 1); 
end;  
 
这个程序的递归版本执行起来并没有比 for循环的版本来的快，也没有比较
容易读懂。然而像是在分析程序结构时 (例如树状结构 )，要处理的元素并不
是固定的，因此要用一个 for循环来处理也几乎是 不可能的，因此递归在这
种案例中，就显得格外有用了。  
 
通常递归函式的程序代码功能都比较强，但也比较复杂。经过多年以后，递
归几乎被遗忘了， 和早期的程序相较， 新的函式化语言， 像是 Haskell, Erlang
和Elixir都大量使用递归，并使递归的观念渐渐回归主流。您可以在
FunctionTest 的范例程序中找到两种写法的次方函式。  
_________________________________________________________________________  
范例程序里面的两种次方函式都没 有处理负次方的能力，如果把次方的参
数传个负数进去，就会造成无穷循环了。同时因为使用了整数型别，也会
很快达到该型别的最大值，并造成数值溢位。我撰写这些程序代码时，也
同时保留了这些先天的限制，好让程序代码能保持简洁。  
 
 
 筆記   
 104   方法(Method) 是什么 ? 
我们已经介绍了要怎么在单元文件的 interface区段透过 forward关键词进行
预先宣告。在类别的型别当中宣告方法，也可以视为一种预先宣告。  
 
但『方法』到底是什么？  
 
方法，是程序或函式与记录或类别相关的特别型态。在 Object Pascal  里面，
每当我们为视觉组件处理事件的时候，我们就需要定义一个『方法』 ，通常
是一个程序，但『方法』这个名词，是用来指属于特定类别 (或记录 )的函式
或程序，所以同时包含两者。  
 
以下是一个由 IDE自动产生的空白方法程序代码， 是属于一个 form的(其实
只要属于类别即可，我们在本书稍后的章节会介绍 ): 
 
procedure TForm1.Button1Click(Sender: TObject);  
begin  
   {here goes your code}   
end;   
 
参数与回传值  
当我们呼叫函式或者程序的时候，我们必须传 递正确数目的参数，并且必须
确认所有参数的型别都跟宣告的相同。要不然，编译程序就会指出这里有错
误，例如参数型别不符。以前面的定义的 Double函式当例子，它是要求整
数作为参数，所以如果我们这样呼叫：  
Double(10.0);  
编译程序就会指出这个错误 : 
[dcc32 Error] E2010 Incompatible types: 'Integer' and 'Extended'   
_______________________________________________________________ __________  
编辑器在我们撰写程序的时候，会提供我们即将呼叫的函式或程序的所有
可能参数清单，这个提示会以一个提示窗口的样式出现，当我们输入某个
函式的名字，并输入了一个小括号，这个窗口就会出现了，这个功能称为
程序代码参数 (Code Parameters) ，它算是 Code Insight 技术的一部分 (在其他
IDE环境中则称之为 IntelliSense)  
 
有些时候，是允许限制型别转换的，例如进行指派，但通常我们应该试着使
用特定型别的参数 (这称之为强制性的参数参照，我们稍后会进行介绍 )。 提示   
 105 当我们呼叫函式 的时候，我们可以把一个表达式作为参数，不用限制传递一
个数值。这个表达式会在执行的时候被运算，运算结果则作为参数被传递到
子程序里面去。在单纯的情形下，我们只把变量名字传递进去。在这个例子
里，变数的数值则是被复制到该参数里 (参数的名称通常和原来的变量名字
不一样 )。我强烈的建议绝不要把同名的变量传给函式当参数，因为光看上
去就很容易让人混淆。  
 
最后，请记得我们可以用同一个函式或程序的名字，但提供不同版本 (这个
技术被称之为多载， overloading) ，也可以在函式或程序里面忽略一些参数，
改以预设的数值来传递 (这个技术则被称为预设参数 )。这两个在函式跟程序
上的重要技术，都会在本章稍后的篇幅加以介绍。  
 
  附带回传值离开  
我们已经介绍过从函式回传结果的几种不同语法 (和C语言或者从 C衍生的
其他语言对照 )。不光是语法不同，其规则也相异。把回传数值指派给 Result
关键词 (或者函式名称 )，并不会像执行 return指令一样结束函式的运行。  
 
Object Pascal 开发者通常受惠于此功能，可以把 Result当成一个暂时的储存
空间，与其这样写：  
function ComputeV alue: Integer;  
var 
   value: Integer;  
begin  
    value := 0;  
    while ...  
      Inc (value);  
    Result := value;  
end;   
 
我们可以省下暂时变量，直接使用 Result，不管 Result的内容到函式结束的
时候是什么，都会是用来回传该函式最后的数值：  
function ComputeV alue: Integer;  
begin  
    Result := 0;  
    while ...  
       Inc (Result);  
end;   
 106 换句话说，也有一些情形，是我们会想要指派好回传值以后，立刻就。离开
程序的。例如在特定的 if判断式里面，如果我们想要指定函式的结果，并
且直接中止当下执行中的程序代码。我们当然应该使用两个独立的函式：先
指派结束的数据给 Result关键词，而且立刻使用 Exit函式脱离子程序。  
 
假如您记得程序代码里面的 FlowTest( 在”用Break和Continue 指令来中断流
程”章节里面介绍过 )的项目程序代码，现在的作法可以视同为重写一些函
式，用来替换掉呼叫 Break，然后接着呼叫 Exit。我已经把程序写在以下的
程序片段里面 了，它是 ParamsTest 这个范例程序的一部分。  
function CharInString (S: string; Ch: Char): Boolean;   
var  
   I: Integer;   
begin   
   Result := False;   
   for I := Low (S) to High (S) do   
      if (S[I]) = Ch then  
      begin  
             Result := True;  
             Exit;   
      end;   
end;   
 
在Object Pascal 里面，我们可以把 if判断式成立时要执行的两个指令，用一
个Exit指令来取代， Exit指令可以直接把要当做回传值的数值当成参数，就
像C语言里面的 return指令一样。 所以我们可以把上面的程序代码写的更精
简，也就可以省下一个 begin -end的区块了：  
 
function CharInString2 (S: string; Ch: Char): Boolean;   
var  
   I: Integer;   
begin   
    Result := Fa lse;  
    for I := Low (S) to High (S) do   
       if (S[I]) = Ch then  
          Exit (True);  
end;   
 
  
 107 _________________________________________________________________________  
在Object Pascal 里面， Exit是一个函式，所以回传值必须括在小括号里面，
C语言的 return是一个编译程序的关键词， 所以 return不用把回传值用小 括
号当成参数括起。  
 
  引用参数 (Reference Parameters)  
在Object Pascal 里面， 程序和函式传递参数时， 包含了传值和传址两种方式。
预设的参数传递是以传值的方式进行的： 作为参数传递进入子程序的数值或
变量，会被复制一份放在堆栈里，子程序将会使用复制出来的这份数值在整
个子程序里面使用，所以即使在子程序里面修改了这个复制的数值，呼叫前
的参数变量或数值，也都不会有任何改变。 （就像我们稍早在函式的参数与
回传值章节所介绍的那样）  
 
透过传址的方式来传递参数，则表示不会复制数据到子程序里面去 ，而是会
把当做参数的变量内存地址传进子程序， 让子程序直接使用该参数的内存地
址，因此子程序只要对这个参数做了任何修改，就会同时修改到呼叫子程序
时所传递的变量内容。要使用引用参数，在宣告参数的时候，只要在参数前
面加个 var关键词即可。  
 
这个技术在大多数的程序语言里面都有提供，也因为不用复制变量内容，通
常程序执行的速度会快上一些。这个作法在 C语言里面就没有提供 (我们可
以使用指标来达成一样的效果 )，但在 C++跟其他使用 C语言语法的语言里
面则也有提供此功能，我们可以透过＆这个符号 (意味着传址 )来达成传址的
目的。以下 是使用 var关键词提供引用参数的写法 : 
 
procedure DoubleTheV alue (var V alue: Integer);   
begin   
   V alue := V alue * 2;  
 end;  
 
在这个案例中，参数既扮演了传递数值让子程序进行计算的角色，也同时把
计算完成的结果带回给呼叫它的程序，也就是回传值的角色。如果我们这么
写：  
var  
X: Integer;   
begin   
   X := 10;  筆記   
 108    DoubleTheV alue (X);  
   Show (X.ToString);  
 
变量 X的内容会在呼叫了 DoubleTheValue 函式之后变成 20，因为这个函式
使用的是引用参数，会直接使用变量 X的内存地址，直接影响变量 X的内
容。  
 
跟传统的传值参数规则比较一下，引用参数所传递的不只是参数里面的数
值，而是把整个参数传过去，所以引用参数不能接受把常数、表达式、函式
的回传值，或是类别的属性当成引用参数传递。另一个规则则是不能传递不
同型别的变量 (必须要先经过转型 )。变量的型别跟参数的型别必须完全一
致，不然编译程序又要抱怨有错了：  
 
[dcc32 Error] E2033 Types of actual and formal var parameters must be identical   
 
如果我们这么写，编译程序就会抱怨而显示上面的错误讯息 (下面的程序片
段是范例程序 ParamsTest 的片段，不过我已经把它加上批注符号了 )： 
 
var  
C: Cardinal;   
begin   
   C := 10;  
   DoubleTheV alue (C);  
 
以引用参数来传递有序型别或记录型别 (我们会在下一章介绍 )的参数是很
有用的。这些型别通常被称为值类型，因为它们的语法含义原本就是传值或
者指派数 值的作法。  
 
Object Pascal 的字符串跟对象则是完全不同的规则， 我们稍后会更深入讨论。
对象变量原本就是内存地址，所以当我们把对象当做参数传递的时候，本来
就会变动到该对象的原始内容。 这些型别比较特殊， 通常被称为 『参考型别』 。  
 
除了标准的引用参数型别之外， Object Pascal 还提供另外一种很特别的参数
关键词 : out。out参数不用具备初始值，它只用来把数据回传给呼叫者，除
了不用提供初始值以外，其他的规则， out跟var几乎都一样。  
 
 
____________________________ _____________________________________________   
 109 out参数是为了兼容 Windows 的COM模式而被创造出来的。除了在
Windows COM 模式与对象的程序代码，在其他程序中几乎没有被使用过，
通常 out参数会被认为在效能上会比 var参数来的好  
 
  常数参数  (Constant Parameters)  
除了引用参数之外，参数还有一种称为常数参数，我们可以在参数前面加上
const关键词。使用了 const关键词的参数，在子程序里面会被当成常数，我
们不能把值指派给常数参 数，编译程序可以对参数的传递进行优化。编译程
序会选择类似引用参数的作法 (或者像 C++里面所提到的常数地址 )，但这个
规则会很像是传值参数，因为原始数值在子程序里面是不能被更动的。  
 
事实上如果我们试着编译以下的程序代码 (是可以的， 但我已经在 ParamsTest
项目里面把它标注为批注了 ): 
 
function DoubleTheV alue (const V alue: Integer): Integer;   
begin   
   V alue := V alue * 2; // compiler error   
   Result := V alue;  
end;  
 
这里面的错误我们很难一眼看出是怎么回事，错误讯息是：  
[dcc32 Error] E2064 Left side cannot be assigned to   
 
常数参数常被用在字符串型别上，因为在这种情形下，编译程序会先暂时停
止参考计算器制 (Reference Counting mechanism) ，以进行优化。同样的，如
果我们在使用 ARC(自动参考计数 : Automatic Reference Counting) 的Object 
Pascal里面传递常数对象的话 ，结果也会一样的。这个主题在本书稍后还会
进行介绍：在这里提到这个主题还是需要的，因为这些优化正是使用常数参
数的常见原因：对于有序型别与可调整型别提供受限的功能。  
 
  函式的多载  (Function Overloading)  
我们常常会需要提供两个类似的函式， 让其中的参数跟实作的程序代码各有
些不同。在传统的写法里，我们只能乖乖的用另一个函式名称来制作第二个
函式。但现代程序的写法，则可以用同一个函式名称，透过不同的参数，对
同一个名称的函式进行 多载。 
多载的含义很简单： 编译程序允许我们使用同一个函式或程序的名称 制作多筆記   
 110 个函式或程序，只要其中的参数不同即可。事实上，透过检查参数，编译程
序就可以判断我们要呼叫的是哪一个版本的函式或程序。 我们可以看一下以
下这一些函式，它们是从 Object Pascal RTL (Run -Time Library, 运行时间函
式库 )当中的 System.Math 单元文件里面节录出来的：  
 
function Min (A,B: Integer): Integer; overload;   
function Min (A,B: Int64): Int64; overload;   
function Min (A,B: Single): Single; overload;   
function Min (A,B: Double): Double; overload;   
function Min (A,B: Extended): Extended; overload;   
 
当我们呼叫 Min(10, 20) 的时候，编译程序会判断我们是呼叫第一个函式，
所以回传值也会是整数。  
 
多载有两个基本规则：  
 多载的每个函式 (或程序 )宣告，结尾都必须加上  overload这个关键词。  
 在多载的每个函式 (或程序 )宣告中，参 数的数量或型别必须要有不同，
参数名称则无所谓，因为名称在呼叫过程中不会被特别指出，而回传值
并不会被拿来作为两个多载函式的判别，换句话说，多载函式 (或程序 )
当然可以回传相同型别的数据。  
_________________________________________________________________________  
规则上有一个例外状况，就是我们不能以回传值来做为多载函式 (或程序 )
的区别依据， 且用 Implicit或Explicit转换运算符， 这会在第五章里面介绍。  
 
以下是 ShowMsg 程序的三个多载版本，我已经把他们放在 OverloadTest 范
例程序里面了 (这个应用程序用来展示多载与预设参数 ): 
procedure ShowMsg (str: string); overload;   
begin   
   Show ('Message: ' + str);   
end;   
procedure ShowMsg (FormatStr: string; Params: array of const); overload;   
begin   
   Show ('Message: ' + Format (F ormatStr, Params));   
end;   
procedure ShowMsg (I: Integer; Str: string); overload;   
begin   
   ShowMsg (I.ToString + ' ' + Str);   
end;   筆記   
 111  
这三个程序都会用讯息框来显示一个字符串， 分别以不同的方式对字符串做
格式化，以下就是三个不同呼叫这些程序的程序代码：  
ShowMsg ('Hello');   
ShowMsg ('Total = %d.', [100]);   
ShowMsg (1 0, 'MBytes');   
 
而结果分别如下 : 
Message: Hello   
Message: Total = 100.   
Message: 10 MBytes   
_________________________________________________________________________  
IDE的Code Parameters 技术对多载的程序与函式处理的非常好。当我们在
编辑器上面输入了函式名称，且输入了小括号，所有同名的多载函式就会
一起被自动列出。当我们输入参数的时候， Code Insight技术则会依照我们
输入的参数型别自动判别符合的多载函式，隐藏其他不符型别的。所以在
撰写程序代码的时候就轻松多了。  
 
如果我们试着呼叫某个函式， 然后传递完全不合其中任何一个多载版本的参
数进去会怎样？当然， 我们会得到编译程序给的错误讯息， 假设我们要呼叫：  
ShowMsg(10.0, ‘Hello’);  
 
我们就会得到以下这个很特别的错误讯息 : 
[dcc32 Error] E2250 There is no overloaded version of 'ShowMsg' that can be cal led with these 
arguments   
 
事实上，多载函式的每个多载版本都必须标注上 overload的关键词，所以我
们不能试着多载相同单元文件里， 一个已存在但没有标注 overload关键词的
函式，如果我们试着这么做，就会得到以下的错误讯息：  
Previous declaration of '<name>' was not marked with the 'overload' directive.   
 
然而，我们可以在别的单元文件里面建立一个新的函式，然后把这个新单元
文件当成命名空间来处理。在这个 情形下，我们就不是新增一个多载版本函
式，而是把原来的函式用一个完全新版的同名函式来取代了，原来的函式会
被编译程序视为被隐藏了 (当然还是可以直接把该单元文件的名称作为前述
字符串，来呼叫原始版本的函式 )，这也就是为什么编译程序不能只从参数
来判断，就决定用哪一个多载版本，但编译程序也会试着用唯一相符的多载
版本函式来处理，但仍会在参数型别不相符的时候发出错误讯息。  提示   
 112  
  多载与呼叫混淆  (Ambiguous call)  
当我们呼叫一个多载函式时，编译程序通常会试着找到一个相符的多载版
本，或者在找不到相符的多载版本时 发出错误讯息 (就像我们刚刚看过的例
子一样 )。但还有第三种情况：假设编译程序能够对函式的参数进行型别转
换，则对单一个函数调用就有可能有不同的转换。当编译程序发现它可以使
用的多种多载版本函式，而其中并不包含完全相符的参数型别，则此时编译
程序发出的错误讯息就会是『此函数调用发生混淆』 。  
 
这种情形并不多见，我得建立一个不合理的范例来说明这个情形，但观察这
个案例是值得的 (虽然实际撰写程序的时候发生的机率非常之低 )。假设我们
决定要实作两个多载版本的函式来处理整数跟浮点数的加总：  
 
function Add (N: I nteger; S: Single): Single; overload;   
begin   
    Result := N + S;  
end;  
function Add (S: Single; N: Integer): Single; overload;   
begin   
    Result := N + S;  
end;  
 
这些函式都在 OverloadTest 范例项目里面。现在我们可以呼叫它们，指派两
种不同的参数给它们：  
 
Show (Add (10, 10.0).ToString);   
Show (Add  (10.0, 10).ToString);   
 
然而，事实上通常一个函式可以在参数经过型别转换后接受该参数，例如一
个函式要求浮点数型别，但可以在整数资料经过型别转换以后接受它，所以
我们可以写成：  
Show (Add (10, 10).ToString);   
 
编译程序会使用第一个多载版本，但第二种多载版本也会被呼叫。如果不知
道我们的要求 (或者知道呼叫该版本时，仍有其他多载版本可能导致这种问
题时 )，则以下错误讯息就会被回报出来：  
[dcc32 Error] E2251 Ambiguous overloade d call to 'Add'    
 113    Related method: function Add(Integer; Single): Single;   
   Related method: function Add(Single; Integer): Single;   
_________________________________________________________________________  
在IDE的错误讯息面板里，我们可以看到上述讯息的第一行，在该行错误
讯息的左边有个加号，点开它 ，就可以看到其他的完整错误讯息了。  
 
如果我们在实际上写程序的时候遇到上面这个情形， 而我们真的需要呼叫这
个函式，我们可以自己先做型别转换来解决这个问题，并让编译程序可以判
别我们要呼叫的是哪一个多载版本：  
Show (Add (10, 10.ToSingle).ToString);   
 
实际会发生混淆呼叫的情形，会是我们使用 variant这种型别作为参数的时
候，因为这个参数型别可以包含许多种不同特定型别，我们在本书稍后的篇
幅会加以讨论。  
 
  预设参数  (Default Parameters)  
另一个跟多载相 关的技术， 是在函式或程序的参数里面可能先设定了预设的
参数值， 所以在我们呼叫函式的时候， 写不写该参数都可以被编译程序接受。
如果我们没有指定该参数，编译程序就会以默认值传给该函式或程序。  
 
我们来看一个例子 (这个例子仍旧是 OverloadTest 范例项目的一部分 )，我们
可以定义以下的程序来封装对 Show函式的呼叫，提供两个预设参数：  
 
procedure NewMessage (Msg: string; Caption: string = 'Message'; Separator: string = ': ') ;  
begin   
   Show (Caption + Separator + Msg);   
end;   
 
藉由上述的定义，我们可以用以下的方式来呼叫这个函式：  
NewMessage ('Something wrong here!');   
NewMessage ('Something wrong here!', 'Attention');   
NewMessage ('Hello', 'Message', ' --');  
 
会得到以下的输出结果 : 
Message: Something wrong here!   
Attention: Something wrong here!   
Message --Hello   提示   
 114  
请注意，编译程序没有建立任何特别的程序代码来协助预设参数，也不用为
这个函式制作任何多载版本。没有输入的参数，编译程序就自动的加入到呼
叫函式的程序代码里去了。只有一个简单的规则要遵循：我们不能跳过任何
一个参数，例如我们不能只提供第一跟第三个参数，然后只跳过第二个。  
 
当然定义上还是有一些其他的规则，呼叫上也有些要注意的地方 : 
 在呼叫时，我们必须从最后一个参数开始跳过，如果我们要跳过参数，
就得从最后面一个一 个来。  
 在定义上，有默认值的参数必须放在整列参数的最后面。  
 默认值必须是常数，显然的，这也限制了预设参数能够使用的型别，像
是可变数组、 interface就不能以 nil之外的值来当成其默认值，而 record
更是完全不能当成预设参数。  
 有默认值的参数必须以传值形式进行，或者当成常数 (const)。传址 (var)
的参数是不能有默认值的。  
 
同时使用预设参数和多载，我们就有更多机会可以让编译程序昏头转向，例
如发出混淆呼叫的错误提示，就像我们前一节介绍过的那样。举例来说，如
果我在前一个范例里面加入以下的新版多载函式：  
procedure NewMessage (Str: string; I: Integer = 0); overload;   
begin   
   Show (Str + ': ' + IntToStr (I))   
end;   
 
这时编译程序并不会发出错误通知，因为这是个合法的定义。然而以下这个
呼叫：  
NewMessage ('Hello');   
 
则会导致编译程序提出错误讯息：  
[dcc32 Error] E2251 Ambiguous overloaded call to 'NewMessage'   
    Related method: procedure NewMessage(string; string; string);   
    Related method: procedure NewMessage(string; Integer);   
 
请注意这个错误是发生在新的多载版本出现前， 编译完全正确的一行指令上
面。实务上我们应该不可能呼叫 NewMessage 这个程序，而只提供一行字符
串作为参数，或者提供一个字符串参数与整数参数做为其默认值。当有类似
的疑虑时，编译程序就会要求程序人员把其意图表 示的更明确一点。   
 115 内嵌程序代码  (Inlining)  
在Object Pascal 当中内嵌函式和方法是低级语言的功能，透过这个作法，可
以得到显著的优化。通常当我们呼叫一个方法，编译程序会建立一些程序代
码，让我们的程序进入一个新的执行点。这表示设立了一个堆栈框架，并开
始处理一些程序，可能需要一些机器指令。然而，我们执行的方法可能非常
简短，甚至呼叫一个方法可能只是设定或者回传一些私有字段。  
 
在这种情形下，复制这些程序代码到实际呼叫它们的地方，就非常有用了，
可以避免堆栈框架的设定或其他相关事情的衍生。 去除了这些 额外的动作之
后，我们的程序当然可以执行更为快速，特别是当这个函式在循环当中被呼
叫了上千上万次的时候，每次省一点时间，整个执行过程所节省的时间就更
为可观了。  
 
对于一些很小的函式来说，回传值的程序代码甚至更小，这些程序代码可能
比呼叫一个函式本身所耗用的空间来的更小。然而，请注意到，假如一个稍
大的函式是内嵌的， 而这个函式在我们的程序代码当中很多不同的地方都有
呼叫到这个函式，我们的程序代码可能变得比较大，而这对于执行档来说，
会是不必要的空间增加。  
 
在Object Pascal 里，我们可以要求编译程序把一个函式 (或方法 )进行内嵌，
内嵌的关键词是 inline，只要在宣告函式或方法的程序代码之后加上 inline
这个关键词即可。不用在定义函式的地方重复这个关键词。请牢记， inline
关键词对编译程序来说只算是个提示，编译程序仍旧可能判断该函式 (或方
法)以内嵌方式编译对整个程序来说并没有好处，而直接把这个关键词给忽
略不管 (不会提供任何警告讯息喔 )。编译程序也可能在完成分析所有程序代
码之后，依照 $INLINE 开关的状态，把部分函式或方法给内嵌，但不会把所
有函式完全都内嵌。这个开关可能是以下三种不同的设定值之一 (请注意，
这个功能是独立于编译程序优化的设定之外的喔 )： 
 默认值， {$INLINE ON} ，对有标注要进行内嵌的函式或方法全部进行
内嵌。  
 {$INLINE OFF} ，我们可以停止所有内嵌的处理，可以针对整个程序、
部分程序或者特定的函式，除非有出现 inline关键词的函式，否则其余
全部内嵌的功能都会被停止。  
 {$INLINE AUTO} ，编译程序通常会对我们标注 inline关键词的函式进
行内嵌，也会把一些很短的函式自动内嵌，使用这个设定的时候务必小
心在意，因为可能让我们的执行程序 文件变大。  
  
 116 在Object Pascal 的运行时间函式库里就有许多被标注 inline关键词的函式。
举例来说， Math单元里的 Max函式就被这么定义的：  
function Max(const A, B: Integer): Integer; overload; inline;   
 
为了实地测试内嵌这个函式的效果，我在 InliningTest 项目里面，写了以下
的循环：  
var      
   sw: TStopWatch;  
    I, J: Integer;  
 begin  
     J := 0;  
    sw := TStopWatch.Start New;  
    for I := 0 to LoopCount do  
       J := Max (I, J);  
    sw.Stop;   
    Show ('Max ' + J.ToString +   
       ' [' + sw.ElapsedMilliseconds.ToString + '] ');  
 
在这段程序代码里面， System.Diagnostics 单元的 TstopWatch 记录，这是一
个会持续监控从 Start指令 (或者 StartNew 指令 )被下达之后所耗费的时间 (或
者系统 CPU的周期 -ticks)，呼叫 Stop之后，这个监控就会停止。  
 
这个窗体有两个按钮，两个都会呼叫同一个函式，但一个在呼叫的时候停用
了inline开关。请注意，我们必须使用 Release组态来编译，才能看出两者
之间的不同 (因为内嵌是属于 Release优化的一部分， Debug组态不会对它有
反应 )。在我的计算机上面进行了 2千万次 (这个数字是 LoopCount 的常数 )
的互动以后，得到了以下的数字 : 
// on Windows (running in a VM)   
Max on 20000000 [17]   
Max off 20000000 [45]   
// on Android (on device)   
Max on 20000000 [280]   
Max off 20000000 [376]   
 
我们该怎么解读这些数据？在 Windows 系统上，内嵌程序快了将近一倍的
速度，而在 Android系统上面，内嵌程序也快了将近 35%。然而在 Android
装置上面执行的速度比计算机慢上许多 (这个差距可是一个数量级的差距 )，
所以我们在 Windows 上面节省了 3秒钟，而在 Android装置上，这个内嵌 
 117 的优化省下了将近 10秒钟。  
 
同样的程序还进行了第二个类似的测试，是透过 Length函式来进行。这个
函式有编译魔术在里面，会因为内嵌的优化而有很大的不同。再一次，进行
内嵌的版本在 Windows 跟Android上面都有非常明显的变快：  
// on Windows (running in a VM)   
Length inlined 260000013 [11]   
Length not inlined 260000013 [40]   
// on Android (on device)   
Length inlined 260000013 [40 1]  
Length not inlined 260000013 [474]   
 
这是用来作第二种测试的循环：  
var  
   sw: TStopWatch;  
   I, J: Integer;  
   sample: string;  
begin   
   J := 0;  
   sample:= 'sample string';  
   sw := TStopWatch.StartNew;   
   for I := 0 to LoopCount do   
     Inc (J, Length(sample));  
   sw.Stop;  
   Show ('Length not inlined ' + IntToStr (J) +   
         ' [' + IntToStr (sw.ElapsedMilliseconds) + '] ');   
end;   
 
Object Pascal 的编译程序并不会清楚定义一个用内嵌或特定结构排除被内嵌
的方式 (for或是 while循环，条件式指令 )建立的函式，编译出来的程序代码
要限制多大的 Size。然而因为把一个大的函式进行内嵌，得到的优点跟让我
们的程序暴露在风险的缺点相较 之下，得到的少，失去的多，所以我们应该
避免这么做。  
 
其中一个限制， 是这个函式或方法不能参考到任何定义在同一个单元文件的
implementation 区段的识别符号 (例如型别、全局变量或函式 )，而他们在呼
叫的程序代码中也不能被使用到。然而，如果我们呼叫的是一个区域函式，
则内嵌这个函式就不会有任何问题了，编译程序会遵照我们的要求，把这个 
 118 函式进行内嵌。  
 
内嵌函式也有一个缺点，就是会使得单元文件要被编译的更频繁，当我们修
改了一个内嵌函式， 所有呼叫到这个函式的单元文件就需要重新编译才能使
用修改后的程序代码。在同一个 单元文件里面要呼叫内嵌函式的话，就必须
要在内嵌函式的程序代码之后才能呼叫它，所以我们要使用内嵌函式的话，
最好把它写在整个单元文件的 implementation 区段中，作为第一个函式。  
_________________________________________________________________________  
Object Pascal 使用单次编译过程的编译程序， 所以我们无法使用还没编译程
序代码的函式。  
 
如果是在不同的单元文件， 我们就必须把包含内嵌函式的单元文件加入到我
们的 uses区段，即使我们没有直接呼叫这些方法也一样。假设我们的 A单
元文件呼叫了 B单元文件里面的一个内嵌函式，如果这个函式又呼叫了 C
单元文件里面的另一个内嵌函式的话， 我们的 A单元文件就必须也要引入 C
单元文件。不然的话，我们会在编译的过程看到编译程序的警告讯息，提示
无法内嵌该函式，因为缺少了一些被参考的单元。相关的作用就是如果单元
之间相互参考，则这里面的所有内嵌函式都不会真的被内嵌。  
 
函式的进阶功能  
如果目前我们所介绍的已经包含函式相关的核心功能， 那么还有几个进阶的
功能也值得一提。如果您是软件开发的初学者，然而您可能已经 想跳过本章
剩下的篇幅，直接去看下一章了。  
 
  Object Pascal 呼叫函式的约定 (Conventions)  
不论何时，当我们的程序呼叫一个函式，两边都必须同意实际上参数从呼叫
端被传递到被呼叫端的实务作法，这些我们称之为呼叫约定。通常，呼叫函
式时，会把参数 (如果有回传值的话也透过同样的方式传递 )透过内存堆栈区
进行传递。然而，参数或回传值在内存堆栈里面的顺序，会随着程序语言与
操作系统的不同而有差异。多数程序语言都使用各自多种不同的呼叫约定。  
 
很久以前， 32位版本的 Delphi提出了一种传递参数的新方式 ，称之为
fastcall， 在任何时候， 三个以内的参数可以直接透过 CPU的缓存器 (Register)
进行传递，这个方式会使得函数调用的速度快上许多。 Object Pascal 预设使
用fastcall这种方式作为呼叫约定，因此也需要使用到 register这个关键词。  
 筆記   
 119 而问题来了，因为这是预设的呼叫约定，因此使用这个约定的函式就无法兼
容于外部函式库，例如 Win32版的 Windows API 。Win32 API 的函式必须使
用stdcall(Standard call: Windows 的标准呼叫 )作为呼叫约定， 而原 始的 Pascal
的呼叫约定则是 Win16 API 的cdel，也就是 C语言的呼叫约定。这些不同的
呼叫约定在 Object Pascal 里面全都兼容， 但是我们不常使用跟默认值不同的
呼叫约定，除非我们需要使用到透过不同程序语言撰写的函式库，例如系统
函式库。  
 
我们需要使用到不同于预设呼叫约定的情形， 就是当我们需要使用到一个操
作系统的原生 API时，这时我们会被要求使用该平台专属的呼叫约定。即
使是 Win64，使用的呼叫约定也跟 Win32不同，所以 Object Pascal 支持很多
不同的选项，在这里我们先不详述。而行动作 业平台常常愿意揭露类别，而
不揭露原生函式。即使在这种情形下，我们也必须考虑到尊重该平台的呼叫
约定的问题。  
 
  程序型别  (Procedural Types)  
另一个 Object Pascal 独特的功能，则是程序型别的存在。这是很进阶的程序
语言问题，只有很少数的程序人员会常用到它。然而，既然我们在后面的章
节会讨论其他的议题 (例如方法指标，在整体环境的技术上大量使用，用以
定义事件处理程序、以及匿名方法等技术 )，那我们就该花点时间在这里浏
览一下这个主题了。  
 
在Object Pascal 里(不是在传统的 Pascal语言里面喔 )，存在着程序型别的概
念(这个概念像极了 C语言里面函式指针的概念 -在C#跟JA VA里面都舍弃了
这个功能，因为这个功能会和全局变量紧密结合 )。 
 
程序型别的宣告会需要指定一连串的参数以及回传值来定义函式。举个例
子，我们可以宣告一个新的程序型别，需要一个整数参数以传址形式传入：  
type TIntProc = procedure (var Num: Integer);   
 
这个程序型别兼容于具备完全符合的参数的程序 (用C语言的用语来说，就
是函式特征相同 )，以下就是一个兼容于前述型别的程序：  
 
procedure DoubleTheV alue (var V alue: Integer);   
begin   
   V alue := V alue * 2;  
end;   
 120  
程序型别通常有两个要求：我们可以以程序类型声明变量，或者把程序型别
当成参数型别传给另一个函式。假设前述的型别跟程序宣告属实，我们可以
写下这些程序代码：  
var  
   IP: TIntProc;  
   X: Integer;   
begin   
   IP := DoubleTheV alue;  
   X := 5;  
   IP (X);  
end;  
 
这段程序代码跟较短版本的程序代码效果相同：  
var  
   X: Integer;   
begin   
   X := 5;   
   DoubleTheV alue (X);  
 end;  
 
第一个版本明显的比较复杂，所以我们什么时候，为什么要用它？某些情形
下，能够决定要呼叫哪个函式，并实际上稍晚再呼叫它，是很有权力的。要
找到能够达成相同目标的范例是完全可能的。然而，我希望我们能看一个比
较单纯的例子，叫做 ProcType 。 
 
这个范例是以两个程序作为基础，一个函式用来把参数值算出两倍的值为
何，这个函式我们已经看过 很多次了。范例基于两个函式，其中之一用来把
参数的值加倍。另一个函式则是用来把参数数值的数字变成三倍，所以这个
名称就改为 ”TripleTheValue”:  
procedure TripleTheV alue (var V alue: Integer);   
begin   
    V alue := V alue * 3;  
end;  
虽然没有直接呼叫这些函式，其中一些已经被存成程序型别的变量了。这个
变量会在用户选择一个核取方框 (checkbox) 时有一些改变，目前的程序是以
传统方式仿真用户点击按钮。这些程序使用了两个全局 变量 (被呼叫的函式，
以及当前的现值 )，所以这些数值都会被经年累月的保留下来。以下是完整 
 121 的程序代码，请以真实程序的完整定义把这些数据封装起来吧：  
var  
   IntProc: TIntProc = DoubleTheV alue;   
 V alue: Integer = 1;   
procedure TForm1.CheckBox1Change(Sender: TObject);  
begin   
    if CheckBox1.IsChecked then   
      IntProc := TripleThe V alue   
  else   
        IntProc := DoubleTheV alue;  
     end;  
procedure TForm1.Button1Click(Sender: TObject);   
begin   
    IntProc (V alue);  
    Show (V alue.ToString);  
end;  
 
当用户点击复选框 (checkbox) ，改变了组件的状态，所有按键点击时都会呼
叫一个实际的程序，所以如果我们点了按钮两次，改变了选取状态，然后再
点按钮两次，我们会先把参数成倍 两次。然后再把现值先变成两倍，再变成
三倍，如下所示：  
2  
4 
12 
36  
 
另一个使用到程序型别的实例，是当我们要把一个函式传递给操作系统时，
例如 Windows( 通常在操作系统中都有所谓的 callback函式 )。在这个章节要
开始的时候有提到过， Delphi程序人员使用方法指针来处理程序化型别 (我
们会在第 10章介绍 )以及匿名方法 (我们在第 15章加以介绍 )： 
_________________________________________________________________________  
最常用的面向对象机制，就是取得一个稍后进行绑定的函式 (是一个可以在
运行时间进行变更的函式 )，也就是虚拟方法。当虚拟方法在 Object Pascal
里面非常平常， Object Pascal 的程序化方法并不寻常。这些技术的基础，都
相当的类似，虚拟函式跟多型将会在第 8章进行说明。  
 
  宣告外部函式  筆記   
 122 系统程序的另一个重要元素，是由外部宣告的函式来承担的。最早使用到外
部函式库连结的程序代码，是以汇编语言撰写的。外部连结函式变成非常普
及，始于 Windows 程序里面呼叫动态链接函式库 (DLL, Dynamic Link  
Library)。外部函式的宣告，表示具备能够呼叫一个函式，该函式未必由编
译程序或链接程序制作或掌控，但必须具备能够加载外部动态函式库，并执
行当中函式的能力。  
_________________________________________________________________________  
无论我们什么时候在 Object Pascal 程序代码里面呼叫某个平台专用的 API，
我们都会失去把该程序编译成其他平台的能力。唯一的例外，是我们把呼
叫特定平台的程序代码透过 $IFDEF编译开关包起来。  
 
举例来说，我们在 Object Pascal 程序代码里面呼叫了 Windows API 的函式。
如果打开 Winapi.Windows 这个单元文件来看，我们会发现里面有很多的宣
告跟定义，长得像这样：  
// forward declaration   
function GetUserName(lpBuffer: LPWSTR; var nSize: DWORD): BOOL; stdcall;   
// external declaration (instead of actual code)   
function Ge tUserName; external advapi32   
         name 'GetUserNameW';  
 
我们很不常有机会需要写上面这样的程序代码，因为他们已经被列在
Windows 单元文件以及其他系统单元文件里面了。 我们只有在需要使用到自
定的 DLL里面的函式时，或者需要呼叫一些系统没有宣告、转译成 Pascal
宣告语法的 Windows API 时，才会需要写这样的宣告。  
 
上述的宣告，是意指在 advapi32 这个动态链接函式库里面，存在着
GetUserName 这个函式 (advapi32 是一个宣告 过的函式库名称，完整档名是
advaoi32.dll) 。GetUserName 提供了 ASCII与WideString 两种版本，而在做
外部函数声明的时候， 我们可以自己指定让外部函式在我们的程序代码里面
用另一个不同的函式名称。  
 
  延迟加载动态链接函式库的函式  
在Windows 操作系统里，提供了两种方式来呼叫 Windows SDK 与其他 API
的函式：我们可以让应用程序加载器把所有外部函式都先行解译，或者在我
们需要的时候才自行加载特定的函式。  
 
这样的程序代码并不难写 (就像我们前一节看过的 ): 我们要做的事，就是 做筆記   
 123 个外部函数声明而已。然而如果函式库，或者我们要呼叫的函式，在所有版
本的 Windows 系统里面都没能找到，我们的程序就会无法在没有提供该函
式库的 Windows 操作系统上面执行。  
 
动态加载提供了很大的弹性，我们得自己处理加载函式库的程序，使用的是
GetProcAddress API ，来找到我们想呼叫的函式，然后把该函式的指标转换
成适当的型别之后就能呼叫它了。这样的程序代码是相当繁复且容易出错
的。  
 
这就是为什么 Object Pascal 编译程序跟链接程序支持 Windows 操作系统层
级的功能，当需要使用该函式 库的时候才延迟加载该函式，且已经用在部分
C++编译程序上会大受欢迎了。这个宣告的目的并不是为了避免 DLL的错
误载入，反正这情形总是会发生的，而是为了让 DLL里面的特定函式得以
被延迟载入。  
 
基本上我们写程序的方法跟传统执行 DLL的函式非常相似，但函式的地址
早在程序第一次被呼叫的时候就被解析出来了， 并不是在程序加载时就解析
好的喔。这表示如果当时函式无法被使用，我们就会看到一个运行时间例外
发生了 (EExternalException) 。然而，我们通常可以检查我们要加载的目前操
作系统的版本，或者特定函式库的版本， 然后决定是否要呼叫这个函式。  
_________________________________________________________________________  
如果我们想要使用比例外处理更简单、明确的方式来处理这种情形，我们
可以直接挂载 (hook)到延迟加载函式的错误处理机制。 Allen Bauer 在他的部
落格上面有很精辟的说明 :  
http://blogs.embarcadero.com/abauer/2009/08/29/38896  
 
从Object Pascal 语言来看，对于外部函 数声明的唯一不同，就是宣告方法，
以前我们可能会写成 : 
function MessageBox;   
      external user32 name 'MessageBoxW';   
 
但我们现在可以写成 (这也是从 Windows 单元文件里面节录出来的 ): 
function WindowFromPhysicalPoint;   
      external user32   
      name 'WindowFromPhysicalPoint' delayed;   
在运行时间，考虑到这个 API是在 Vista之后 (Vista的代号是 Windows 6.0)
的版本才有的，在首次加载的时候，我们可能会想把程序代码写成这样：  
if CheckWin32V ersion (6, 0) then   筆記   
 124 begin  
    hwnd := WindowFromPhysicalPoint (aPoint);   
 
比起旧版的 Windows 里，同样功能的程序写法，这段程序已经是少到不能
再少了。 (真的，译者也举双手双脚同意 ) 
 
另一个相关的观察，则是我们可以在建立我们自己的 DLL，以及从 Object 
Pascal里面呼叫这些 DLL的函式时使 用同样的机制。我们可以提供单一的
执行档，让这个执行档能够和同一个 DLL的不同版本进行绑定，这样我们
就可以透过延迟加载函式的功能来使用该函式的新版本了。  
 
重申一次，这个功能几乎都是跟 Windows 程序设计相关的，而且在其他高
阶抽象概念的操作系统里面并没有实现相同的功能， 即使其他操作系统开放
了像是类别或比纯粹 C语言函式更高阶的抽象概念 (这些概念现今还是
Windows API 的核心 )。 例如像是外部宣告、 延迟加载这些技术， 已经是 Object 
Pascal编译程序技术的一部分，我想，是值得我们在这个章节好好观察一番
的。   
 125 05:数组与记录  
 
我们在第二章介绍数据型别的时候，曾经提到过 Object Pascal 同时存在数
据型别与型别建构子。型别建构子的简单例子是列举型别，会在本章介绍。  
 
型别定义的力量，来自更多高深的机制，像是数组、记录与类别。在本章
的篇幅中，我们先介绍前两个，他们的本质可以追溯到 Pascal语言被定义
出来的初期，但经过了这么多年以后，也已经有所改变 (变得更强了 )。现在
的版本几乎已经跟原来的定义完全不同了，只剩名字还被留着。  
 
到本章的结尾，我也会稍微提到一些 Object Pascal 进阶的数据型别， 像是
指标。然而自定数据型别的强大，我们要到第七章才能体会，在第七章里
面，我们会开始深入类别与面向对象程序设计。  
 
数组数据型别  
数组型别定义了以清单列出特定型别的表示法。这些列表当中可以存放固
定数量的元素 (静态数组 )，也可以存放变动的元素数量 (动态数组 )。我们通
常以方括号括住一个索引值来存取数组中的特定元素。方括号也用来代表
固定数量元素数组的数量。  
 
Object Pascal 语言支持不同的数组型别，从传统的静态数组到动态数组。我
们推荐使用动态数组，尤其是在使用行动版的编译程序时。我们先介绍静
态数组，然后稍 后再来看动态数组吧。  
 
  静态数组  (Static Arrays)  
传统的 Pascal语言数组都是静态的，也就是其元素的数量在宣告的时候就
确定了，底下的程序片段就是个范例，在这个范例中，定义了一个 24个整
数的清单，用来表示一天 24小时的温度：  
type  
   TDayTemperatures = array [1..24] of Integer;   
 
在这个传统的数组定义里，我们可以透过方括号来使用次范围型别，实际
用两个有序型别的常数值来定义一个新的次范围型别。这个次范围指出数 
 126 组中有效的索引值。既然我们 定义了该数组索引的最大值与最小值，那么
这个索引就不必非得从 0开始了， 就像在 C, C++, Java 以及其他大多数的语
言一样 (从0开始作为起始点的数组也已经在 Object Pascal 里面普及了 )。注
意，在 Object Pascal 里面，索引值可以是数字，或者其他有序型别的值，
像是字符、列举型别等等。非整数型的索引目前还是很少见。  
_________________________________________________________________________  
仍有许多程序语言，像 JavaS cript，特别倚重关系型数组 (associative arrays) 。
Object Pascal 的数组限制索引必须是有序型别， 所以我们不能用字符串当成
索引值。在 RTL里面有提供了 Dictionary 跟其他类似的数据结构可以用，
我会在本书的第三部分，介绍 Generic的篇幅里面介绍他们。  
 
既然数组索引值是以次范围为型别，编译程序就可以检查他们的范围了。使
用不合法的常数次范围值会导致编译错误， 而超过范围的索引值则会导致运
行时错误，不过，这也得要设定了对应的编译选项才会发生。  
________________ _________________________________________________________  
次范围检查的选项在设定页的 Compiling 页签里的 Runtime errors 群组里面。
我们可以从 IDE的Project Options 对话框找到 (在项目名称上面点选鼠标右
键，就会出现 Project Options 选项了 )。在第二章的『次范围型别』那一小
节我们已经提过啰。  
 
使用以上的数组定义，我们可以设定一个名为 DayTemp1 的变量，型别就用
TDayTemperatures( 我已经写好 在范例项目 ArrayTests 里面， 以下就是该项目
的程序代码节录 ): 
 
type  
   TDayTemperatures = array [1..24] of Integer;   
var 
   DayTemp1: TDayTemperatures;  
begin  
       DayTemp1 [1] := 54;  
       DayTemp1 [2] := 52;  
       ... 
       DayTemp1 [24] := 66;  
       // The following line ca uses:  
       // E1012 Constant expression violates subrange bounds   
      // DayTemp1 [25] := 67;   
 
这么一来，我们当然可以用标准的方法来处理数组了，也就是 for循环。这筆記  
筆記   
 127 个范例是使用循环来显示一天当中的所有温度数字：  
var 
   I: Integer;  
begin  
   for I := 1 to 24 do  
      Show (I.ToString + ': ' + DayTemp1[I].ToStr ing);   
 
当然，这段程序代码执行不会有问题，但因为它的数组范围是写死的 (从1
到24)，这种写法还不尽理想。因为数组的定义会随时间改变，所以我们可
能会想要使用动态数组。  
 
  数组的大小跟边界  
当我们在处理数组的时候，记得！永远都要用标准函式 Low跟High检查它
的边界，这两个函式会回传上下两个边界值。 (译者也这么认为，因为这几
年越来越常碰到初学者，甚至已经写了几年的程序人员，完全不管数组边界
值，直接就抓数据，然后就发生数组超出边界的错误，在手机就会闪退，在
桌面应用程序就会发生不断出现错误 ) 请永远在存 取数组内容之前，先检查
该索引值是不是在数组的合法范围之内！尤其是在循环里面处理数组数据
时，更需要逐一检查，因为循环可能从 0到数组数量 -1，或者从 1到数组数
量，或者任何次范围的定义，在执行过程中，什么时候会出问题很难预料，
所以务必一一检查。  
 
即使我们在程序写好之后，还需要更改数组索引的范围， Low跟High这两
个函式仍旧是有效的，但如果我们把范围写死，我们就得在数组范围有异动
的时候，每次都要改数组的程序了。 Low跟High这两个函式会让我们不用
花太多时间在维护数组的程序代码，并使程序代码可靠性更高。  
_________________________________________________________________________  
顺便一提，对静态数组使用 Low跟High函式，在运行时间完全没有多花
时间。因为它们是在编译阶段就已经完成了解析，所以不用任何额外的函
式来处理。类似的编译阶段解决的作法，在其他系统函式里面也常出现喔。  
 
另一个相关的函式是 Length，这个函式会回传数组的元素数量，我把上述三
个函式整合在下面的范例程序代码里面，用来显示当天的平均温度：  
var 
   I: Intege r; 
   Total: Integer;  
begin  筆記   
 128     Total := 0;   
   for I := Low(DayTemp1) to High(DayTemp1) do   
      Inc (Total, DayTemp1[I]);   
   Show ((Total / Length(DayTemp1)).ToString);   
 
上面的程序代码也是 ArraysTest 范例项目的一部分。  
 
  多维度静态数组  
数组可以包含超过一个以上的维度，以矩阵或者方块的形式来呈现，不一定
是一维的线性列 表。以下是两个简单的定义：  
type  
   TAllMonthTemps = array [1..24, 1..31] of Integer;   
   TAllY earTemps = array [1..24, 1..31, 1..12] of Integer;   
 
我们可以这样来存取里面的元素：  
var 
   AllMonth1: TAllMonthTemps;  
   AllYear1: TAllY earTemps;  
begin  
   AllMonth1 [13, 30] := 55; // hour , day   
   AllYear1 [13, 30, 8] := 55; // hour, day, month   
_________________________________________________________________________  
静态数组会立即使用许多内存空间 (例如使用掉堆栈里的内存 )， 这些浪费是
可以被避免的。 AllYear1 变量需要使用 8,928个整数，以每个整数 4 bytes
来计算，就将近 35KB了。不管在全局内存空间或者堆栈里面 (如上例的程
序，就会耗用堆栈的内存 )，预先配置这么大的空间都是不对的。相反地，
动态数组使用的是 heap的记忆空间，而且在内存的配置跟管理上弹性也都
更大。  
 
假设这两个数组型别是以相同的核心型别建置， 我们最好使用前例的资料型
别，可以写成：  
type  
   TMonthTemps = array [1..31] of TDayTemperatures;   
   TY earTemps = array [1..12] of TMonthTemps;   
 
这样的宣告颠倒了前例的顺序，但也允许两个变量之间整个区块的指派动
作。我们看一下可以怎么指派独立的 数值：  筆記   
 129  
Month1 [30][14] := 44;   
Month1 [30, 13] := 55; // day, hour   
Y ear1 [8, 30, 13] := 55; // month, day, hour   
 
理论上，我们应该用第一行的作法，选择数组中的某一数组 (姑且称为数组
A)，然后再处理数组 A里面的特定元素。然而，直接透过方括号里头指定
两个索引值来存取二维数组的作法也是被允许的。当然，直接指定三个索引
值来处理三维数组也是可以的。  
 
使用中介型别的重要性，只基于数组中元素相同时，元素型别可 以兼容的特
性而来 (这当中的型别是完全相同的 )。而当元素型别不同的时候，这个特性
就不存在了。这个型别兼容的规则，对于 Object Pascal 的所有型别都成立，
只有少数情况例外。  
 
举例来说，以下的程序代码会复制一个月的温度到该年的第三个月份：  
Y ear1[3] := Month1;  
 
反之，一个类似的指令如果是套用到独立的数组时 (这数组跟温度的数组型
别并不相同 ): 
AllY ear1[3] := AllMonth1;  
 
就会引发错误：  
Error: Incompatible types: 'array[1.. 31] of array[1..12] of Integer' and 'TAllMonthTemps'   
 
像我提过的，静态数组在内存管理的问题上做出了牺牲，特别是当我们想要
把它作为参数进行传递，或者只配置一个大数组的一部分时。再者，我们无
法在执行过程中，对仍处在合法生命周期的数组变量进行重新配置。这也是
为什么使用动态数组占有比较多优势的原因， 即使动态数组需要使用一些额
外的管理机制，例如对内存的管理。  
 
  动态数组  
在传统的 Pascal语言里，数组是固定大小的，当我们宣告了数组的元素数量
以后，这个数组可 以储存的元素数量就被固定了。 Object Pascal 也提供了一
个原生、直接的动态数组功能。  
_________________________________________________________________________  
『直接的动态数组功能』指的是相对于使用指针与易失存储器配置等技术
筆記   
 130 来得到类似的效果，那样做程序会很复杂，而且容易出错。  
动态数组是动态配置，并且对参考进行计数 (这个作法会使得传递参数的时
候快上许多，且只有参考会被传递，而不是把完整的数组复制一份传过去 )。
当我们完成处理时 ，我们可以透过把数组变量指向 nil或者把数组的长度设
定为 0这两种作法来把数组内容清除掉。但如果它们的参考是有进行计数
的，编译程序就会帮我们把内存自动清除掉了。  
 
透过动态数组，我们宣告数组型别时，就不用指定元素数量了，等到我们需
要使用的时候，再透过 SetLength 程序设定数组的长度即可：  
var 
   Array1: array of Integer;  
begin  
   // this would cause a runtime Range Check error   
   // Array1 [1] : = 100;  
   SetLength (Array1, 10);   
   Array1 [1] := 100; // this is OK   
 
在还没有设定数组的长度之前，我们不能直接使用数组，透过 SetLength 程
序，我们会在 heap的内存里面配置数组需要的空间。如果我们没有这么做，
要不会出现范围检查错误 (如果对应的编译程序设定没有设定为启动的话 )，
或者就会出现存取违规 (在Windows 上面 )或者类似的内存存取错误 (在其他
作业平台上 )。在上述程序代码里面， SetLength 函式会设定所有值先设为 0。
初始程序代码会让这个数组立刻可以开始被读写，不用担心任何内存错误
(当然，如果我们硬是存取数组范围之外的值，还是会错的 )。 
 
如果我们想要自己配置内存，我们也不用直接释放它，在上面的程序代码里
面，当 Array1变量的生命周期结束，而程序也结束时，编译程序就会自己
释放掉当中使用的内存了 (以上面的程序代码为例，原本配置的 10个整数的
内存空间会被释放掉 )。所以我们可以直接把 nil指派给动态数组变量，或者
呼叫 SetLength(0) ，这通常都是不需要的 (编译程序会自己处理 )。 
 
请注意， SetLength 程序可以用来 调整数组大小，如果我们把数组的长度加
大，原有的元素并不会受到影响，而如果我们把数组的长度缩短，则被裁减
到的元素也会被释放，但没有被裁减的元素则不会受影响。  
 
在最初呼叫 SetLength 程序的时候，我们只指定了数组元素的数量，数组的
起始索引仍旧是 0，最后一个索引则是指定的数量减一。换句话说，动态数
组并不支持传统 Pascal静态数组的两个功能： 指定从非 0的元素作为初始索 
 131 引，以及以非整数作为索引值。同时， Object Pascal 动态数组的动作与行为
也更像 C语言或其他从 C衍生而来的程序语言了。  
 
跟静态数组相同 的是，我们可以透过 Length来得知动态数组的长度，也可
以使用 High跟Low函式。 只是在动态数组使用 Low函式， 永远都会得到 0，
使用 High函式，则永远都会得到数组长度减一。也就是说，对一个长度为
0的动态数组执行 High函式，会得到 -1(想一想，这是个奇怪的数值，对吧，
因为 High比Low传回的值还小！ ！ ) 
 
所以，当做个例子吧，在 DynArray 范例项目里面，我透过可变循环来把信
息放进，也从动态数组取出，这是型别跟变量定义：  
type  
   TIntegersArray = array of Inte ger;  
var 
   IntArray1: TIntegersArray;  
 
数组被以索引值的数据进行配置与存放，使用以下的循环：  
var 
   I: Integer;  
begin  
     SetLength (IntArray1, 20);  
     for I := Low (IntArray1) to High (IntArray1) do   
        IntArray1 [I] := I;  
end;  
 
第二个按钮的程序则包办了显示每个数值与计算平均值的功能， 类似前一个
范例，不同的是只使 用单一循环：  
var 
   I: Integer;  
   total: Integer;  
begin  
   Total := 0;   
   for I := Low(IntArray1) to High(IntArray1) do begin   
     Inc (Total, IntArray1[I]);  
     Show (I.ToString + ': ' + IntArray1[I].ToString);   
   end;   
 
   Show ('Average: ' + (Total / Le ngth(IntArray1)).ToString);    
 132 end;   
这段程序的输出则相当的浅显易懂 (我省去了大部分 ): 
 0: 0 
 1: 1 
 2: 2 
 3: 3 
 ... 
 17: 17  
 18: 18  
 19: 19  
 Average: 9.5  
 
除了 Length, SetLength, Low, High 之外，我们还有一些常用的程序会跟数组
搭配使用的，例如 Copy函式，我们可以用它来复制数组的部份元素 (也可以
复制全部 )。注意到，我们也可以把数组变量指派给另一个变量，但这么做
并不是把所有元素都复制 了一份过去喔，这么做只会把数组的指针复制过
去，两个数组变量所使用的内存空间会是同一份，所以当我们修改其中一个
数组的元素时，另一个也会一起变动。  
 
唯一略为复杂的程序代码是 DynArray 程序的最后部分，用两种方法来把一
个数组复制到另一个去：  
 使用 Copy函式，可以把数组的数据复制到使用不同的内存空间的一个
新的数组去。  
 使用指派运算符 (:=)，这作法只会做出另一个变量的替身，储存的还是
同一份内存空间。  
 
在这时候，如果我们修改了其中一个数组的元素时，原来那数组的元素会不
会跟着一起发生异动，就要看你用哪一种方法 来做这个复制的动作了，以下
是完整的程序代码：  
 
var 
   IntArray2: TIntegersArray;  
   IntArray3: TIntegersArray;  
  begin  
   // alias  
   IntArray2 := IntArray1;  
   // separate copy   
   IntArray3 := Copy (IntArray1, Low(IntArray1), Length(IntArray1));       
 133  
  // modify items  
   IntA rray2 [1] := 100;  
   IntArray3 [2] := 100;  
 // check values for each array  
    Show (Format ('[%d] %d -- %d -- %d',  [1, IntArray1 [1], IntArray2 [1], IntArray3 [1]]));   
   Show (Format ('[%d] %d -- %d -- %d',  [2, IntArray1 [2], IntArray2 [2], IntArray3 [ 2]]));   
  
执行结果，我们会看到如下的输出：  
[1] 100 -- 100 -- 1  
[2] 2 -- 2 -- 100   
 
对IntArray2 的变动也同步影响了 IntArray1 ，因为用  := 指派运算符，只是
把IntArray1 的地址存一份到 IntArray2 而已，内存空间是完全相同的一份，
但在 IntArray3 则已经是独立的一份，所以对 IntArray3 的变动不会影响到
IntArray1 。 
 
  对动态数组提供一些新的原生处理  
对动态数组最近有提供一些新的功能，甚至可以说是这个语言的独 特创举，
就是支持把常数数组指派给动态数组，以及提供动态数组的连接。  
_________________________________________________________________________  
这些对动态数组的功能延伸，是从 Delphi XE7 开始就提供的，所以从 2014
九月开始发布的 Delphi XE7 跟Appmethod 都具备以上功能。  
 
在实务上，我们可以写出像以下的程序代码，这比以往的程序代码都要来的
更为精简：  
 
var 
   di: array of Integer;  
   i: Integer;  
begin  
   di := [1, 2, 3]; // initialization   
   di := di + di; // concatenation   
   di := di + [4, 5]; // mixed concatenation   
   for i in di do  
   begin  
       Show (i.ToString);  筆記   
 134    end;  
请注意，在上面的程序代码里面的 for-in循环会扫描整个数组里面的元素，
这程序代码是范例项目 DynArray Concat的一部分。另外，这些数组的元素
型别可以是任何一种，上例是 Integer，我们也可以改为 record或类别。  
 
还有第二个功能增强，就是可以在指派时直接进行连接，但这是 RTL的部
份，不是程序语言上有所改变。要把动态数组弄的像字符串那么容易操作是
不太可能的，但我们可以用 Insert跟Delete来处理元素的连接跟删除。  
 
这表示我们可以写出以下这样的程序代码了 (也是同一个项目的程序代码 ): 
var 
   di: array of Integer;  
   i: Integer;  
begin  
   di := [1, 2, 3, 4, 5, 6];   
   Insert ([8, 9], di, 4);   
   Delete (di, 2, 1); // remove the third (0 -based)   
 
  开放数组参数  
在数组的使用上有些情境非常特别， 例如把一个不确定长度的清单作为参数
传给函式。除了直接传一个数组作为参数，我们还会在这一节跟下一节介绍
两个特殊的语法结构。  
 
顺道一提，具备这特性的函式之一，就是 Format函式，我们在前面几个范
例程序代码里面有使用到，它的第二个参数，就是以方括号 建立起来的一个
数组。  
 
跟C语言不同 (当然跟其他从 C衍生的语言也不同 )， 在传统的 Pascal语言里，
函式跟程序的参数永远都是固定个数的。然而在 Object Pascal 里面，就有方
法把不特定个数的参数透过数组参数来传递，从技术上来说，这就称为 开放
数组参数 。 
_________________________________________________________________________  
从历史纵轴来看，开放数组参数的出现早于动态数组，但今日看来，这两
个技术从实际作用的方法来看非常相似，几乎 越来越无法区别了。这也是
为什么我把开放数组参数放在动态数组之后进行讨论的原因。  
 
开放数组参数的基本定义跟已定义的动态数组型别是一样的，前面加上筆記   
 135 const叙述字。这表示我们可以定义参数的型别，但我们不用定义这个数组
中一定要放几个元素不可。以下是这种定义的范例之一，也是从 OpenArray
范例项目中撷取而来：  
function Sum (const A: array of Integer): Integer;   
var  
   I: Integer;  
begin  
    Result := 0;  
    for I := Low(A) to High(A) do  
       Result := Result + A[I]; end;   
 
我们可以呼叫这个函式，传给它一个整数数组作为参数 (当中当然可以参杂
变量与常数，这个函式就会把其中每个数值拿来使用 ): 
X := Sum ([10, Y , 27*I]);   
 
假设有个整数动态数组， 我们可以把它直接传给一个要求开放数组参数的函
式(假设这里就是要求整数数组 )，以下就是这样一个范例，整个数组会被传
进去作为参数：  
var 
   List: array of Integ er; 
   X, I: Integer;  
begin  
   // initialize the array   
   SetLength (List, 10);   
   for I := Low (List) to High (List) do   
      List [I] := I * 2;  
   // call  
   X := Sum (List);  
 
这是如果我们是用动态数组，假如我们是用相同元素型别的静态数组，就可
以也把它传给要求开放数组参数的函式，或者我们也可以呼叫 Slice函式，
把数组的一部 分传去当参数 (当成其中的第二个参数 )。 以下的程序片段 (也是
OpenArray 范例的一部分 )示范了如何把一个静态数组的一部分传给 Sum函
式作为参数 : 
var  
   List: array [1..10] of Integer;   
   X, I: Integer;   
begin   
 136    // initialize the array   
   for I := Low (List) to High (List) do   
     List [I] := I * 2;  
 
   // call  
   X := S um (List);  
   Show (X.ToString);  
 
   // pass portion of the array   
   X := Sum (Slice (List, 5));   
   Show (X.ToString);   
 
  变异型别的开放数组参数  
除了这些指定型别的开放数组参数， Object Pascal 也允许我们定义变异型别
(type -variant)或者不指定型别 (untyped) 的开放数组作为参数。这个特殊的数
组会拥有不定数量的元素，而这些元素的数据型别也可能各自不同。这也正
是Object Pascal 的限制进入区域之一， 因为这里已经不是完全型别安全的区
域了。  
 
技术上来说，我们可以定义一个参数，它的型别是 array of const ，用以把一
个不确定数量与元素型别的数组作为参数来传给函式。举例来说，以下是
Format函式的定义 (我们在第六章里面会讨论这个函式，在讨论字符串的时
候，不过我已经在几个范例里面提过它了 ): 
function Format (const Format: string;   
    const Args: array of const): string;   
  
第二个参数是一个开放数组，他会接受不确定数量的值，事实上，我们可以
用以下方式呼叫这个函式：  
N := 20;  
S := 'Total:';   
Show (Format ('Total: %d', [N]));   
Show (Format ('Int: %d, Float: %f', [N, 12.4]));   
Show (Format ('%s %d', [S, N * 2]));   
 
请注意，我们可以把一个常数、变量内容，甚至是表达式当做参数传递。宣
告这样的函式很容易，但我们要怎么实作它？我们怎么 知道这些参数的型
别？变异型别的开放数组参数是和 TVarRec 这个型别的元素完全兼容的。   
 137  
_________________________________________________________________________  
别把 TVarRec 记录和 Variant(变异型别 )使用的 TvarData 记录搞混了。这两
个结构的作用不同，也完全不兼容。即使连列出的可能型别也不一样，因
为TVarRec 所处理的型别都是 Object Pascal 的数据型别，而 TVarData 处理
的型别都是 Windows 的OLE数据型别。关于 Variant(变异型别 )，我们会在
本章后面的篇幅来加以介绍。  
 
以下我们列出在变异型别开放数组当中可以支持的资料型别，当然 TVarRec
记录也就能支持：  
vtInteger       vtExtended      vtPChar  
vtWideChar    vtCurrency      vtWideString  
vtBoolean      vtString         vtObject  
vtPWideChar   vtV ariant        vtInt64  
vtChar          vtPointer        vtClass  
vtAnsiString    vtInterface      vtUnicodeString  
 
这个记录的结构包含型别 (VType)，以及一个变异型别字段，我们可以透过
这个字段来存取实际的资料 (比一些页面的纪录更多，即使这是这些结构的
进阶功能 ) 
 
一般的作法是当我们的函式接收到这种型别的参数时，就透过  case叙述句
来对不同型别的数据进行处理。在范例程序代码函式 SumAll里面，我想把
不同型别的数据做加总，把字符串转换成整数，字符转成对 应的有序数值，
把布尔值的 True转成 1。这个程序代码可以说相当的高端 (里面还用到了指
标引用： pointers dereference) ，所以不用担心你现在会看不懂：  
function SumAll (const Args: array of const): Extended;   
var  
   I: Integer;  
begin  
   Result := 0;   
   for I := Low(Args) to High (Args) do   
     case Args [I].VType of   
       vtInteger:   
         Result := Result + Args [I].VInteger;  
       vtBoolean:  
         if Args [I].VBoolean then  
           Result := Result + 1;  筆記   
 138        vtExtended:   
         Result := Result + Args [I].VExtended^;   
       vtWideChar:  
         Result :=  Result + Ord (Args [I].VWideChar);  
       vtCurrency:   
         Result := Result + Args [I].VCurrency^;   
     end; // case  
 end;  
 
我已经把上面这个函式加入 OpenArray 范例程序里， 可以用以下的程序代码
来呼叫它：  
var 
   X: Extended;  
   Y: Integer;  
begin  
          Y := 10;  
          X := SumAll ([Y * Y , 'k', True, 10.34]);  
          Show ('SumAll: ' + X.ToString);  
end;   
 
这个函式的输出加入了 Y平方值，以及 K的有序值 (107)，以 1表示布尔值
的True，以及浮点数，结果如下：  
SumAll: 218.34   
 
记录数据型别  
数组以数字索引定义了一连串的元素，而记录则以名称定义对应的成群元
素。换句话说，记录是一连串被赋予名称与对应字段的元素，每一组都元素
都有其特定的资料型别。记录数据型别的定义会把这些字段全部列出，包含
每个字段的名称，以及对应数据应有的型别。  
_________________________________________________________________________  
在大多数的程序语言里面都有记录这个型别，在 C语言里面，被以 struct
这个关键词建构，在 C++里面则是用方法的延伸定义来处理，跟 Object 
Pascal的作法很像。有些『纯』面向对象式的程序语言则只能在类别里面进
行加注，就没有提供 record或struct这样的功能了。  
 
以下是段简单的程序代码 (这段程序代码是从 Recor dsDemo 范例项目节录
的)，里面定义了一个记录型别，并用这个型别定义了一个变量，以及一些筆記   
 139 使用这个变量的程序代码：  
type  
     TMyDate = record  
            Y ear: Integer;  
            Month: Byte;  
            Day: Byte;  
     end;   
var 
   BirthDay: TMyDate;  
begin  
    BirthDay.Y ear := 1997;   
    BirthDay.Month := 2;   
    BirthDay.Day := 14;   
    Show ('Born in year ' + BirthDay.Y ear.ToString);   
_________________________________________________________________________  
『记录』这个词在 Object Pascal 里面可能代表两种意思，一个是『记录』
型别的定义， 另一个则是使用记录型别的变量 (或者也可以叫 『记录』 变量 )。
所以『记录』这个词有两种意思，一定要认清我们用这个名 词的时候所指
的是什么。  
 
在Object Pascal 里面，记录用来代表数据结构的时候，多于代表简单的字段
列表，在本章的剩余部分会试着说明，但我们先从记录的传统用法开始。记
录所使用的内存通常会被配置在局部变量的堆栈， 或者全局变量所使用的全
局内存空间。我们用 SizeOf这个函式来强调这个现象， SizeOf会回传一个
变量所使用的内存空间大小 (单位为 byte)，可以写成以下指令这样 : 
Show ('Record size is ' + SizeOf (BirthDay).ToString);   
 
上面这个指令会回 传 8 (它回传 8, 而不是 6或4 bytes，是因为使用了一个
整数，以及另外两个 byte字段 -我们等下会在 ”字段对齐 ”的小节加以说明 )。 
 
换句话说：记录是值类型，这表示如果我们把记录指派给另一个记录变量，
我们就会做一份完整的数据复制。如果我们对新的变量内容做修改，原来的
记录变量内容是不会变动的。以下的程序片段用程序代码来说明这个概念：  
var 
   BirthDay: TMyDate;  
   ADay: TMyDate;  
 begin  
   BirthDay.Y ear := 1997;  筆記   
 140    Birth Day.Month := 2;  
   BirthDay.Day := 14;  
   ADay := Birthday;  
   ADay.Y ear := 2008;  
   Show (MyDateToString (BirthDay));  
   Show (MyDateToString (ADay));  
 
输出结果 (用国际日期格式 ): 
 1997.2.14  
 2008.2.14  
 
对同样一份数据做异动的情况， 会发生在当我们把记录当成函式的参数传入
时，就像上面的程序代码里面我们呼叫的 MyDateToString 函式：  
function MyDateToString (MyDate: TMyDate): string;   
begin   
   Result := MyDate.Year.ToString + '.' +   
       MyDate.Month.ToString + '.' +   
       MyDate.Day.ToString;   
end;   
 
呼叫这个函式的时候，都会完整复制一整份记录型别的数据。为了避免这个
复制的情形发生，我们可以透过宣告该函式的参数是引用参数的作法，来达
成对原始记录数据的变 更。在下面这个范例程序代码里面，就特别以引用参
数的作法，让函式里面对记录变量的修改能够回传到原始的记录变量里：  
procedure IncreaseY ear (var MyDate: TMyDate); begin   
   Inc (MyDate.Y ear);  
end;   
 
var 
   ADay: TMyDate;  
begin  
   ADay.Y ear := 2016;  
   ADay.Month := 3;  
   ADay.Day := 18;  
   Increaseyear (ADay);  
   Show (MyDateToString (ADay));  
 
假使原始记录变量的 Year字段会因为呼叫这个程序而被增加，则呼叫完函 
 141 式之后，原始变量的 Year字段就会比呼叫前多一年：  
2017.3.18   
 
  使用记录数组  
就像之前提到过的，数组可以把同一个型别的数据重复建置出来，而记录是
在单一结构里面包含不同的元素。假使这两个型别建构子的用途是不同的，
那么把它们两个混着用就是很正常的想法，也就是定义一个数组，让该数组
的元素型别是记录型别 (另一种混用法就很少见 : 在记录中使用数组 )。 
 
这个数组的程序代码还是跟 其他任何的数组一样， 每个数组的元素使用一个
记录型别的空间。我稍晚会介绍如何使用更复杂的结构，像是 Collection 或
者Continer类别 (用来储存多个元素 )，在记录数组的使用上，我们可以学到
更多数据管理的名词。  
 
在RecordTest 项目里面，我加进了一个 TMyDate 型别的数组，我们可以用
以下的程序代码对这个数组进行配置、初始化并使用它：  
var DatesList: array of TMyDate; I: Integer;   
begin  
   // allocate array element s  
   SetLength (DatesList, 5);   
   // assign random values   
   for I := Low(DatesList) to High(DatesList) do begin   
      DatesList[I].Y ear := 2000 + Random (50);   
      DatesList[I].Month := 1 + Random (12);   
      DatesList[I].Day := 1 + Random (27);   
   end;   
   // display the values   
   for I := Low(DatesList) to High(DatesList) do   
      Show (I.ToString + ': ' +   
         MyDateToString (DatesList[I]));  
 
假设 app使用随机数据，则输出值就会每次都不一样，就像我以下撷取的结
果: 
0: 2014.11.8   
1: 2005.9.14   
2: 2037.9.21   
3: 2029.3.12    
 142 4: 2012.7.2   
  变异记录  (Variant Records)  
在Object Pascal 早期的版本中，记录型别也可以有变动的部份，也就是说，
多个字段可能对应到相同的一个内存空间，即使这些字段的型别不同。 (这
个概念可以对应到 C语言里面的 union)。另一个作法，我们可以使用这些变
异字段或者群组来存取记录里面的同一个内存空间， 但这些数据还必须考虑
到不同的型别的观点。这种型别的主要用途，使用来储存大同小异的数据，
或者用型别转换的方式来对同一块内存数据进行不同解译 (透过强制转型，
这在 Object Pasca l早期版本是可以的， 今日的版本已经不允许直接做强制转
型了 )。变异记录的应用已经大幅被面向对象或其他更新的技术所取代了，
目前只剩很少的系统函式库在很特别的情境下会内部使用到这个技术了。  
 
变异记录型别的使用并不保证型别使用上的安全， 在程序实务上也不建议使
用。除非您已经是 Object Pascal 的专家，不然您不用特别去抓出这些情况。
总之，这也是我决定不以实例说明这个观念的原因，当然也就不会特别介绍
其用法了。如果您真的需要这方面的相关概念，请看一下我在 121页中『变
异型别的开放数组参数』那一节的范例程序中，对 TVarRec的使用吧。  
 
  字段对齐  (Fields Alignments)  
另一个跟记录相关的进阶议题，是这些记录用来进行对齐的方法，这个方法
也让我们对于了解记录的实际大小更有帮助。如果我们深入观察函式库，我
们会常常看到 packed这个关键词在记录型别上出现：这表示记录必须尽可
能使用最小的空间，即使这样的作法可能导致数据存取的动作变慢。  
 
这个差异是从变异字段的对齐有 16bit或32bit两种选项的时候开始出现的，
所以在变异字段的内容储存的是整数时，即使这个整数只使用了 8bit，这字
段的下一个内存开始的 地址，也会是在该整数起始位置后的 32bit处。这样
的内存对齐机制，会使得程序代码的执行更为快速。  
 
一般的字段对齐技术，都是被用在类似记录型别的数据结构，部分 CPU架
构在使用了这样的技术后，就能加速对独立字段的数据存取。我们可以透过
＄ALIGN这个编译程序开关来改变字段对齐的设定。  
 
使用 {$ALIGN 1} 这个设定，编译程序会尽量节省内存的使用，就像我们在
记录型别上使用 packed这个描述字的效果， 另一种极端， 则是使用 {$ALIGN 
16}，这个设定会使用最大量的内存进行对齐机制，此外还有 4跟8两种对 
 143 齐的参数可以设定。  
 
如果我们回头拿 RecordsTest 项目当成个例子，在里面的记录定义加上
packed关键词：  
type  
     TMyDate = packed record  
           Y ear: Integer;  
           Month: Byte;  
           Day: Byte;  
     end;   
 
SizeOf这个函式的回传值现在就会回传 6, 而不是回传 8了. 
 
用以下的例子作为进阶的范例，如果您对 Object Pascal 还不是很熟悉，可以
先跳过这个例子。我 们先看一下以下的结构 (可以在 AlignTest 这个范例项目
里面看到 ): 
type  
         TMyRecord = record  
           c: Byte;  
           w: Word;  
           b: Boolean;  
           I: Integer;  
           d: Double;  
end;   
 
当设定了 {$ALIGN 1} ，上面的结构会使用 16 bytes(这是 SizeOf的回传值 )，
而在相对的内存地址里面，内容会像以下这样：  
 
c: 0 w: 1 b: 3 i: 4 d: 8   
_________________________________________________________________________  
相对地址是以记录布局和以数值、字段配置之间的差异计算出来的。例如
这样的算式： Integer(@MyRec.w) – Integer(@MyRec1) 。指针跟地址符号 (@)
我们会在本章后面的部分介绍。  
 
比较一下，如果我们把对齐的尺寸改为 4 (这会使数据存取的速度变快 )，这
个size就变成了 20 bytes，相对地址 就变成了 : 
c: 0 w: 2 b: 4 i: 8 d: 12   
 筆記   
 144 如果我们用了很极端的选项 {$ALIGN 16} ，这个结构就需要 24 byte，对应的
字段如下 : 
c: 0 w: 2 b: 4 i: 8 d: 16   
 
  With叙述句是什么 ? 
另一个我到目前还不想提的旧版 Pascal的语言叙述句， 因为它只会被用来跟
记录或类别一起使用，就是 With。这个关键词是比较奇特的 Pascal叙述句，
但它后来也在 JavaScript 跟Visual Basic 里面出现了。这个关键词的使用，
能让程序人员少打一些字，但也 很危险，因为许多原本该写清楚的类别、记
录的名称被省却了之后，整段程序代码就变得不容易读了。我们可以发现，
一直以来关于 With这个叙述句的争论不断，因此我也建议我们使用这个叙
述句的时候，要持保守的态度。不管怎么说，我觉得一定要把这个叙述句在
本书当中加以介绍（这跟稍早提到的 goto叙述句是不同的）  
_________________________________________________________________________  
对于是否要把 goto叙述句从 Object Pascal 移除也一直有 许多争论，对 with
叙述句是否要从行动版的编译程序中移除也一样。虽然有些使用情境是合
法的，但有些范围的问题会随着 with叙述句的使用而发生，这就是不再继
续支持这个功能的好理由了（或者像 C#一样用一个别名来提供该功能）  
 
with叙述句的功能就是让程序代码能够简写。 当我们需要使用一个记录型别
变量 (或者需要使用对象 )时，为了不用每次要用到该变量时就输入该变量的
名字，我们就可以用 with叙述句来省却输入这个变量的名字，举例来说，
当需要使用到记录型别时，我把以下这段程序代码：  
var 
   BirthDay: TM yDate;  
begin  
         BirthDay.Y ear := 2008;  
         BirthDay.Month := 2;  
         BirthDay.Day := 14;  
 
加上了 with叙述句之后，可以把这段程序改写成：  
with BirthDay do  
begin  
     Y ear := 2008;  
     Month := 2;  
     Day := 14;  
end;   筆記   
 145 这个作法可以在 Object Pascal 的程序代码当中套用在使用组件或其他类别
的使用上。当 我们的程序代码需要使用到对象或类别的时候， with叙述句就
允许我们可以简化程序代码，尤其是在巢状数据结构的使用上。  
 
所以，我之所以不鼓励使用 with叙述句的原因，就是它可能让微小的错误
难以被找出来。这些难以发现的错误在本书的这个点当中很难说明。我们先
来思考一个比较没有伤害性的情境，这已经会让我们白头搔更短，浑欲不胜
簪。以下是一个记录以及使用这个记录的一些程序代码：  
type  
   TMyRecord = record  
     MyName: string;  
     MyV alue: Integer;  
   end;  
procedure TForm1.Button2Click(Sender: TObject);   
var  
   Record1: TMyRecord;  
begin  
   with Record1 do  
   begin  
     MyName := 'Joe';  
     MyV alue := 22;  
   end;  
   with Record1 do  
     Show (Name + ': ' + MyV alue.ToString);  
 
是吧 ?这个应用程序可以编译、执行，但它的执行结 果却跟我们第一眼看完
以后期盼的结果不一样：  
Form1: 22   
 
这个输出结果的字符串部分并不是前面的程序设定的记录值， 原因是第二个
with叙述句误用了 Name字段，这不是记录里面定义的字段，而是另一个不
在此程序范围中的变量 (特别是使用到了 Button2Click 这个方法所在的 form
组件的 name字段了 ) 
 
如果我们这么写 : 
Show (Record1.Name + ': ' + Record1.MyV alue.ToString);   
编译程序就会显示错误讯息，表示这个记录里面并没有定义一个名为 Name
的字段。   
 146 通常我们可以说从 with叙述句出现的时候，就在当时的范围内定义了一个
新的识别符号，我们可以隐藏既有的识别符号，在同一段程序代码的范围内
使用到其他的识别符号。这也是一个用来警惕大家不要使用 with叙述句的
好理由，尤其我们更该避免使用多个 with叙述句，例如 : 
with MyRecord1, MyDate1 do...   
 
在上面这个 with叙述句里面的程序代码会变得很难懂，因为每个在该程序
片段当中的字段，我们都得想想到底是从哪个记录参考来的。  
 
带有方法的纪录  
在Object Pascal 里面的纪录 ，比以前的 Pascal语言的纪录或者 C语言里面
的struct都要更为强大。事实上，记录里面可以包含有程序或函式 (我们称之
为方法 )。这些方法甚至可以重新定义语言本身的运算方法 (这个功能称之为
运算符多载 : operator overloading) ，我们会在下个章节介绍。  
 
一个带有方法的纪录，基本上已经跟类别非常接近了，我们稍后就会发现这
一点。 而这两者之间最大的不同， 只在他们管理内存的方式不同而已。 Object 
Pascal的记录具备现代程序语言的两种基本功能：  
 
 方法：也就是和记录数据结构直接链接的程序或函 式，这些方法可以直
接使用记录的数据字段。换句话说，方法就是在宣告记录型别的时候同
时宣告的程序或函式 (也可以只是预先宣告 )。 
 
 封装：透过封装，我们可以限制某些数据字段或方法不被其他程序代码
直接使用。我们可以透过 private这个存取描述字来提供封装的功能，
好让其他程序代码无法看见位于 private区段的数据或方法。而 public
区段的字段跟方法则可以被所有程序代码所使用。 预设的存取描述字是
public。 
 
现在我们对记录的延伸功能有了核心观念的认识， 我们来看一个简单的记录
定义，这是从 RecordMethod s范例项目所节录的：  
type  
   TMyRecord = record  
   private  
             Name: string;  
            V alue: Integer;  
            SomeChar: Char;   
 147    public  
      procedure Print;   
      procedure SetV alue (NewString: string);   
      procedure Init (NewV alue: Integer);   
end;   
 
我们可以看到这个记录结构被分成两个部分 :private跟public。 我们可以宣告
多个部分， public跟private这些关键词在同一个记录宣告可以出现不只一
次。但如果使用多次，就要留意到在不同区段的变量跟方法究竟是属于
private还是属于 public，不然我们的程序代码以后会很难懂。  
 
其次，上述的程序片段中，里面的方法都只有宣告名称，并没有实作方法的
程序代码在里面，所以这些是属于预先宣告。  
 
我们要怎么撰写这些方法的程序代码，好让整个定义完整呢 ?方法几乎完全
一样，我们得写个全局的 函式或程序。唯一不同的是，我们得用记录的名字
来帮这些方法冠名， 这些方法是以记录型别的名称跟实际上的方法名称组合
而成的。实际写作的时候，我们可以直接指名要存取的域名，甚至是直接使
用该记录型别的其他方法，而不用再写一次该记录的名字：  
procedure TMyRecord.SetV alue (NewString: string);   
begin   
    Name := NewString;  
end;  
 
在这段程序代码里面， NewString 只是函式的参数，而 Name则是记录的字
段。  
_____________ ____________________________________________________________  
先写好方法的定义，然后再一一写好完整的定义，这方法挺无聊的。我们
可以直接在 IDE里面按 Ctrl+Shift+C 这组快捷键，就能自动依照宣告的内
容把实作所需要的程序样板全部自动产生出来了。 我们也可以按 Ctrl+Shift+
箭头键 (上/下)在方法宣告与完整程序代码之间快速切换。  
 
以下是这个记录型别的其他方法实作程序代码：  
procedure TMyRecord.Init(NewV alue : Integer);   
begin   
   V alue := NewV alue;  
   SomeChar := 'A';  
end;  筆記   
 148 function TMyRecord.ToString: string;   
begin   
   Result := Name + ' [' + SomeChar + ']: ' + V alue.ToString;   
end;   
 
以下是介绍如何使用这个记录型别的简单程序范例：   
var 
  MyRec: TMyRecord;  
begin  
   MyRec.Init(10);   
   MyRec.SetV alue ('hello');   
   Show (MyRec.ToString);   
 
您可能已经猜到，输出的结果是这样子的 : 
hello [A]: 10   
 
而如果我们想要直接使用这个记录里的字段，会发生什么事呢 ? 
MyRec.V alue := 20;  
 
这段程序不仅可以编译，也可以执行。这就跟我们在 private区段里面需告
了字段一样令人惊讶。因为一般应该只有记录方法可以存取这些字段。原因
是因为 Object Pascal 的private存取描述字，只对不同 unit有作用。  
 
所以如果这段程序是放在不同 unit里面，就会变成不合法的指令了。但在宣
告该记录型别的同一 unit里面，这是完全合法的。同样的规则，适用在记录
型别以及类别上面。  
 
  Self: 记录神奇的地方  
假设我们有两个记录，例如叫做 myrec1跟myrec2，这两个记录是相同的记
录型别，当我们呼叫一个方法，并执行它的程序代码。我们怎么知道这两个
记录的程序代码到底是哪一个会被执行？在幕后，当我们定义了一个方法，
编译程序会自动加一个隐藏参数进去，我们呼叫该方法时，就有一个记录的
参考存在了。  
换句话说，上述的程序代码里 面会被编译程序转换成类似以下这样：  
// 您写的：  MyRec.SetV alue ('hello');   
// 编译程序产生：  SetV alue (@MyRec, 'hello');   
  
 149 在上述的伪码里面，＠ (address of )这个符号是用来表示内存所在的地址，通
常用来取得一个记录型别的变量所配置的内存。  
_________________________________________________________________________  
重申一次， @( address of )这个符号我们 会在本章最后再介绍一次，章节标
题会是”那关于指标呢 ?” 
 
这是呼叫方法的程序代码被转译的方法， 但实际上的程序代码呼叫是怎么参
考到这个隐藏参数的 ? 实际上是使用了一个特别的关键词 ”self”.所以这个方
法应该要写成：  
procedure TMyRecord.SetV alue (NewString: string);   
begin   
   self.Name := NewString;   
end;   
 
在这段程序编译的过程中，使用 self这个关键词至为重要，除非我们需要把
记录整个进行参考。例如，把记录当做参数传 给另一个函式。这个情境在类
别的使用上就蛮常见的，在同样的情形下，类别也会使用完全相同的关键
词”self”来处理。  
 
使用了”self”这个关键词作为参数，会让程序代码更容易懂 (虽然多写 self并
不是必要的 )，其中一个情境，是我们需要用同一个记录型别复制完全相同
的数据时。在这个情境下，我们如果要对另一个实体进行数值测试：   
function TMyRecord.IsSameName (ARecord: TMyRecord): Boolean;   
begin   
   Result := (self.Name =  ARecord.Name);   
end;   
_________________________________________________________________________  
Object Pascal 隐藏的参数 self, 在C++跟Java里面叫做 this，在 objective -C
里面也一样用 self喔。  
 
 
记录与建构函式 (Constructors)  
当我们定义了一个记录型别跟变量 (或者称为记录的实体 )，并把它宣告为全
局变量时，记录里面的字段就已经被初始化了，但当我们在堆栈当中宣告的
时候 (可以想象这是个程序或函式内部的局部变量 )，就不会自动初始化。所
以当我们写了以下的程序代码 (也是 RecordMethods 范例项目的一部分 )： 
     var 筆記  
筆記   
 150        MyRec: TMyRecord;  
     begin  
       Show (MyRec.ToString);  
 
这段程序的输出值则会多少有些随机变化。当字符串初始值是个空字符串
时，字符字段跟整数字段会直接从被配置的内存空间中取值来用 (就跟一般
局部变量初始化的动作一样 )。通常这个值会随着每次执行的时候，从内存
取得的随机地址有 所不同，像是：  
[
]: 1637580   
 
这就是为什么在使用记录型别变量前，为记录执行初始化程序是很重要的
(跟其他变量进行初始化一样重要 )，避免读取非法的数据，因为那很容易导
致整个应用程序挂点。  
 
记录也支持一种特别的方法，称为建构函式，我们可以透过它来对记录进行
初始化。跟其他方法不同的是，建构函式可以建立一个新的变量实体 (但仍
旧可以对已存在的实体进行初始化 )。以下示范怎么帮记录新增一个建构函
式：  
type  
  TMyNewRecord = record  
  private  
   ... 
  publi c  
    constructor Create (NewString: string);   
    function ToString: string;  ...  
 
建构函式是包含程序代码的方法 : 
constructor TMyNewRecord.Create (NewString: string);   
begin   
   Name := NewString;  
   Init (0);  
end;  
 
这么一来，我们就可以用以下两种写法之一来对记录做初始化了：  
var 
  MyRec, MyRec2: TM yNewRecord;  
begin  
   MyRec := TMyNewRecord.Create ('Myself'); // class -like   
 151    MyRec2.Create ('Myself'); // direct call   
 
请注意，记录的建构函式必须有参数：如果我们试着呼叫 Create()，就会得
到错误讯息： ” Parameterless constructors not allowed on record types” ( 记录型
别的建构函式不能没有参数 )。 
____________ _____________________________________________________________  
根据文件的说明，不带参数的记录建构函式是为系统保留的 (系统有特定的
方式为记录的特定型别字段进行初始化，像是字符串跟接口 )。这也是为何
使用者要定义建构函式的时候，一定要至少给一个参数才行。当然，我们
也可以为建构者制作多载或者用不同的名称制作多个建构函式。我们在后
面的章节中讨论到类别的建构函式时会进行介绍。  
 
  运算符号的新纪元  (Operators Gain New Ground)  
Object Pascal 语言另一个跟记录相关的功能是对运算符号进行多载，这个功
能可以让我们对我们定义的数据型别所需的系统标准的运算符号进行多载
(例如加、减、乘等等运算 )。这个意思就是说，我们可以自己定义一个加法
(一个特别的 Add方法 )，然后透过 +符号来呼叫它。要定义这样的运算符号，
我们可以使用 class operator 这个关键词来实作。  
_________________________________________________________________________  
透过重复使用已经存 在的保留字，程序语言的设计者把这个功能对于旧有
的程序代码冲击降到了 0。 这个作法就是把常用的关键词做组合， 例如 strict 
private, class operator, class var 等等。  
 
class这个名词，在这里是和类别方法 (class method) 做连结，我们之后会在第
12章介绍这个概念。在这个关键词之后，我们可以宣告运算方法的名字，
例如 Add:  
type  
   TPointRecord = record  
   public  
     class operator Add (a, b: T PointRecord): TPointRecord;  
 
这里的 Add方法，在我们使用 TpointRecord 这个记录型别的变量时，就可
以用 +符号来呼叫了，例如：  
var 
   a, b, c: TPointRecord;  
begin ...   
   c := a + b;   筆記  
筆記   
 152  
c变量的结果就会是 a跟b这两个记录型别变量相加的结果。有哪些运算符
号是可以透过这个方式来重新定义的呢 ?基本上，整个 Object Pascal 程序语
言里面的运算符号都可以， 但我们不能定义 Object Pascal 没有定义过的运算
符号喔，以下的运算符号都可以重新定义：  
 
 型别转换运算符号 (Cast Operators): Implicit, Explicit  
 一致性运算符号 (Unary Operators): Positive, Negative, Inc, Dec, 
LogicalNot, BitwiseNot,  Trunc, 以及  Round   
 比较运算符号 (Comparison Operators): Equal, NotEqual, GreaterThan,  
GraterThanOrEqual, LessThan, 以及  LessThenOrEqual   
 二进制运算符号 (Binary Operators): Add, Subtract, Multiply, Divide, 
IntDivide, Modulus, ShiftLeft, ShiftRight, LogicalAnd, LogicalOr, 
LogicalXor, BitwiseAnd, BitwiseOr, 以及 BitwiseXor.   
 
在我们实际撰写的程序代码里面，不用特别呼叫这些方法，我们只需要在程
序代码中写入对应的运算符号即可， 只有在定义的时候才需要写 出这些特殊
方法的名字，记得要在这些特殊方法的宣告前面加上 class operator ，以免跟
其他方法的名称重复了。例如我们可以在一个记录型别里面重新制作 Add
运算符号，而这个记录型别里面也可以有个方法叫做 Add.  
 
当我们在定义这些运算符号的时候，我们得把所需的参数完整列出，运算符
号只会在参数完全符合的时候才被套用。 例如要提供两个不同型别的值相加
的功能，我们就得在这个新的运算符号宣告里面写清楚，第一个参数是哪一
种型别的值，第二个参数是哪种型别的值。实务上，运算符号的定义并不会
提供自动切换的功能喔。而且我们必 须很精准的定义型别，因为型别自动转
换的功能在这里不会启动。 很多时候这表示我们得提供一个运算符号很多种
不同的版本，并且要对该运算符号进行多载。  
 
另一个我们需要留意的重要元素， 是在用来定义数据转换的两个特殊运算符
号： Implicit跟Explicit。第一个是用来定义一个隐含的型别转换 (或者称为
宁静转换 )透过这种转换，数据不会有任何遗失 (因为只是把内存数据用另一
种型别的格式加以解释 )。第二个符号 (Explicit) 则会真的把一个变数转换成
另一种型别的变数。这两种运算符号都可以用来处理『转换前』 ，以及『转
换后』的数据型别。  
 
我们要留意到， Implict跟Explict都可以基于函式回传的型别进行多载，这
通常不可能发生在多载的方法上。实务上，在型别转换发生时，编译程序会 
 153 知道要回传的型别是什么， 因此就会自动先把该做的型别转换给做了。 例如，
在OperatorsOver 这个范例项目中，我定义了一个记录跟一些运算符号：  
type  
   TPointRecord = record  
   private  
       x, y: Integer;  
   public  
       procedure SetV alue (x1 , y1: Integer);   
      class operator Add (a, b: TPointRecord): TPointRecord;   
      class operator Explicit (a: TPointRecord): string;   
      class operator Implicit (x1: Integer): TPointRecord;   
end;   
 
以下则是这些运算符号方法的实作程序代码 : 
class operator TPointRecord.A dd( a, b: TPointRecord): TPointRecord;   
begin  
    Result.x := a.x + b.x;  
    Result.y := a.y + b.y;  
end;   
class operator TPointRecord.Explicit(a: TPointRecord): string;  
begin  
    Result := Format('(%d:%d)', [a.x, a.y]);   
end;   
class operator TPointRecord. Implicit(x1: Integer): TPointRecord;  
begin  
    Result.x := x1;  
    Result.y := 10;  
end;   
 
这样的纪录在使用上就很直觉了，我们可以写出这样的程序代码：  
procedure TForm1.Button1Click(Sender: TObject);   
var  
   a, b, c: TPointRecord;  
begin  
   a.SetV alue(10, 10);  
   b := 30;  
   c := a + b;  
   Show (string(c));   
 154 end;   
第二行的资料指派 (b := 30)就是透过 implict运算符号来达成的，由于在呼叫
Show这个方法的时候，少了一个型别转换，所以我们自己在程序代码上面
写清楚，用 explicit型别转换处理它。另外也要思考一下， Add运算符号不
会更动传进来的参数，它只会回传一个新的数值。  
_________________________________________________________________________  
为了配合运算符号只会回传新数值的这 个规则，要思考重载一个新的运算
符号，其实难度就更高了。如果一个运算符号建立了一个新的随机对象，
那谁要来释放这个对象 ?在行动版的编译程序里，我们有了新的 ARC技术
可以把这个问题处理好，但在一般操作系统呢 ? 
 
透过鲜为人知的方法， 其实是有方法可以透过撰写完整的内部方法名称来呼
叫运算方法的 (例如  &op_Addition) ，在方法前面加上 &符号，不要直接写出
该运算方法对应的符号。举例来说，我们可以把这个记录的加总方法改写如
下(请参照范例项目程序代码，就可以看到完整的列表 ): 
c := TPointRecord.& &op_Addition(a, b);   
 
不过我很少看到有什么情形需要我们这样写的就是了。 (定义运算符号的用
意，是让我们能够简化运算方法的名称，直接写算式当然比写成函数调用更
为直觉，对吧 ?) 
 
  实作出可交换性 (Implementing Commutativity)  
假如我们希望值做一个能把整数数值加到记录当中的功能。 我们可以定义以
下的运算方法 (这些程序代码也在 OperatorsOver 范例项目里面找到，提供给
两种显然不同的纪录型别使用 ): 
class operator TPointRecord2.Ad d(a: TPointRecord2; b: Integer): TPointRecord2;   
begin  
    Result.x := a.x + b;  
    Result.y := a.y + b;  
end;   
_________________________________________________________________________  
之所以要把这个运算符号定义在一个新的型别，而没有在已经定义好的纪
录里面加上它，是因为同样的结构已经定义了 Implicit转换，把一个整数换
乘该记录型别了。所以我就不用另外定义一个新的运算符号，就能直接把
整数加到记录里面了。这个问题我们会在下一节里面好好说明。  
 
现在，我们就可以把一个浮点数合法的加入到记录里面了：  筆記  
筆記   
 155  
var 
   a: TPointRecord2;  
begin  
    a.SetV alue(10, 20);  
    a := a + 10;  
 
然而如果我们把表达式子反过来写：  
a := 30 + a;   
 
编译程序就会回报错误 : 
[dcc32 Error] E2015 Operator not applicable to thi s operand type   
 
就像我们刚刚介绍过的，在实务上，运算符号定义后，是不会自动具备可交
换性这个特质的，我们得自己重复制作，或者制作这个运算符号的另一种多
载版本：  
class operator TPointRecord2.Add(b: Integer; a: TPointRecord2): TPointRecord2;   
begin  
   Result := a + b; // 提供可交换性   
end;   
 
 
  隐含转换与型别介绍 (Implicit Cast and Type Promoti ons) 
注意！这个重要：在呼叫运算符号时的解析，跟以往呼叫方法时的规则是完
全不同的。当型别自动介绍发生时，是有可能发生单一一个表达式结束时，
因为存在不同参数的多载，而导致函数调用产生混淆的情形的。这也是为何
我们要更费心在 Implicit运算符号的使用上。  
 
以下面的表达式来思考前一个范例：  
a := 50;  
c := a + 30;   
c := 50 + 30;   
c := 50 + TPointRecord(30);   
 
这些表达式都没有问题。在第一个式子中，转型会在指派动作之后发生。第
二个式子，编译 程序会把 30转换成适当的记录型别。第三个式子， explicit
型别转换会强迫把第一个数值用 Implicit转型。然后加法才能在这些记录中 
 156 执行。换句话说，第二个参数的结果跟另外两个都不一样，我们来看看执行
的结果吧：  
// output  
 (80:20)  
 (80:10)  
 (80:20)  
 
// expanded statements   
c := a + TPointRecord(30);   
// that is: (50:10) + (30:10)   
 
c := TPointRecord (50 + 30) ;  
// that is 80 converted into (80:10)   
 
c := TPointRecord(50) + TpointRecord(30);   
// that is: (50:10) + (30:10)   
 
 
变异型别 (Variants)  
为了要完整支持 Windows 的OLE跟COM技术， Object Pascal 在原生数据
型别当中就有所谓的松散型别概念，这个型别就是 Variant。即使这个名称
可能唤起你对变动记录 (我们稍早介绍过 )的印象，而且在实作层面上跟开放
数组参数有点类似， Variant是完全不同的功能，实作上也是用特殊的方法
来完成的 (Windows 开发世界中不常用的语言 )。 
 
在这一节里，我不会真的去参照 OLE跟这个数据型别参照的其他情境 (像
data set 介绍时要提及字段存取一样 )。我会回头来看动态型别，
RTTI(RunTim Type Information) 并参照第 16章，在那个章节里面，我也会提
到一个相关的型别 (但是是型别安全的喔 )，称为 TValue。在这里我想  
从一般观点来讨论数据型别。  
 
  变异型别没有型别 (Variants Have no Type)  
一般来说，我们可以用 Variant变量来储存任何型别的数据，并且进行数字
运算、型别转换。在 Variant的使用上，自动型别转换会打破 Object Pascal
所遵循的型别安全的通则，而使用动态型别的概念，这个概念在其他语言中
有被介绍过，例如 SmallTalk 跟Objective -C，在一些脚本语言里面也提供了 
 157 这样的功能，像是 JavaScript, PHP, Python 跟Ruby.  
 
变异型别会在运行时间进行型别判别跟运算。 编译程序不会警告我们在程序
代码里面可能有什么错误，因为它只能做一些延伸测试。整体来看，我们 可
以把使用了变异型别的程序代码视为直译程序代码， 因为也只有直译器的程
序代码才会在运行时间才能检查数据的正确性。实务上，这也直接冲击到执
行的速度。  
 
现在，我要提出警语，让大家尽量避免使用 Variant这个型别，我们来看一
下Variant能做什么。基本上，当我们宣告了一个 Variant型别的变量 : 
var 
   V: V ariant;  
 
我们就可以把很多不同型别的数据指派给它了：  
V := 10;  
V := 'Hello, World';   
V := 45.55;   
 
我们一有了 variant数值之后，就可 以把它复制到任何兼容或不兼容的数据
型别去了。如果我们把一个数值指派到不兼容的数据型别变量去，编译程序
并不会在编译的时候指出错误，而会在运行时间进行可接受的型别转换。如
果找不到可接受的型别转换， 就会抛出一个运行时错误的讯息。 技术上来看，
Variant会把型别信息随着数据做储存，允许一些可容许的运行时间型别转
换，但会会牺牲速度，且比较不安全。  
 
我们看一下以下的程序代码 (这是 VariantTest 范例项目的一部分 )，这是上面
程序代码的一些延伸：  
var 
   V: V ariant;  
   S: string;  
begin   
   V := 10;  
   S := V;  
   V := V + S;  
   Show (V);  
 
   V := 'Hello, World';   
   V := V + S;  Show (V);    
 158    V := 45.55;  
   V := V + S;  
   Show (V);  
 
有趣吧 ?以下是输出结果 (不意外 ): 
20  
Hello, World10   
55.55   
 
除了把储存有字符串的 variant变量指派给 S变量，我们也可以把储存有整
数、浮点数的 variant变量指派给 S变量试试看。再折磨它一下，我们可以
用variant来计算数值， 例如 V := V + S; 这个算式会以 variant里面储存的数
据格式来试着直译多种计算的方法。在以上的程序代码里面，同一行算式可
能对整数、浮点数进行加总，也可能是做字符串连接。  
 
在算式里面放了 variant是有风险的。如果该字符串里面是储存数字，那么
运算就 ok, 但如果不是，就会跑出运行时错误了。如果你不是要特别引人注
意这个情形，就不要使用 Variant这个型别。还是使用标准的 Object Pascal
数据型别，以及型别检查的规则吧。  
 
  深入探讨变异型别 (Variants in Depth)  
深入了解 Varaint也是很有意思的，我们再多加一些技术信息吧。 Variant是
怎么运作的， 我们又能怎么更深入控制一些 ?RTL(运行时间函式库 )包含了变
动记录型别 :TVarData, 这个型别对内存的控制跟 Variant一样。我们可以用
它来存取 Variant数据的实际型别。 TvarData 结构包含了 Variant的型别，用  
VType、一些保留字段、以及实际值来标示。  
__________________________________________ _______________________________  
如果需要更详细的研究 TVarData 这个型别的定义，请参考 RTL的原始码，
在System单元文件中可以找到。它的定义跟一般简单的数据结构定义很不
一样。我建议具备了足够经验之后再去看关于变异型别的定义比较好。  
 
VType这个字段的内容会随着我们在 OLE变量里面所储存数据的型别而有
不同。通常 OLE变数的型别会被称为 OLE型别或变异型别 (variant types) ，
以下列出所有可用的变异型别：  
varAny      varByte    varDate  
varEmpty     varInteger    varOleStr  
varSingle     varTypeMask   varUString  筆記   
 159 varArray     varByRef    varDispatch  
varError      varLongWord   varRecord  
varSmallint     varUInt64    varV ariant  
varBoolean     varCurrency    varDouble  
varInt64      varNull    varShort Int 
varString     varUnknown    varWord  
 
以上的型别名称都很直觉，几乎都从字面上就可以知道它的用途，但要注意
里面的 null value 的概念，我们可以透过指派 NULL(不是 nil)给variant变数
来得到这个值。  
 
有很多函式可以用来处理 variant，我们可以用来制作特定的型别转换，或者
用来询问一个 variant变量的真正数据型别 (例如 VarType函式 )。这些型别转
换跟指派的函式通常都会自动被使用，当我们撰写了使用到 variant变量的
表达式时就会自动使用到。其他支持 variant的程序代码，实际上是使用了
variant数组，再次重申，这个结 构几乎只有 Windows 用在 OLE整合的时候
才会使用，其余平台、情形几乎不会有用到的机会。  
 
  变异型别很慢 (Variants Are Slow)  
使用了 Variant型别的程序代码会很慢，不只是当我们在做数据型别转换的
时候，即使是我们做很简单的两个数字相加也一样。它的速度几乎跟直译器
的程序一样慢。为了比较使用 variant跟使用一般整数的执行速度，我们用
相同的算法来实验，我们从 VariantTest 范例项目的第二个按钮程序来看。  
 
这个程序会跑一个循环，计时、然后更新进度列的状态。以下是两个相似循
环中的第一个，以 Int64跟Variant来比较：  
const maxno = 10000000; // 10 million   
var 
   time1, time2: TDateTime;  
   n1, n2: V ariant;  
begin  
    time1 := Now;  
    n1 := 0;  
    n2 := 0;  
    while n1 < maxno do  
    begin  
        n2 := n2 + n1;    
 160          Inc (n1);  
    end;  
    
   // we must use the result   
   time2 := Now;   
   Show (n2);   
   Show ('V ariants: ' + FormatDateTime ( 'ss.zzz', Time2 -Time1) + ' seconds');   
 
计时的程序代码值得看一下， 因为未来我们可以用这个方法来做任何可能的
效能测试。我们可以看到程序代码里面用 Now函式来取得当时的时间值，
然后用 FormatDateTime 函式来显示时间的经过，可以用 ss来显示经过了几
秒，或者用 zzz来显示经过了几个 ms. 
 
在这个范例里面，速度的差异非常显著，即使不特别去计算也能注意到 : 
49999995000000   
V ariants: 01.169 seconds   
49999995000000   
Integers: 00.026 second   
 
上面的数字是我在 Windows 虚拟机上面执行的结果， variant的结果比直接
用整数慢了 50倍。当然，在每一台计算机上执行的结果都会不一样，但差
别不会太大，用越快的机器来跑，这个倍数说不定会增加的更为显著。在我
的Android 手机上面，执行结果如下 (花的时间都更长，这是一定的，手机
的运算能力本来就不如桌机 ): 
49999995000000   
V ariants: 07.717 seconds   
49999995000000   
Integers: 00.157 second   
 
在我的手机上，速度比 Windows 慢了 6倍，事实上执行花了 7秒多，这样
的运行时间一定会让使用者很有感觉。 但用整数实作的程序代码执行起来虽
比桌机运行时间多 7倍，但连 0.2秒都不到，使用者仍旧很难意识到这个等
待的时间。  
 
指标的两三事 (What About Pointers)  
在Obje ct Pascal 里的另一个基础数据型别就是指针。 有一些面向对象语言已
经把这个强大却有些危险的程序结构给藏起来了， 不过 Object Pascal 仍旧让 
 161 程序人员在需要的时候使用它 (不过已经不如以前那么常用到了 )。 
 
但什么是指标呢 ? 这个名词又是哪来的 ? 跟其他大多数的数据型别不同， 指
针不储存实际的数据，它只储存变量在内存里面的地址，透过指针，我们可
以找到变量的实际使用内存空间，进而得到里面的数据。  
_______________________________________________________ __________________  
在本书中，这部份属于进阶的章节，在此介绍指标是因为它是 Object Pascal 
语言的一部分，而且是所有程序人员都需要知道的核心知识的一部分。虽
然它并不是基础的主题，如果您是刚接触 Object Pascal 的话，您可以先跳
过这个章节，未来再回来复习即可。如果您过去接触的程序语言都是没有
指标的类型，这个短短的章节对您来说读起来也可能很有趣。  
 
指针的定义并不是透过特定的关键词，它是透过特别的符号 (ˆ)来宣告的。举
个例子，我们可以定义一个指针，指向整数变量：  
type  
    TPointerToInt = ^Integer;  
 
我们定义好指针变量之后，就可以把另一个同型别的变量的地址指派进去
了，只要透过 @符号即可：  
var 
  P: ^Integer;  
  X: Integer;  
begin  
   X := 10;  
   P := @X;   
   // change the value of X using the pointer   
 
   P^ := 20;   
   Show ('X: ' + X.ToString);   
   Show ('P^: ' + P^. ToString);   
   Show ('P: ' + Integer(P).ToHexString (8));   
 
以上的程序代码是 PointerTest 范例项目的一部分。 假设指针 P指向了变量 X，
我们就可以用 Pˆ取得 X的数据，可以读取也可以变更里面的内容。我们也
可以独立显示 P的内容， P的内容就是变量 X在内存里面的地址，我们可以
把指针转型为整数，就可以看到地址了。上面的范例程序不显示整数，而是
以16进位来显示， 这在内存的寻址里面比较常见， 以下是程序的输出结果 (指
针的内容会随着编译与执行的结果有所不同 )： 筆記   
 162 X: 20  
P^: 20  
P: 0018FC18  
_________________________________________________________________________  
要对指标的内容做整数转型，只有在 32位的平台才会正确，在 64位的平
台是不会正确的。另一个好一点的选择是把它转型成 NativeInt ，然而
NativeInt 没有整数型别助手可以使用，所以会让简单的程序变得稍微复杂
一点，所以这个范例目前只限定 32位专用。  
 
我来整理一下，当我们宣告了指针变量 P: 
 直接使用指标 (P), 我们可以取得 P所指向的内存地址。  
 使用指标指向 (Pˆ), 我们可以取得 P指向的内存内容。  
 
指针不只可以指向已经配置好的内存地址， 它也可以动态指向特定的内存区
块，例如我们可以用 New程序来配置一块新的内存空间，此时就可以用指
针储存刚配置好的这块空间的地址。而当不需要再使用的时候，就可以用
Dispose程序来释放它 (行动平台则使用 DisposeOf) 。 
_________________________________________________________________________  
内存管理跟 Heap作业的细节，我们会在第 13章里面加以介绍。简单的说，
Heap是一大块由操作系统配置给应用程序随机取用 /释放的内存空间。 除了
New跟Dispose之外，我们也可以用 GetMem 跟FreeMem 来取用额外的内
存空间，但是 New跟 Dispose比较安全一点。  
 
以下程序片段是用来示范如何使用随机配置内存：  
var 
   P: ^Integer;  
begin  
   // initialization   
   New (P);   
   // operations   
   P^ := 20;   
   Show (P^.ToString);   
   // termination   
   Dispose (P);   
如果在使用后没有把内存释放掉，我们的程序最后就会把可用的内存用尽，
然后挂掉。没有把配置的内存释放掉的错误，通常称为内存泄漏 (Memory 
leak)。 
_________________________________________________________________________  警語  
筆記   
 163 要让上面的范例程序安全一点，我们可以用 try-finally区块，这个主题我们
会在第九章进行介绍 。 
 
如果一个指针变量没有值，我们可以指派 nil给它。我们可以先检查指标的
内容是否为 nil，如果不是 nil，我们才能够去读取其指向的内存空间内容。
Object Pascal 提供了一个名为 Assigned 的函式， 让我们可以方便进行这样的
测试。  
 
这样的测试很常用，因为存取未被配置的内存空间内容，会导致内存违规存
取而使程序错误 (不同操作系统对内存违规存取的处理各有不同的作法，
Windows 会跳出一个错误窗口， iOS跟Android则是直接关闭该程序 )： 
var 
   P: ^Integer;  
begin  
    P := nil;  
    Show (P^.ToString);  
 
我们可以执行 PointerTest 范例项目来看看发生这个错误的反应， Windows
的错误窗口会显示如下的信息：  
Access violation at address 0080B14E in module 'PointersTest.exe'. Read of address 00000000.   
 
为了让存取指标更为安全，我们可以加入一些检查，看看指标内容是否为  
nil: 
  if P <> nil then  
    Show (P^ .ToString);  
 
另外，在 Object Pascal 里面提供的 Assigned 也可以用来检查这种情形 : 
if Assigned (P) then   
  writeln (P^.ToString);   
_________________________________________________________________________  
Assigned 倒不是一个真的函式，因为这个关键词会让编译程序产生适当的
检查程序代码。 Assigned 也可以用在检查程序型别变量 (或者方法参考 )是否
有被指派，不用真的执行看看该程序或方法是否存在。  
 
Object Pascal 也定义了一个名为 Pointer的数据型别，这个型别可以指向未
定义型别的指针 (就像 C语言里面的 void*)如果我们使用了未定义型别的指
标，我们就得用 GetMem，不能用 New来配置内存空间。因为用 New来配
置，系统会以 New所要配置的数据型别自动计算大小来配置。而 GetMem筆記  
筆記   
 164 则需要告诉系统需要配置的内存空间。  
 
事实上，在 Object Pascal 里面不常需要使用指标，但指标是这个程序语言里
面一个有趣的进阶功能。能够提供这个功能，就能让我 们实作出一些可以直
接呼叫操作系统层级，高效率的 API跟函式了。无论如何，了解指针对进
阶程序设计以及完全了解语言对象模型是很重要的。  
 
文件型别, 还有谁有提供 ?(File Types, Anyone?)  
本章最后的一节，我们来介绍 Object Pascal 数据型别建构的过程，就是 文件
(file)型别。文件型别是用来表示实体磁盘 文件，这也是原始 Pascal语言里面
就具备的功能，相较起来，目前已经很少有旧的或现代的程序语言会把 文件
的概念作为基本的数据型别了。 Object Pascal 语言也提供了 file关键词， 用
来代表文件型别，就像 array或record一样。我们可以用 file来定义一个新
的型别，然后用这个型别来宣告新的变量 : 
type  
  IntFile = file of Integers;   
var 
   IntFile1: IntFile;  
 
我们也可以直接用 file这个关键词，不用指定该 文件的内容型别，直接定义
一个文件。当然我们也可以使用 TextFile型别，这个型别定义在 RTL里面
的System单元，使用来宣告使用 ASCII字符的文件 (或者更精确一点，是定
义byte组成的文件 )。 
 
最近这几年来， 直接使用 文件已经越来越不常见了，不过这个功能还是存在
的。在 RTL里面已经提供了很多种可以用来管理二进制跟文本文件的类别
(例如，支持 Unicode的文本文件 )。Object Pascal 应用程序一般来说都会使
用RTL的stream类别 (TStream 以及衍生的相关类别 )来处理许多跟 文件相关
的读写动作。 Stream用来表示虚拟 文件，可以对应到实体 文件、内存区块、
网络信道，以及任何其他连续的 byte组合。  
 
我们还是可以看到许多旧时代的 文件管理函式， 那些是提供给命令字符模式
(DOS命令字符 )的程序开发之用， 我们可 以使用 write, writeln, read 等相关函
式来对特定的 文件进行读写的动作，这些都是使用标准输入、标准输出加以
提供的 (C跟C++也对输入输出有类似的支持，其他的程序语言也提供了类
似的服务 )。  
 165 06:关于字符串  
 
字符、字符串已经是所有程序语言最常处理的数据型别了。在 Object Pascal
里，字符串的处理非常简单、快速，功能也非常强大。就算字符串基本上
很容易掌握，且我们在前几章的范例中已经用了很多次字符串作为输出，
但在幕后，字符串的处理还是比第一眼的印象来的复杂。文字处理还是使
用了一些值得我们 仔细了解的主题：要完整了解字符串处理，我们还需要
知道关于 Unicode 的表示法、了解字符串怎么跟字符数组对应，还要学习
一些在执行时期函式库 (RTL)里面跟字符串处理相关的函式，包含把文字存
放到文件里，以及从文本文件里面加载文字的方法。  
 
Object Pascal 在文字处理上有一些选项，提供了不同的资料型别跟处理方
法。本章的焦点会放在标准的字符串型别上，但我们还是会花一些时间来
介绍目前桌机版操作系统仍在使用的旧版字符串型别 (有别于行动装置版 )。
在开始主题之前，我们先从基本开始吧 :Unicode 表示法。  
 
Unicode: 全世界的字母  
Object Pascal 的字符串管理是以 Unicode字符集为中心的， 尤其是以 UTF -16
为主。在我们深入技术细节之前，值得先花一些时间来看一下 Unicode 的
标准。  
 
Unicode的设计理念， 是要用单一一个字符集把世界上所有的文字都包含在
内，这样的作法把许多复杂的问题单纯化了，但要实现这个理想的过程却
极为复杂。在 Unicode 的设计中，是要以同一个叙述方式，同时包含图形
化的表示方法，以及独特的数值 (称之为 Unicode的字码 )。 
______________________ ___________________________________________________  
Unicode联盟的网址是 http://www.unicode.org ，在这个网站中，提供了非常
多的文件，最具代表性的文件是  ”The Unicode Standard” 这本书，这本书
可以在网上找到： http://www.unicode.org/book/aboutbook.html.  
 
并不是所有程序人员对 Unicode都熟悉， 而且很多程序人员直到今日还在使
用比较旧的文字编码方法，例如 ASCII (或者称之为 ISO编码 )。我们很快介
绍一下这些旧标准，您就会对 Unicode的特点 (或是其复杂度 )更为感激了。  
 筆記   
 166   旧的文字编码 :从ASCII到ISO编码  
字符编码始于美国标准信息交换编码 (American Standard Code for 
Information Interchange – ASCII)，这个标准是在 1960年代早期发展出来，
作为计算机字符的编码标准。当时这个编码法只涵盖了 26个英文字母  (包
含大写、小写 )、10个数字、常用的标点符号，以及一些控制字符 (我们到今
天还有使用到 )。 
 
ASCII使用 7 bit来表示系统常用的 128个不同字符。只有从 #32(空格符 )到
#126(~：波浪号 )是肉眼可见的字符，请见图 6.1 (从Windows 平台的 Object 
Pascal应用程序中解译出来的 )。 
_________________________________________________________________________  
 
 
 
  
 
 
 
 
 
ASCII当然是所有字符编码的基础 (这基本的 128个字符目前仍旧是 Unicode
编码的核心部分 )，后来很快的就以这 128个字符做延伸 ，改以 8 bit做为储
存字符编码内容的数据长度，让 ASCII多了另外 128个字符。  
 
目前所遭遇的问题，是全世界有太多种不同的语言，但并没有简单的方法让
我们可以知道其他语言的文字要怎么被囊括在这个集合当中 (就像过去的
ASCII可以把英文字母跟常用符号包含在内一样 )。为了让这个情形得到解
决，Windows 里面内载了许多种不同的文字集合， 我们后来称之为 code page ，
透过 code page 的定义，我们可以把不同语言的文字依照不同语系的
Windows 版本进行显示。除了 Windows 的Code page 之外，还 有许多种类似
的分页标准，用来对不同语系的文字进行定义与编码，这些分页方式后来都
成为了 ISO国际标准的一部分。  
 
目前仍旧最常被使用到的 ISO文字编码标准仍然是 ISO 8859 ，在这个标准
里面定义了好几个区域集合。最常用到的集合 (大多数西方国家几乎都使用
这个集合 )是Latin这个集合，也被称为 ISO 8859 -1。 
 圖6.1: ASCII
當中的可視字
元集  
 
 167 _________________________________________________________________________  
即使 Windows 1252 code pa ge跟ISO8859 -1已经极其接近， 但仍然没有完全
兼容。 Windows 在里面加入了一些额外的字符，例如 €符号等，这些额外
的字符被添加在 128到150区域中。除了跟 Latin集合的所有值不同，
Windows 的这些延伸值也跟 Unicode的字码无法兼容。  
 
  Unicode 字码跟字形  
如果要精确一点，我们应该再多介绍另一个概念，就是字码。事实上，有时
多个字码可能指向同一个字形 (可以辨识的文字 )。通常这不一定是单一一个
文字，可能是文字，或者文字跟符号的组合。举例来说，如果我们有一串字
码代表拉丁文字的 a(#$0061)，尾随着重音符号 (#$0300)，这样的组合应该会
是代表一个音标符号。  
 
在Object Pascal 的编码名词中，如果我们写了以下的程序代码 (这是
CodePoints 范例项目的一部分 )，这个讯息就只会包含一个文字，如图 6.2所
示：  
var 
   str: String;  
begin  
   str := #$0061 + #$0300;   
   ShowMessage (str);   
______________________________________________________ ___________________  
  
 
 
 
 
 
在这个例子里，我们是写了两个字符，代表两个字码，但实际上两个字码的
组合只指向一个单一符号。事实上，在拉丁字符集里面，我们可以用一个字
码直接指向前述的这个字符 (字符 a加上重音符号的字码是 $00E0)，在其他
的字符组合， Unicode的字码是唯一能够取得刚刚这个字符的方法 (并且能够
正确输出喔 )。 
 
即使显示的是一个重音音标，并没有可以自动把这个资料进行转换的方法
(只能够适当的显示 )，因此字符串内部处理对字符  à 仍旧各有不同的作法。  筆記  
圖6.2: 多個
Unicode 字碼
指向單一一個
符號  
 
 168 ____________ _____________________________________________________________  
要正确显示由多个字码所组合描述的字符符号，必须依赖操作系统的特别
处理，也必须使用文字绘制技术。所以我们应该有发现到，在操作系统上
并不是所有的字都可以正确的被显示出来。  
 
  从字码到字节  (UTF)  
ASCII使用直接而简单的方法处理字母跟其编码数值之间的对应， Unicode
则使用比较复杂的方式。就像我已经提过的，在 Unicode的每个字符，都有
一个关连的字码，但对应到要显示的字符， 则通常要复杂的多。  
 
在Unicode的原理背后，比较容易让人混淆的元素之一，是同一个字码  (或
者说是 Unicode 字符的编码数值 )在文件、内存、实际储存在媒体上的时候
可能有多种方法加以表示。这个问题主要是因为所有只存在唯一对应的
Unicode的字码实际上都是用了 4 bytes来表示的。 这个作法实现了固定长度
表示字符的思路 (所有字符都是以固定长度的数值加以表示 )，但大多数的开
发人员会觉得这样对内存用量和处理程序上都太昂贵了。  
_________________________________________ ________________________________  
在Object Pascal 里面， Unicode 字码是直接以 4 bytes的UCS4Char 数据结
构来直接表示的。  
 
这也是为何 Unicode 的标准里还定义了其他表示方法，会使用比较少的内
存，但在这些表示方法里面，每个符号储存所使用的空间就会随着字码而有
不同了。这个想法为最常用的元素提供了短一点的表示方法，而比较不常用
的元素则会用比较长的储存空间。  
 
Unicode 字码在实际储存时不同的表现格式，被称为 Unicode Trasnform ation 
Format (简称 UTF)。这些格式是算法的对应，它们是 Unicode标准的一部分，
可以让每个字码 (每个绝对的数值都对应到一个字符 )对应到每个文字所拥
有的代表数值。我们要注意到，这个对应关系是双向的，可以在不同的表现
方式中双向转换。  
Unicode标准定义了三种 UTF格式， 分别以不同的长度来为之命名： 8, 16, 32。
了解这三种格式最多需要 4 bytes来为每个字码编码其实还蛮有趣的。  
 UTF -8 把每个字符转换成变动长度来储存，每个字符的编码可能使用 1
到4个byte不等。 UTF -8也是目前 HTML跟类似的协议最常用的，因为
UTF -8最为精简，所有 ASCII的字符几乎完全兼容于 UTF -8的格式。  筆記  
筆記   
 169  UTF -16则是很多操作系统 (包含 Windows 跟Mac OS X) 跟开发环境最常
用的格式。这个格式可以把绝大多数的文字用两个 byte来表示，相对
来说很精简，而且处理上速度也很快。  
 UTF -32在处理上速度最快，因为所有字符编码都是相同的长度，但是
在内存用量上最浪费，也因此在实务应用上很少被使用。  
UTF -16 最常被误解为可以用 2 bytes直接对应到所有字码，但因为 Unicode
包含了超过  10万个 字码， 我们直接心算一下， 就知道总量超过了 2 bytes 所
能表示的元素上限  (64K)，所以 UTF -16是不可能完整对应到所有  Unicode 
字码  的。然而，开发人员常常只需要用到 Unicode的一部分子集合，所以会
把用到的字符塞到每两个 byte定义一个字符，用固定长度来表示。  
在早期，这个 Unicode的子集合被称为 UCS -2，现在我们会常看到 UCS -2对应
到基础多语系平面 (Basic Multilingual Plan, BMP) 。然而这仍然只是 Unicode
的子集合 (许多语系平面之一 )。 
_________________________________________________________________________  
有一个和多位表示法 (UTF -16跟UTF -32)相关的问题， 就是到底哪个位是起
始位 ? 根据 Unicode 标准的定义，怎么排列都可以，所以我们可以定义
UTF -16 BE(big endian) 或者 LE(litte -endian)，UTF -32也一样。 Big-endian位
序列，是最高位优先 (Most Significate Byte first ，MSB优先 )。而 little-endian
则是最低位优先 (Least Significant Byte first, LSB 优先 )。位序列通常会标注
在文件的最前面，称之为位序列记号 (Byte Order Mark, BOM) 。 
 
  位序列记号  (BOM)  
当一个文本文件里面储存  Unicode 字符，有个方法可以注记这个 文件使用
哪一种  UTF 格式来储存  字码。这个信息会储存在 文件的开头，称为位序
列记号 (Byte Order Mark, BOM) 。这可以视为用以辨识 Unicode使用何种序列
格式 (LE 或者  BE)的签章。 以 下的列表汇总了一些不同的 BOM， 包含了 2, 3, 
4个 bytes的长度 : 
00 00 FF FE    UTF -32, big -endian  
FE FF 00 00   UTF -32, little -endian  
FE FF          UTF -16, big -endian  
FF FE          UTF -16, little -endian  
EF BB BF       UTF8       
我们会在本章后段介绍 Object Pascal 如何用它的串流式类别管理 BOM。
BOM会出现在 文件的最开头 ，Unicode数据则会立刻接在 BOM后头。 所以，筆記   
 170 一个内容为 AB的UTF -8文件，它的前五个 Bytes会是这样的 (3个是 BOM, 
2个是 AB这两个字符 ): 
EF BB BF 41 42   
 
如果文本文件开头没有出现 BOM， 这个文件就会被认为是 ASCII文本文件，
但这文件也可能包含其他种类编码的文字。  
_________________________________________________________________________  
在另一种用法，当我们从 Web，或者从其他网络协议接收数据的时 候，我
们可能得从该协议的其他定义中来区分编码方式，就不能用 BOM了，反而
透过这些协议取数据的时候 BOM有时还会让编码识别造成困扰。  
 
 
  看清楚 Unicode  
我们有可能用像图 6.1那样的列表来把所有的 Unicode 字符全部列出来吗 ?
我们可以用基础多语系平面 (Basic Multilingual Plan, BMP) 来显示字码，排除
掉代理对应 (surrogate pairs) 。 
________________________________________________________________ _________  
并非所有数值都是真实的 UTF -16 字码，因为有些字符 (称之为代理对应：
surrogate pairs) 的数值并不是合法的数值数据，这些数值是大于 65535的数
字，超过了 2 bytes可以描述的范围。代理对应当中一个很好的例子，就是
乐谱里面的低音部记号   ，它的字码是 1D122，以 UTF -16表示的话，就需
要以两个数值来表示 :D834然后接着 DD22。 
 
要完整把所有这个 BMP的元素显示出来，需要一个 256x256的矩阵，在屏
幕上面很难完整显示。这也是为何 ShowUnicode 这个范例项目里面在两页
之间用了 tab来做分隔的原因：第一个 tab显示 256个区块的主要索引值，
第二个 tab则显示真实 Unicode的元素。每次显示一个区块。这个范例当中
的用户接口比本书其他范例程序都多了一些， 如果您只是对 Unicode有兴趣
的话，可以忽略它的程序代码，只看它的输出部分。  
 
在这个程序的开头，在 TabControl 的第一个分页当中，我们放了一个
TListView 组件，这个 ListView有256个项目，每个项目被点击的时候，都会
显示一组 256个Unicode字符。以下是在 onCreate这个事件处理 程序的程序代
码，我们用了一个简单的程序来显示每一个元素，对应的输出值请参考图
6.3 : 
 
// helper function   筆記  
筆記  
 
 171 function GetCharDescr (nChar: Integer): string;   
begin   
   if Char(nChar).IsControl then   
     Result := 'Char #' + IntToStr (nChar) + ' [ ]'   
   else  
      Result := 'Char #' + IntToStr (nCh ar) +  
               ' [' + Char (nChar) + ']';   
end;   
 
procedure TForm2.FormCreate(Sender: TObject);   
var  
   I: Integer;   
   ListItem: TListViewItem;  
begin  
    for I := 0 to 255 do // 256 pages * 256 characters each   
    begin   
       ListItem := ListVie w1.Items.Add;  
       ListItem.Tag := I;   
       if (I < 216) or (I > 223) then   
       ListItem.Text :=  GetCharDescr(I*256) + '/' + GetCharDescr(I*256+255)   
       else   
           ListItem.Text := 'Surrogate code points';   
    end;   
end;   
 
_____________________________________________________ ____________________  
 
 
 
 
 
 
 
 
 
 
 
 圖6.3: 
ShowUnicode
範例的第一
頁，程式畫面列
出了很長的
Unicode 字元
區塊  
 
 172 请留意程序代码里面是怎么储存这些分页的号码的，我们用了 ListView 项
目中的 Tag这个属性， 这个属性储存了稍后我们用来显示该项目对应的区段
所需的信息。当用户点击任一个 ListView 的项目时，应用程序就会切换到
TabControl 的第二个分页，把该区段的 256个字符显示在字符串矩阵上。  
procedure TForm2.ListView1ItemClick(const Sender: TObject; const AItem: TList ViewItem);   
var 
   I, NStart: Integer;  
begin  
   NStart := AItem.Tag * 256;   
   for I := 0 to 255 do   
   begin   
      StringGrid1.Cells [I mod 16, I div 16] :=   
         IfThen (not Char(I + NStart).IsControl, Char (I + NStart), '');   
   end;   
   TabContro l1.ActiveTab := TabItem2;   
 
这里的 IfThen函式是用来作两种测试：如果传入的第一个参数为真 (或说判
别式成立 )的话，这个函式会把第二个参数回传。反之，则以第三个参数回
传。在这里的测试使用了 InControl 这个字符型别助手的方法，用来过滤掉
无法显示的控制字符。  
_________________________________________________________________________  
这里用到的 IfThen函式，作用很像 C语言阵营里面的 ?:运算符号。同样的
函式，有一个用来测试字符串的版本。另一个则是用来测试整数的版本。
测试字符串的版本放在 System.StrUtils 单元文件里面， 测试整数的版本则是
放在 System.SysUtils 里面。  
由范例程序所输出的 Unicode字符矩阵，我们用图 6.4来做显示。请注意到
输出的字符，会随不同操作系统当中的显示有所差异，即使选择的是同样的
区块， Window跟Mac的显示仍可能有差异。  
__________________________________________________________________ _______  
 
 
  
 
 
 
 
 
 筆記  
圖6.4: 
ShowUnicode
範例的第二
頁，程式畫面顯
示了實際的
Unicode 字元  
 
 173 再度介绍字符型别  
在简单介绍过 Unicode 之后，我们回头来看一下这个一章的主题，也就是
Object Pascal 式如何管理字符跟字符串的。我们在第二章已经介绍过了字符
型别， 也提到了型别助手的相关函式可以在 Character 单元当中引入来使用。
现在，我们也对 Unicode有了更完整的认识，是时候深入多看些细节了。  
 
首先，字符型别并不是一成不变的记录 Unicode的字码。事实上字符型别对
每个元素都使用两个 byte来记录其数值。当字符以 Unicode 的基础多语系
平面 (Basic Multilingual Plan, BMP) 来表示字码的时候，同时也可以透过代理
对应 (surrogate pairs) 来显示字码。  
 
技术上来说，我们可以使用另一个型别来直接记录任何一个 Unicode code ，
这就是 UCS4Char 型别，它使用了 4 bytes来记录一个数值。这个型别不常
被使用到，因为它需要使用更多的内存空间，我们可以看到 Character 单元
里面提供了好几种不同的处理方法给这个型别使用。  
 
回到字符型别，请记得它是一个列举型别 (可能是所有列举型别当中相对比
较大的 )，所以这个型别本 身有顺序性，并且我们也可以把 Ord, Inc, Dec, 
Hight, Low 这些函式套用在字符型别上面。绝大多数的延伸功能，都包含在
型别助手里面，它们不是基本的系统 RTL单元的一部分，所以我们得自己
引入 Character 单元。  
 
  使用Character 单元来处理 Unicode  
大多数对于 Unicode字符的特殊处理 (当然也包含 Unicode字符串 )都被定义
在System.Character 这个单元当中。这个单元文件定义了 TCharHelper 这个
型别助手，用来提供 Char型别协助，让我们可以直接从 Char型别的变量中
直接呼叫这些处理方法。  
_________________________________________________________________________  
Character 单元定义了一个名为 TCharacter 的纪录型别，在这个型别当中定
义了一系列的静态类别函式，搭配有一些全局的子程序跟这些方法对应着。
这些函式已经比较老，有些都已经被弃用了。在 Unicode层级来处理 Char
型别，这些方法却仍然是很有帮助的，所以透过类别助手提供。  
 
这 个 单 元 文 件 也 定 义 了 两 个 很 有 趣 的 列 举 型 别 。 第 一 个 称 为
TUnicodeCategory ，它对应了很多分类的字符，例如控制字符、空格符、大
写字符、小写字符、数字、标点符号、数学符号等等。第二个则是筆記   
 174 TUnicodeBreak ，它定义了许多不同的空白、分隔符。如果我们惯用 ASCII
各种处理方法，那改用 Unicode就将是个很大的改变。在 Unicode里面，数
字不只是从 0到9的字符，空白也不仅仅是字符 #32，在其他许多不同语系
的字符分页中，都可能也有相同意义的字符。  
 
字符型别助手提供了超过 40个不同的测试与处理方法，可以用来：  
 取得字符的数字表示值 (GetNumericValue)  
 询问目录 (GetUnicodeCategory) ，或者检查字符是否属于不同目录当中
的任何一种 (IsLetterOrDigit, IsLetter, IsDigit, IsNumer, IsControl, 
IsWhiteSpace, IsPunctutation, IsSymbol, 以及 IsSeparator) 。 在前一个范
例中，我就使用了其中的 IsControl 判断方法。  
 检查是否是大写或小写 (IsLower, IsUpper) 或者转换大小写 (ToLower, 
ToUppe r) 
 确认是否属于 UTF -16代 理 对 应 (surrogate pairs)(IsSurrogate, 
IsLowSurrogate, IsHighSurrogate) ， 也可以用不同方式转换代理对应字
符。  
 把 字 符 转 换 成 UTF -32或从 UTF -32字 符 转 换 为 字 符 型 别
(ConvertFromUtf32, ConverToUtf32) ，或者转换成 UCS4Char 型别
(ToUCS4Char)  
 确认是否为特定字符里面的成员 (IsInArray)  
 
请留意以上所有的动作，是对字符型别全体内容一体适用，不是只对特定变
数有效。 所以我们可以用字符型别当做起始关键词，来使用上述的方法，我
们将在底下的程序范例里面介绍。  
 
为了把这些方法对 Unicode 字符做点实验，我们提供了范例项目，名称是
CharTest。这个范例当中的一个实验，是对 Unicode字符呼叫大写、小写操
作方法的实验。事实上在 RTL里面，传统的 UpCase方法只能对基本的 26
个ASCII表示法的英文字母有效， 对于 Unicode字符来说就没有所谓的大小
写之分。 (因为并非全世界的文字都有大小写之分，所以这个方法无法一体
适用于所有的 Unicode字符 ) 
 
为了测试这个情境，在 CharTest 这个范例项目里面，我加入了以下的程序片
段，试着把一个音标符号转成大写 : 
var 
   ch1: Char;  
 begin  
    ch1 := 'ù';    
 175     Show ('UpCase ù: ' + UpCase(ch1));   
    Show ('ToUpper ù: ' + ch1.ToUpper);   
 
传统的 UpCase没办法把拉丁音标符号进行转换，而 ToUpper 方法可以做的
很完美：  
UpCase ù: ù   
ToUpper ù: Ù   
 
在字符型别助手里，包含了许多 跟Unicode相关的功能，像是在接下来的范
例程序代码里面所介绍的，这些程序代码定义了一个字符串，字符串里面的
文字也涵盖了在 BMP(低于 Unicode 64K 以下的字码 )以外的字符，以下的
程序代码也是 CharTest 范例项目的一部分， 我们对字符串中的不同字符做了
一些测试：  
var 
   str1: string;  
begin  
    str1 := '1.' + #9 + Char.ConvertFromUtf32 (128) +   
           Char.ConvertFromUtf32($1 D11E);  
    ShowBool (str1.Chars[0].IsNumber);  
    ShowBool (str1.Chars[1].IsPunctuation);  
    ShowBool (str1.Chars[2].IsWhiteSpace);  
    ShowBool (str1.Chars[3].IsControl);  
    ShowBool (str1.Chars[4].IsSurrogate);  
end;   
 
显示结果的函式在这个范例中是一个改写过的版本：  
procedure TForm1.ShowBool(value: Boolean);   
begin   
    Show(BoolToStr (V alue, True));  
end;  
_________________________________________________________________________  
Unicode 字码  $1D11E是乐谱符号的 G调符号。  
 
  Unicode 字符常数  (Unicode Character Literals)  
在前几个范例中， 我们已经知道可以直接把独立的字符常数或 字符串常数指
派到字符或字符串变量里面了。 我们也可以直接透过数字把字符表示指派给
字符串或字符变量，只需在数字前加上一个井字号 (#)，不过这样可能会发筆記   
 176 生意外。  
为了兼容以前的程序代码， 直接输入的字符常数内容会依照它们的内容来进
行转换。以下的程序片段就是把数值 128指派给字符串，这个字符串就会显
示成欧元符号 (€): 
var 
   str1: string;  
begin  
    str1 := #$80;  
 
以上的程序代码并没有遵循 Unicode 规范，上面这个符号的字码是 8364。
事实上，这个数值并不是从 ISO官方的codepage 定义而来，而是从微软为
Windows 实作的数据得来的。 为了让已经存在的程序代码能够更轻松的转移
到Unicode兼容的功能。 Object Pascal 编译程序会把 2码的字符串数值直接
当成 ASCII字符来处理 (当然这得视用户的计算机所使用的 code page 而定 )。
如果我们把数值转成字符，然后再加以显示，数值就会变成其代表的正确字
符了，够惊讶吧 ? 所以，以下的程序代码执行以后：  
Show (str1 + ' - ' + IntToStr (Ord (str1[1])));   
 
就会得到这样的输 出：  
€ - 8364   
 
假如我们想要完整的把原有的程序代码全部转换为 Unicode, 把旧有的
ANSI数据全部放弃，我们可以直接修改编译程序设定，只要直接在程序代
码里面加入这个设定 : #HIGHCHARUNICODE 即可。这个设定会决定从  
#$80到 #$FF的数值要被怎么处理 ? 我们稍早曾介绍过默认的选项 (关闭 : 
OFF)，如果我们把这个设定开启了，同样的程序就会输出如下的结果：  
☐ - 128  
 
这些数值会被直译为实际的 Unicode 字码，而输出值就会变成看不见的控
制字符。另一个处理特定字码 (或者任何 #$FFFF以下的 Unicode 字码 )的方
法，则是使用四个数字加以表示 : 
str1 := #$0080;  
 
这样也仍然不会显示欧元符号，除非我们把 $HIGHCHARUNICODE 这行设
定拿掉。但我们可以用 4个数值来表示远东的文字，例如以下的程序可以显
示两个日文文字：  
str1 := #$3042#$3044;  Show (str1 + ' - ' + IntToStr (Ord (str1.Chars[0])) +   
     ' - ' + IntToStr (Ord (str1.Chars[1] )));   
 177  
上面的文字可以显示出以下的结果：  
あい - 12354 – 12356  
_________________________________________________________________________  
あい可以译为 ”相遇”，但我不是完全确定我找到的这个翻译是不是正确，
因为我不懂日文，所以或许会有错。  
 
以上为原作者的文字。あい要看在日文里面的前后文跟汉字的转换，あい
可以对应汉字的 ”爱”，或者逢い。  
逢い：就像原作者找到的翻译，就是相逢、遇见的意思。  
爱: 这不用我多说了 …… 
 
我们也可以用超过 #$FFFF的数值，这些数值会自动被转换为适合的代理对
应(surrogate pairs) 。 
 
字符串数据类型  (String Data Type)  
在Object Pascal 里的字符串数据类型比简单的字符数组更为完整， 而且其功
能比大多数有提供字符串型别的程序语言的字符串功能更为强大。 在这一小
节里面，我也会介绍在这个型别当中的关键观念。接下来的章节里，我们会
更深入的介绍这些功能。  
 
在以下的列表中， 我会列出在 Object Pascal 里面字符串型别运作的关键概念
(请记得，我们可以不用 了解观念，也仍然可以把字符串使用的很好，且内
部运作的规则也是非常透明的 )： 
 字符串型别所使用的数据，是从 heap里面动态配置来的。字符串变量
就是实际数据的参考。但我们完全不用担心这些细节，因为编译程序
会帮我们把这些细节都处理好。就像使用动态数组一样，我们宣告一
个新的字符串变量时，变量的内容是空的。  
 我们有很多方法可以把数据存放到字符串变量里面去， 我们可以实际去
配置一块内存空间 -呼叫 SetLength 函式，它所需的参数，是我们需要
配置的字符数量， (当然，每个字符是 2 bytes)。当我们扩展一个字符
串的时候， 已经存在该字符串的数据会被保留的好好的 (不过这些数
据可能被搬移到不同的内存空间去 )。当我们把字符串缩小的时候，
原本的字符串内容就有部分可能会遗失。 我们几乎不用去重新设定字
符串的长度。 仅有的情境是当我们要把一个字符串的缓冲区传递给操
作系统特定的函式使用。  
 如果我们需要增加字符串在内存的空间 (例如做两个字符串连接 )，但有筆記   
 178 可能原来的内存地址已经无法再扩增 (可能后面的空间被其他变量用
到了 )，此时连接字符串的动作就需要重新配置一段足以容纳连接之
后的字符串数量的内存， 然后把两段字符串都复制到新的这段内存空
间，然后把旧的 那段给释放掉。  
 要清除掉我们已经不再使用的字符串，我们可以直接指派一个 ’’给字符
串变量，或者我们可以用 Empty这个常数，它也同样代表了 ’’这个字
符串。  
 根据 Object Pascal 的规则，字符串的长度 (我们可以透过呼叫 Length函
式来取得 )代表该变量里面合法字符的数量，而不是配置的数量。跟
C语言不同的是， C语言的字符串必须用 #0作为字符串结尾，而所有
版本的 Pascal都直接配置了字符串内容所需的内存大小。 然而我们仍
然可以在字符串的尾端找到字符串结尾符号。  
 Object Pascal 的字符串使用了参考计 数(Reference -Counting) 机制，这可
以持续追踪一共有多少个字符串变量在参考这段内存。 参考计数会在
某个字符串变量再也没有被使用的时候释放内存。也就是说，当没有
任何变量参考该段内存的时候，参考计数的数值就会变成 0. 
 字符串使用了 ”写入时才复制 ”的技术，这是很有效率的。当我们把一个
字符串指派给另一个字符串，或者把字符串当成参数传递给函式时，
没有任何数据被复制，只是参考计数会被增加而已。然而，如果其中
一个参考到这个内存的变量试图改变内容， 这个时候系统就会把该段
内存复制到另一个空间，然后改变这个新空间 的内容，原本的内存内
容不会被改变。  
 字符串连接的作法，对已经存在的字符串是很快的，且没有明显的副作
用。当有其他替代的要求时，字符串链接是很快且很强大的。但这对
于目前已经存在的许多程序语言来说，就没这么简单。  
 
我猜以上的描述可能会让许多人迷惑，所以我们来实际看看字符串的使用。
我们待会来看一些以上提到的功能的示范，包含参考计数跟写入时才复制。
在我们开始介绍前， 我们先来回头看一下字符串型别助手的功能以及一些其
他在基本 RTL上面的字符串管理功能。  
 
在深入介绍前，我们先说明前面列表里面的一些名词。因为字符串的处理 已
经相当无缝化，所以很难完整解析到底发生了什么事。除非我们开始深入观
察字符串的内存结构，这一点我们在本章后续会持续深入，但这个主题目前
有点太深奥。所以我们开始看一些简单的字符串处理吧，从 Strings101 应用
程序项目开始 : 
var 
   String1, String2: string;   
 179  begin  
   String1 := 'hello world';   
   String2 := String1;   
   Show ('1: ' + String1);   
   Show ('2: ' + Str ing2);   
   String2 := String2 + ', again';   
   Show ('1: ' + String1);   
   Show ('2: ' + String2);   
end;   
 
当上面这段程序代码执行，会让我们知道，当我们把同一个字符串指派到两
个不同的字符串变量时，变更其中一个的内容，另一个并不会被影响到。在
这个例子里， String1并不会被 String2的内容变动所影响到。  
1: hello world   
2: hello world   
1: hello world   
2: hello world, again   
 
在我们开始下一个范例之前，先说明一下，一开始的字符串指派动作，并不
会导致字符串的完整复制，复制的动作会被延迟 (再说一次，这个功能叫做 ”
写入时才复制 ”)。 
 
另一个要介绍的重要功能，则是字符串长度是如何被管理的。如果我们查询
一个字符串的长度， 我们所得到的响应， 会是字符串所使用的实际长度值 (这
个长度的数据是储存在字符串的 meta data 里面，会使得这个查询动作非常
快就能完成 )。但如果我们呼叫 SetLength 函式，这个函式会直接配置内存，
但不会进行初始化。 这常被用在把字符串当成呼叫外部系统函式的参数时。
相反地，如果我们需要一个空字符串，我们可以使用虚拟建构函式 (Create)。
最后，我们可以用 SetLength 来切割一个字符串。以上所提到的都包含在以
下的程序代码里面：  
var 
   string1: string;  
begin  
    string1 := 'hello world';   
    Show(string1);   
    Show ('Length: ' + string1.Length.ToString);   
 
    SetLength (string1, 100);    
 180     Show(string1);   
    Show ('Length: ' + string1.Length.ToString);   
   string1 := 'hello world';   
   Show(string1);   
   Show ('Length: ' + string1.Length.ToString);   
 
   string1 := string1 + string.Create(' ', 100);   
   SetLength (string 1, 100);  
   Show(string1);   
   Show ('Length: ' + string1.Length.ToString);   
 
输出的结果会像以下这样 : 
hello world   
Length: 11   
hello world ~̆~̫~͌~ʹ~Η~υ~ϧ~Ј~Щ~ы~ѭ~ҏ~ұ~Ә~Ӽ~ԟ~Շ~հ ~~~۵~ܚ~ܼ~ݡ~ރ~ޤ~ߊ ߰~~ࠔ~ࠔ~ࠔ~ࠔ~ࢮ~ࠔ  
ܼ~ֳ~ו~׵~؛~ف~٦~ڋ~گ~  ٔ~~ 
Length: 100   
hello world   
Length: 1 1  
hello world   
Length: 100   
我想在本节里面强调的第三个概念，是空字符串的概念。所谓的空字符串，
是指字符串变量所存的文字内容是空的。不论是在指派或是比对的用途，我
们都可以用两个单引号，或者用特定的函式来表示空字符串：  
var 
   string1: string;  
begin  
   string1 := 'hello world';   
   if string1 = '' then    
     Show('Empty')  
   else  
     Show('Not emp ty');  
 
   string1 := ''; // or string1.Empty;   
   if string1.IsEmpty then   
     Show('Empty')  
   else  
     Show('Not empty');    
 181  
输出的结果如下 : 
Not empty  
Empty  
 
  把字符串作为参数传递  
我们刚提到过，如果我们把字符串指派给另一个字符串，实际上的动作只是
复制了内存地址，内存内所存放的字符串内容并不会被复制。然而如果我们
的程序代码在字符串变量被指派后改变了字符串变 量的内容， 原始字符串的
内容会被复制到另一个内存空间，然后进行修改 (也只有在对字符串内容进
行更动的时候，才会执行这个程序 )。 
 
另一个会发生类似复制程序的时间点， 是在把字符串作为参数传递给一个函
式或程序的时候。默认的作法，系统会制作一个新的内存地址来存放作为参
数的字符串，这样一来，万一在子程序中改动了作为参数的字符串，原始的
字符串就不会受到影响。假如我们要使用另一种规则，就是子程序当中的改
动要直接套用在原始字符串变量的话，我们就得用传址呼叫的方式，只需在
参数前面加上一个 var关键词即可 (同样的作法也可以套用在 大多数其他简
单的数据型别上面 )。 
 
但是万一我们不想改动作为参数被传递进子程序的字符串呢 ? 在这个情形，
我们可以在参数前面直接加上个 const描述字即可。加上了 const描述字之
后，编译程序就不会让我们在子程序里面改动该字符串变量的内容了，但是
同时也会优化参数传递的动作。事实上， const字符串不会要求子程序进入
时增加该字符串的参考计数，也不会要求离开时减少该字符串的参考计数。
由于这些动作非常快，执行它们数千或数百万次，也只会对我们的程序增加
很轻微的负担。这也是为何我们建议在没有改动参数需求时，直接在参数前
加上 const关键词的原因了。  
 
用程序的语汇来说，以下的三个程序宣告中，字符串参数的传递都是使用不
同方法来达成的：  
procedure ShowMsg1 (str: string);   
procedure ShowMsg2 (var str: string);   
procedure ShowMsg3 (const str: string);   
 
  []的使用，以及字符串中对字符计数的模式   
 182 一如我们所知的，我们在使用 Object Pascal 或者其他程序语言的时候，有个
很关键的字符串处理方法，就是取用字符 串当中的某一个元素 (字符 )，有时
我们会透过方括号，也就是取用数组元素的相同方法。  
 
在Object Pascal 里，提供了两个明显不同的方式来达成这个功能：  
 Chars[]字符串型别助手的处理，可以把字符串当成一个只读的字符数
组，是 0 base的索引值喔。  
 标准的 []字符串处理函式， 可以读取， 也可以写入字符串的任一个元素，
至于是以 0 base或者  1 base, 则取决于编译程序的设定。  
 
一开始这当中会有一点容易迷惑，而且需要厘清的地方，我们先看一下简单
的历史介绍之后，再加以介绍。之所以要做这个简短的历史 介绍 (如果觉得
对这个没兴趣，可以跳过 )，是因为要理解目前 Object Pascal 以现在的作法
来提供字符串功能，而没有了解过往的作法，会很难理解。  
_________________________________________________________________________  
让我们先回顾一下历史，所谓鉴古而知今。在 Pascal语言的早期，字符串
是被以类似字符数组的方式来处理的。在这个字符数组的第一个元素 (可以
视之为数组的第 0个元素 )是用来记录字符串当中合法字符的数量的。在那
个时期里， C语言要计算字符串长度时，就得每次都重新计算一次，直到
字符串结尾字符出现为止。而 Pascal的程序只需要直接检查第一个 Byte即
可，假设第 0个byte是用来记载字符串的长度，字符串的第一个字符就是
从数组的第 1个元素开始了。随着时间经过，其他程序语言都随着 C语言
的习惯，把字符串跟数组的第一个元素从索引值 0开始记录。后来， Object 
Pascal也开始让动态数组改为 0 base，渐渐的所有 RTL跟组件库里面相关
数据结构也都改为了 0-base，唯独字符串是一个很特别的例外。而在迈入
了行动开发的纪元之后， Objec t Pascal 语言的设计群们决定提供字符串的
0-base优先权，让开发人员万一有旧的程序代码需要移植到行动平台时可
以选择。当然这也在开发人员论坛里面引起了很多的争论。  
 
假如我们想要对索引值使用 0-base跟1-base的不同做出一个比较详细的比
较，可以思考一下在欧洲跟北美洲对于楼层的算法 (我真的不知道世界上其
他地区是怎么计算的 )。在欧洲，地面楼层称为 0楼，一楼则是高于地面楼
层的第一层楼。而在北美洲，地面楼层称为 1楼，高于地面楼层的第一层则
算是 2楼。 换句话说， 北美洲使用 1 base的楼层计算法， 而欧洲是使 用0 base
的计算法。 而对字符串来说， 绝大多数的程序语言都使用 0 base的楼层算法。  
 
我们再更深入一点来说明，以刚刚我们介绍过的， Char[]使用了  0 base的索
引法，所以如果我们写 : 筆記   
 183 var 
   string1: string;  
begin  
   string1 := 'hello world';  
   Show (string1.Chars[1]);  
 
则输出的字符会是 : 
e 
 
万一我们直接使用方括号来存取字符串内容，把程序代码改写如下：  
Show (string1[1]);  
 
这个输出的结 果就可能是 h或e，取决于当时的编译程序设定  
$ZEROBASESTRING ，如果这个设定值是开启的 , 输出的结果就是 e, 如果
这个设定值是关闭的，输出值就是 h。现在假定这个设定值是为了提供和旧
版本程序代码的接轨，行动版的编译程序默认是把这个设定值设定为开启，
而Windows 版的编译程序则默认是关闭这个设定值的。我们要如何处理这
个差异呢 ?以下是几种不同的选项：  
 对于新建的项目来说，我的建议是对所有的程序代码都开启 0-base字
符串的功能 (在项目选项的层级设定 )，不管是行动应用程序或是桌面
应用程序都一样，并遵循 所有程序语言对字符串使用上的标准程序。  
 如果您有旧的项目，已经测试完毕、验证完毕，在传统的 Pascal 1 -base
字符串上已经运作的很好了，就把 0-base的设定关闭，直接编译出
行动版的应用程序吧。  
 确定您的程序代码在上述两种情形都能正确运作，把索引值给抽象化，
例如使用 Low(字符串 )当做索引的第一个值。这个作法可以在任何一
种设定法都正常运作。然而，如果我们要让程序代码更容易懂，就需
要一些在写应用程序之外额外的处理。  
 
在实作第一跟第二种策略的时候相对简单，因为不用管设定，程序写起来花
费的心思少了很多，我 在这一节的范例中用 for循环加以示范：  
var 
   s: string;  
   I: Integer;  
 begin  
   s := 'Hello world';   
   for I := Low (s) to High (s) do   
      Show(s[I]);    
 184 换句话说，字符串毫无例外的拥有着从 Low到High函数所回传的数值之间
的所有元素。如果我们想深入了解，一般来说，这跟编译程序的设定有关，
我们可以这么写 : 
Low(String);  
 
这个函式回传的值不是 0就是 1，端看编译程序的设定 。无论如何，永远要
记得，是一个编译程序的设定来决定字符串存取时，中括号里面的索引值是
如何被解译的。  
_________________________________________________________________________  
字符串就是字符串，关于 0-base的字符串概念，我讲的完全是错的。在内
存的数据结构并没有不同，所以我们可以我们可以把任何字符串当做参数
传递给任何函式，不管是编译程序怎么设定，都不会出错。换句话说，如
果我们有段程序，在编译程序设定为 0-base字符串时，需要把字符 串传递
给1-base的函式库，系统仍然是可以正确处理这种情形的。  
 
  字符串连接  
我已经提过， Object Pascal 跟其他程序语言不一样， Object Pascal 完全支持
直接进行字符串连接，而且处理速度相对比其他程序语言更快。在这一章里
面，我已经示范过一些字符串连接的程序代码，当中也做了一些速度测试。
在后面的章节里，在第 18章，我会简报关于 TStringBuilder 这个类别，这个
类别遵循了 .NET组成字符串的表示法。 因为使用 TStringBuilder 有一些原因，
效能并不是最重要的一个 (在以下的范 例中，我会加以示范 )： 
var 
   str1, str2: string;  
begin  
   str1 := 'Hello,';   
   str2 := ' world';   
   str1 := str1 + str2;   
 
请留意到我把 str1这个变量同时使用在一个指派动作的左边跟右边， 把一一
些新的内容加在已经存在的字符串后面，而不是指派给另一个全新的变数。
当然两种作法都没问题，只是加在一个已存在的字符串的效能会比较好。  
 
这种字符串连接的作法也可以用个循环来达成，就像以下从 LargeString 范
例项目中撷取的部分程序代码：  
uses  
    Diagnostics;  筆記   
 185 const   
   MaxLoop = 2000000; // two million   
var 
   str1, str2: string;  
   I: Integer;  
   t1: TStopwatch;  
begin  
   str1 := 'Marco ';   
   str2 := 'Cantu ';   
 
   t1 := TStopwatch.StartNew;  
   for I := 1 to MaxLoop do  
      str1 := str1 + str2;  
   t1.Stop;  
   Show('Length: ' + str1.Length.ToString);   
   Show('Concatenation: ' + t1.ElapsedMilliseconds.ToString);   
end;   
 
这段程序代码执行后，我从 Windows 虚拟机跟 Android 装置分别得到以下
的输出结果 (桌机比较快一点 ): 
// Windows (in a VM)   
Length: 12000006   
Concatena tion: 59   
 
// Android (Nexus 4)   
Length: 12000006   
Concatenation: 991   
 
这个范例项目的程序代码跟 TStringBuilder 类别的作法有些类似。目前我还
不想深入这个范例项目的程序代码 (在第 18章的时候我们再深入讨论 )，我
们只要先看实际上执行所花的时间， 和直接连接的作法所花的时间做个比较  
// Windows (in a VM)   
Length: 12000006   
StringBuilder: 79   
 
// Android (Nexu s 4)  
Length: 12000006   
StringBuilder: 1057    
 186 我们可以看到，连结的动作可以说是最快的选项。  
  字符串助手的处理程序  
假如字符串型别是重要的，那么这个型别的助手所提供的处理程序应该不
少，这一点应该不会让人太惊讶。假如这些处理程序在大多数的应用程序中
都很重要，且很常被使用到，那我就认为应该用个清单好好来介绍一下 : 
 
我已经把字符串型别助手的处理程序用逻辑先编组了 (这些程序大多都拥有
好几个多载版本 )，简单的叙述一下它们的功能，大多数的功能名称都能很
直觉的看出其功能：  
 复制整个字符串或复制部分字符串，像 Copy, CopyTo, Join 跟SubString  
 字符串变更程序，像 Insert, Remove, Replace  
 把一些不同型别的数据转成字符串，我们可以用 Parse或Format  
 把字符串转成不同型别的数据，我们可以用 ToBoolean, ToInteger, 
ToSingle, ToDouble, ToExrtended, 如果要把字符串转成字符数组，我
们也可以用 ToCharArray  
 把空格符塞到一个字符串里，我们可以用 PadLeft, PadRight, 也可以用
Create的一个多载版本。相对的，我们也可以把空格符移除，透过
TrimRight, TrimLeft 跟Trim.  
 字符串的比较跟相符测试 (Compare, CompareOrdinal, CompareText, 
CompareTo 跟Equals) - 请记得， 我们也可以用等号来比较两个字符串
是否内容相同。  
 转换大小写用 LowerCase, UpperCase, ToLower 跟ToUpper 以及
ToUpperInvariant  
 检查字符串内容，我们可以用 Contains, StartsWith, EndWith。要搜寻特
定字符是否存在该字符串中，也可以用 IndexOf 来达成 (从字符串开
头到特定位置之间的搜寻 )。 相似的函式还有 IndexOfAny( 这可以搜寻
一个字符数组中的任何一个字符是否存在该字符串中 )，LastIndexOf
跟LastIndexOfAny 可以从字符串结尾开始回头找特定字符最后一次
出现在该字符串的位置。最特殊的处理程序，则是 IsDelimiter 跟
LastDelimiter ，这是用来检查字符串的结尾是否是目录分隔符，以及
最后一次目录分隔符出现的位置。  
 要存取字符串长度，我们可以用 Length函式，这个函式会回传字符串
中内含字符的数量。 CountChars 则可以把代理对应 (surrogate pair) 一
并计算， GetHashCode ，可以回传该字符串的哈希值 (Hash value) 。另
外还有一些检查的程序，例如 IsEmpty, IsNullOrEmpty 以及
IsNullOrWhiteSpace 都可以用来检查字符串的内容是否为空。  
 字符串的特殊处理程序， 像是 Split, 可以帮我们把字符串依照特定分隔 
 187 符(或分隔字符串 )切成许多部分。要移除或加入引号，我们可以用
QuotedString 或者 DeQuoted.  
 最后，要存取单独字符，我们可以用 Char[]，方括号中需要填入数值索
引。透过这个处理程序，我们可以读取特定的字符，但不能修改它，
这个函式的索引值是 0-base的，跟 C语言的特性相同。  
 
事实上，很重要的一点，所有字符串型别助手的处理程序都是依照 RTL的
字符串建立的，也就是说，它引入了 0-base字符串的概念，字符串的开始
元素从 0开始，字符串的长度记录在  -1的位置。换个说法，所有字符串型
别助手的处理程序都使用 0-base的索引值作为参数与回传值。  
___________________ ______________________________________________________  
Split程序是在 Object Pascal RTL 里面较新的成员。之前比较常见的作法，
是把字符串加载到 stringList 里面，然后设定一个特定的断行符号，接着就
可以一一读取每一行的文字了。 Split处理程序则在效能跟弹性上都有了显
著的提升。  
 
假如我们需要对字符串处理程序进行大量的处理， 我可以写几个项目来示范
这些功能。或者也可以只提到几个相对简单的程序，或者常用的程序：  
var 
  Str1, Str2: string;  
  I, NIndex: Integer;  
begin  
    Str1 := '';  
    // create string   
    for I := 1 to 10 do   
       Str1 := Str1 + 'Object ';  
    Str2:= string.Copy (Str1);  
    Str1 := Str2 + 'Pascal ' + Str2.Substring (10, 30);  
    Show(Str1);  
 
请留意我使用 Copy函式的方 法，我是直接建立了一份独立的字符串来储存
相同的内容，而不是只做了指派替身。即使在这个特定的范例中，也没有任
何不同。最后一个处理程序时， SubString 的函数调用是用来解开字符串的
内容，结果文字如下：  
Object Object Object Object Object Object Object Object Object Object   
Pascal ect Object Object Object Objec   
 
在初始化完成之后，第一个按钮会处理搜寻部分字符串，并且重复这样的搜筆記   
 188 寻，透过不同的起始搜寻 点，来计算目标字符串出现的次数 (在范例中，是
搜寻单一字符 )： 
// find substring  
Show('Pascal at: ' +  
    Str1.IndexOf ('Pascal').ToString);  
// count occurrences  
I := -1; 
NCount := 0;  
repeat  
   I := Str1.IndexOf('O', I + 1);  // search from next element   
   if I >= 0 then   
     Inc (NCo unt);  // found one   
until I < 0;   
Show('O found: ' +  
    NCount.ToString + ' times');  
 
这个 repeat循环不是最简单的一个：它从一个负值开始，之后找到吻合的字
符后，就从该吻合的字符之后再继续进行搜寻，所以也会记录下吻合的字符
出现的次数，如果没有任何吻合的字符，则回传 -1。上述这段程序代码的输
出值为：  
Pascal at: 70   
O found: 14 times   
 
第二个按钮的功能则是扮演搜寻与取代的功能，可以搜寻 特定字符串，并把
搜寻到的字符串更改为指定字符串。 在搜寻的功能中， 会建立一个新字符串，
复制初始与最后的部份，并加入一些新的文字在中间。取代的功能则是使用
了Replace 函式来处理出现多次的字符串，透过适当的参数传递即可
(rfReplaceAll) ，以下是范例程序代码 : 
// single replace   
nIndex := str1.IndexOf ('Pascal');   
str1 := str1.Substring(0, nIndex) + 'Object' +   
         str1.Subst ring(nIndex + ('Pascal').Length);  
Show (str1);  
 
// multi -replace  
str1 := str1.Replace('O', 'o', [rfReplaceAll]);   
Show (str1);   
  
 189  
由于输出的字符串相当长，而且不易阅读，我只列出当中的部分字符串：  
...Object Pascal ect Object Object...   
...Object Object ect Object Object...   
...object obje ct ect object object...   
 
重申一次， 这只是在众多丰富的字符串处理功能中， 很小一部分的范例而已，
在字符串型别助手当中还有许多功能等着我们去发现呢。  
 
  更多字符串的运行时间函式库 (RTL)  
决定沿用其他语言常用的处理程序名称来制作字符串型别助手的一个效应，
就是这些名称会跟传统 Object Pascal 的处理程序名称不同 (这些处理程序直
到今天还是存在于全局函式当中 )。以下的列表就可以看出一些名称不同的
函式了：  
global    string type helper   
Pos    IndexOf  
IntToStr   Parse  
StrToInt   ToInteger   
CharsOf   Create   
StringReplace  Replace   
_________________________________________________________________________  
要记住，这些全局函式跟字符型别助手的处理程序之间的一个极大不同：
第一组的函式使用的是 1-base的索引方式来处理字符串，第二组的函式使
用的都是 0-base的。  
 
只有在 RTL当中最常用的字符串函式被改了名字，其他比较不常用的函式
则还是沿用了旧名称，例如 UpperCase 或QuotedString 。在 System.SysUtils
单元里面还有许多这样的字符函式， 这些函式很多并没有被并入到字符串型
别助手当中。  
 
这些函式中，值得一提的包含有 : 
 ResemblesText ，这个函式实现了 Soundex 算法 (可以找到不同拼法，但
读音相同的英文字汇 ) 
 DupeString ，这个函式会回传特定函式被要求的份数。  
 IfThen，这个函式会在判断式成立时回传第一个字符串，不成立时回传
第二个字符串 (我在本章前面的范例中有使用到这个函式 ) 
 ReserveString ，这个函式会把参数字符串顺序全部颠倒之后回传。  筆記   
 190  
  格式化字符串  
透过加号来链接字符串、使用一些转换函式之后，我们已经可以产生出比较
复杂的字符串了。但还有一个比较不同的、更强大的方法来把数字、金额以
及其他数据进行格式化后转换成字符串的方法。 复杂的字符串格式化可以透
过呼叫 Format函式来达成， 这个函式很传统， 但很常用， 不只在 Object Pascal
里面有，在其他程序语言里面也有提供。  
__________________________ _______________________________________________  
『输出格式化字符串』这个功能的函式家族，或者称为 printf的函式，在早
期的程序语言里面都有提供，像是 FORTRAN 66, COBOL, 以及 ALGOL 
68。这些特定的格式化字符串符号与结构到今日仍在使用 (Object Pascal 里
面也有使用到 )，这些结构跟函式都很接近 C语言的 printf函式，需要对相
关主题更深入研究的话， 建议您可以参考 en.wikipedia.org/wiki/Printf_format  
_string这个网址。  
 
Format函式要求一个包含基本输出的文字，以及特定参数格式符号 (会以 %
符号作为开头字符，再加上各种代号表示不同型别 )的字符串作为参数，以
及一个数据数组，用来对应前面指定参数格式字符串的各个字段。例如，要
把两个数字格式化输出到一个字符串中，我们可以写成：  
Format ('First %d, Second %d', [n1, n2]);   
 
上面的 n1跟n2是两个整数数值。第一个参数格式符号 (%d)会被 n1的内容
取代，第二个参数格式符号则会被 n2的内容取代，如果有多个参数，则顺
序依此类推。 如果数组当中的变量或数据型别跟参数格式符号的顺序对不起
来，就会发生运行时错误。没办法在编译阶段进行型别检查，是我们在使用
Format函式的时候的最大风险。相似的是，如果我们在数组里面指定的数
值个数跟参数不同，也会发生错误。  
 
Format函式使用了开放数组参数 (我们在第五章介绍过，该参数可以有不特
定的数量与型别作为参数内容 )。除了使用 %d, 我们也可以使用许多型别的
参数格式符号，我们稍后会提供一个列表来说明各种型别的代号。这些参数
格式符号都会为其代表的型别提供预设的输出值。 然而我们也可以使用更多
的格式表达方法来替代预设的输出值。例如，宽度的格式表达法可以决定使
用固定长度的字符，好让输出的数字格式可以有固定的位数，例如：  
Format ('%8d', [n1]);   
 
这个范例会把 n1的数值转换成一个 8个字符的字符串，字符串靠右对齐 (使筆記   
 191 用减号则可以让字符串靠左 )如果不足 8个字符，则会用空格符来补足，以
下就是各个型别的参数格式符号列表：  
d (十进制整数 ) 此符号对应以十进制表示法把整数转换成字符串  
x (十六进制数 ) 此符号对应以十六进制表示法把整数转换成字符串  
p (指针 )   此符号对应以十六进 制表示法把指针转换成字符串  
s (字符串 )   此符号对应字符串、 字符或者 PChar(指向字符数组的
指针 )， 
        该变量的内容会被复制到输出的字符串去。  
e (指数 )   此符号对应浮点数， 会以科学计数表示法把浮点数显示为  
                字符串。  
f (浮点数 )  此符号对应浮点数，会把浮点数数值以字符串显示。  
g (通用 )   此符号会以最短的十进制表示法把浮点数或指数以字符
串 
显示。  
n (数字 )   此符号对应浮点数，会以十进制显示浮点数数值，但会每  
三位数就自动加上千位 符号。  
m (货币 )   此符号对应货币数值，会以十进制显示浮点数，但以货币  
数值加以显示，因此该转换会依照地区货币的设定进行。  
 
要仔细观察这些转换的最好方法，莫过于我们直接用 format函式来实验了。
为了让这个实验容易一点，我们提供了 FormatString 范例项目，在这里面使
用者可以自行输入格式化字符串来为一些预先定义好的整数变量加以显示。  
 
这个程序的窗体在按钮之上有一个输入文字框 (TEdit)，初始化之后，内容是
一个预先定义的格式字符串 (‘%d - %d - %d’)。 第一个按钮让我们显示较为复
杂的范例格式化字符串 (程序代码会把格式化字符串 ’Value %d, Align %4d, 
Fill %4.4’ 指派到文字框里面 )。第二个按钮会把这个字符串应用在预先定义
的变量中，透过以下的程序代码：  
var 
   strFmt: string;  
   n1, n2, n3: Integer;  
begin  
   strFmt := Edit1.Text;  
   n1 := 8;  
   n2 := 16;  
   n3 := 256;  
 
   Show (Format ('Format string: %s', [ strFmt]));    
 192    Show (Format ('Input data: [%d, %d, %d]', [n1, n2, n3]));    
   Show (Format ('Output: %s', [Format (strFmt, [n1, n2, n3])]));   
   Show (''); // blank line   
end;   
 
如果我们先以初始的格式化字符串进行显示， 然后再以复杂点的格式化字符
串进行显示 (依序点击第二个按钮，第一个按钮，然后再点第二个按钮 )，我
们应该就会看到如下的输 出字符串：  
Format string: %d - %d – %d  
Input data: [8, 16, 256]   
Output: 8 - 16 - 256  
 
Format string: V alue %d, Align %4d, Fill %4.4d   
Input data: [8, 16, 256]   
Output: V alue 8, Align 16, Fill 0256  
 
在这个程序后隐含的意义，是让我们可以直接输入格式化字符串，然后试着
套用这些字符串来显示变量内容， 我们可以对照看更多可以使 用的格式化选
项。  
 
  字符串的内部结构  
我们可以使用字符串，而不需要了解字符串的内部作法，但仔细来看一下这
个型别内部的实际数据结构也是挺有趣的。在早期的 Pascal语言里面，字符
串的长度限制是 255个字符，并会使用第 0个位来储存字符串的长度。从早
期的发展到现在已经经过许久，但把额外信息储存为字符串信息的一部分，
仍旧被保留下来，成为 Object Pascal 语言的特色 (C语言阵营的其他程序语
言则还是使用字符串结尾符号的概念来实作字符串 )。 
_________________________________ ________________________________________  
传统 Pascal字符串型别的型别名称是 ShortString ，它是使用单一位字符或
者AnsiChar 为元素，长度限制为 255个字符。 ShortString 型别在桌面应用
程序版的编译程序仍然可以使用，但在行动版编译程序已经不能使用了。
我们仍然可以透过类似的数据结构，带领位的动态数组来达成这个功能，
或者 Tbytes，或者 Byte的静态数组也可以。  
 
一如我们已经介绍过的，字符串变量只是个指向从 heap配置而来的记忆空
间的指针。事实 上，储存在字符串变量的数据，并不是从这个数据的最前头
开始记录的，第一个字符是被储存在第 1个位置，而不是第 0个位置。字符筆記   
 193 串的相关信息则是储存在索引负值的内存空间当中。 在内存当中对字符串型
别的表示法如下 : 
-12  -10  -8  -4  字符串指针所指到的地
址 
Code 
page  元素大小   参考计数   字符串长度  字符串的第一个字符   
第一个元素 (从字符串指针开头的地方往回算起 )是用来记录字符串长度的
地方。第二个元素则是用来记录参考计数，接下来的字段 (只用在桌面应用
程序编译程序 )是每个元素占用几个位 (目前不是 1就是 2)， 最后则是以 Ansi
为基础的字符串型别用来记录 code page 的字段 (同样也只用在桌面应用程
序编译程序 )。 
 
很令人惊讶，除了我们熟知的 Length之外，居然还有函式可以直接存取这
些底层的字符串属性字段。  
function StringElementSize(const S: string): Word;   
function StringCodePage(const S: string): Word;   
function StringRefCount(const S: string):  Longint;   
 
就像范例程序中所述，我们可以建立一个字符串，并且询问一些关于它的信
息，我们用 StringMetaTest 这个范例来做示范 : 
var 
   str1: string;  
begin  
   str1 := 'F' + string.Create ('o', 2);   
 
   Show ('SizeOf: ' + SizeOf (str1).ToString);   
   Show ('Length: ' + str1.Length.ToString);   
   Show ('StringE lementSize: ' +   
       StringElementSize (str1).ToString);   
   Show ('StringRefCount: ' +   
       StringRefCount (str1).ToString);   
   Show ('StringCodePage: ' +   
       StringCodePage (str1).ToString);   
 
   if StringCodePage (str1) = DefaultUnicodeCodePa ge then   
     Show ('Is Unicode');   
   Show ('Size in bytes: ' +    
 194       (Length (str1) * StringElementSize (str1)).ToString);   
   Show ('ByteLength: ' +   
           ByteLength (str1).ToString);  
_____________________________________________________________ ____________  
范例程序中以动态的方式来建立出 ’Foo’这个字符串，而没有直接指派一个
字符串常数是有特殊原因的，因为字符串常数的参考计数是没有作用的 (或
者设为 -1)。在这个范例中，我想要详细的显示出参考计数的内容，所以使
用了动态的方法来建立字符串。  
 
这个范例的执行结果在 Windows 上面显示如下 : 
SizeOf: 4   
Length: 3   
StringElementSize: 2   
StringRefCount: 1   
StringCodePage: 1200   
Is Unicode   
Size in bytes: 6   
ByteLength: 6   
 
在Android上执行的结果如下 : 
SizeOf: 4   
Length: 3   
StringElementSize: 2   
StringRefCount: 1   
StringCodePage: 1200   
Is Unicode   
Size in bytes: 6   
ByteLength: 6   
 
Code page 回传值是 Unicode字符串，所以是 1200，这个数字会存在一个名
为DefaultUnicodeCodePage 的全局变量里面。在上面的程序代码中 (以及执
行结果 )，我们可以很清楚的留意到两个字符串变量尺寸的不同 (并不都是
4)，字符串长度跟实际使用的长度是不同的。这个结果可以用每个字符的长
度(占用多少位 )乘上整个字符串的长度得出， 或者直接呼叫 ByteLength 函式
也可以。 ByteLength 这个函式在旧版的桌面应用程序编译程序里面并不支
持。  
 筆記   
 195   观察在内存里面的字符串  
仔细观察字符串的 metadata 对于了解字符串的内存管理是很有帮助的，尤
其是观察参考计数的变化。为了这个要求，我在 StringMetaTest 范例项目里
面加了一些其他的程序代码。  
这个程序有两个全 局字符串： MyStr1跟MyStr2。程序代码仍使用动态方式
为前面提到这两个变量产生出字符串内容 (原因在稍早的 ”笔记”中已说明
过)，然后把第二个变量指派给第一个：  
MyStr1 := string.Create(['H', 'e', 'l', 'l', 'o']);   
MyStr2 := MyStr1;   
 
除了处理字符串之外，这个程序也显示字符串的内部状态，透过以下的
StringStatus 函式 : 
function StringStatus (const Str: string): string;   
begin  
   Result := 'Addr: ' +  
       IntToStr (Integer (Str)) +   
       ', Len: ' +   
      IntToStr (Length (Str)) +   
      ', Ref: ' +  
      IntToStr (PInteger (Integer (Str) - 8)^) +   
      ', V al: ' + Str;   
end;   
 
StringStatus 这个函式中很重要的一点，是它的参数是使用 const描述来传递
字符串的。如果我们不使用 const来描述参数的话，作为参数的字符串会被
复制一份、产生一些额外的副作用，例如每次把字符串传递给这个函式，参
考计数就会被加一。比较一下，以 var跟const传递字符串参数，则不会让
字符串的参考计数有变动。在这个范例中我已经使用了 const参数，在这个
函式里并不会更动到字符串的内容。  
 
要取得字符串的内存地址 (对于搞清楚这个字符串到底是哪一份很有用，而
且可以知道什么时候两个不同的字符串变量居然是指向同一个内存区块
的)，我也把字符串型别做了一个强制型别转换，转成整数型别。字符串 型
别是以参考计数方式来实作的，字符串变量实际上是指针：实际内容是记录
在字符串变量所指向的内存空间里面，而不是直接存在字符串变量中。以下
的程序代码用来测试字符串变量的内部变化 : 
Show ('MyStr1 - ' + StringStatus (MyStr1));    
 196 Show ('MyStr2 - ' + StringStatus (MyStr2));   
MyStr1 [1] := 'a';   
Show ('Change 2nd char');   
Show ('MyStr1 - ' + StringStatu s (MyStr1));   
Show ('MyStr2 - ' + StringStatus (MyStr2));   
一开始，我们需要让两个字符串拥有同样的内容，同样的内存空间，我们可
以看到计数参考的内容是 2。 
MyStr1 - Addr: 51837036, Len: 5, Ref: 2, V al: Hello   
MyStr2 - Addr: 51837036, Len: 5, Ref: 2, V al: Hello   
 
接着程序改变了其中一个字符串的内容 (改哪一个都没关系 )，内容被更改的
那个字符串变量所指 向的内存位置就改变了。这就是 ”写入时才复制 ”的效
果，这是第二部分的输出结果 : 
Change 2nd char   
MyStr1 - Addr: 51848300, Len: 5, Ref: 1, V al: Hallo   
MyStr2 - Addr: 51837036, Len: 5, Ref: 1, V al: Hello   
 
您可以自由修改这个范例，并使用 StringStatus 这个函式来观察字符串的内
容，并可以针对许多种不同情形下的长字符串处理方式来观察，例如对同一
个字符串进行多重参考，当字符串被当成参数传 递时、指派到局部变量的时
候，这些情形都很值得留意。  
 
字符串与编码  
我们已经看过，在 Object Pascal 里面，字符串型别是对应到 UTF16的格式，
每个元素以 2个Byte显示，并以代理对应 (surrogate pair) 来管理在基础多语
系平面 (Basic Multilingual Plan, BMP) 之外的字码。然而在许多情形中，当我
们需要存盘、读档、透过 socket联机传送，或者从网络联机接收以不同表示
法(例如 ANSI或UTF8)传送的文字数据时。  
 
要在不同编码的 文件跟内存空间里面进行格式转换 (或者编码转换 )时，
Object Pascal RTL ( 运行时间函式库 )提供了一个好用的类别 Tencoding 以及
一些衍生类别，这些类别都定义在 System.SysUtils 单元里面。  
_________________________________________________________________________  
在Object Pascal RTL 里面还提供了一些其他好用的类别，让我们可以用来
读写多种编码的文字数据。例如 TStreamReader 跟TStreamWriter 类别就可
以读写各 种不同编码的文字数据，这些类别我们会在第 18章里面介绍。  
 筆記   
 197 虽然我们还没介绍过类别跟继承，但这一系列的编码类别很简单，在全局对
象中也已经为每一种编码都提供了对象， 会自动帮我们建立起来。 换句话说，
每个编码类别的对象都已经可以透过 TEncoding 类别来取用， 就好像是类别
的属性一样：  
 
type  
  TEncoding = class   
   ...  
  public   
    class property ASCII: TEncoding read GetASCII;   
    class propert y BigEndianUnicode: TEncoding read GetBigEndianUnicode;   
    class property Default: TEncoding read GetDefault;   
    class property Unicode: TEncoding read GetUnicode;   
    class property UTF7: TEncoding read GetUTF7;   
    class property UTF8: TEncoding re ad GetUTF8;   
_________________________________________________________________________  
Unicode的编码是基于 TUnicodeEncoding 类别， 这个类别也使用 UTF -16 LE 
(Little Endian) 这个格式 (字 符 串 型 别 也 是 使 用 同 样 格 式 )。而
BigEndianUnicode 则用了比较少被使用到的 Big Endian 表示法。如果您对
两种 Endian表示法 (这是用来表示数字数据以位排列时的顺序 )不熟悉的话，
在此赘述一次： Little Endian 是把最高位放最前面， 也就是俗称的 MSB(Most 
Significate Byte) 放最前面，而 Big Endian 则是把最高位放最后，也就是把
MSB放最后面。更多的细节，建议您可以参考 en.wikipedia.org/ 
wiki/Endianness  
 
在目前这个章节要仔细观察这些类别还有点太难，我们先来看一些实际案
例。 Tencoding 类别提供了一些方法可以从位数组来读写 Unicode字符串，
会自动进行适当的编码 /译码处理。  
 
接下来我们用 TEncoding 系列类别 来示范 UTF格式转换，但保持范例程序
代码简单、不让焦点被转移到文件系统去。在 EncodingsTest 范例项目我在
内存里面用一些特定的数据建立了一个 UTF -8的字符串，然后透过呼叫一
个函式来把它转换成 UTF -16： 
var 
   Utf8string: TBytes;  
   Utf16string: string;  
begin  
   // process Utf8data   筆記   
 198    SetLength (Utf8string, 3);   
   Utf8string[0] := Ord ('a'); // s ingle byte ANSI char < 128   
   Utf8string[1] := $c9; // double byte, reversed latin a   
   Utf8string[2] := $90;   
   
   Utf16string := TEncoding.UTF8.GetString(Utf8string);   
   Show ('Unicode: ' + Utf16string);   
输出结果会是 : 
Unicode:  aɐ  
 
为了对不同表示法的转换有更深入的了解，我加入了 这些程序代码 : 
Show ('Utf8 bytes:');   
for AByte in Utf8String do   
   Show (AByte.ToString);   
 
Show ('Utf16 bytes:');   
UniBytes := TEncoding.Unicode.GetBytes (Utf16string);   
for AByte in UniBytes do   
   Show (AByte.ToString);  
 
这段程序代码把内存做了倾印，以十进制表示法印出，把两种格式的字符串
都倾印了 ，UTF8(以1个或 2个Byte来表示一个字码 )以及 UTF -16(所有字
码都是 2 bytes):  
Utf8 bytes:  
 97 
 201 
 144 
Utf16 bytes:  
 97 
 0 
 80 
 2  
 
请注意，在 UTF -8表示法中，字符直接转成 byte的作法，只能对 ANSI -7
的字符有用， ANSI -7的字符最大值只到 127。对更大的 ANSI字符就没有所
谓的直接对应了，我们必须要做适当的字符编码转换 (这样的转换在多位的
UTF -8元素进行时也可能出错 )。所以以下的程序就跑出了错误的结果 : 
// error : cannot use char > 128    
 199 Utf8string[0] := Ord ('à');   
Utf16string := TEncoding.UTF8.GetString(Utf8string);   
Show ('Wrong high ANSI: ' + Utf16string);   
// try different conversion   
Utf16string := TEncoding.ANSI.GetString(Utf8string);   
Show ('Wrong double by te: ' + Utf16string);   
    
// output  
Wrong high ANSI:  
Wrong double byte: àÉ  
 
编码类别们让我们可以进行双向的编译码处理，所以我们接下来把 Unicode
转换为 UTF -8，然后做一些 UTF -8的字符串处理 (其中有些处理要很小心，
因为这个格式的长度是变动的 )，然后再转换回 UTF -16: 
var 
   Utf8string: TBytes;  
   Utf16string: string;  
   I: Integer;  
begin  
   Utf16string := 'This is my nice string with à and Æ ';   
   Show ('Initial: ' + Utf16string);   
 
   Utf8string := TEncoding.UTF8.GetBytes(Utf16string);   
   for I := 0 to High(Utf8string) do   
      if Utf8string[I] = Ord('i') then   
        Utf8string[I] := Ord( 'I');  
   Utf16string := TEncoding.UTF8.GetString(Utf8string);   
   Show ('Final: ' + Utf16string);   
 
输出结果如下 : 
Initial: This is my nice string with à and Æ   
Final: ThIs Is my nIce strIng wIth à and Æ   
 
 
其他的字符串型别  
因为字符串型别的内部单元格式并不能满足最常用且最大量被使用的字符
串编码方法， Object Pascal 桌面应用程序编译程序提供了许多种不同的字符 
 200 串型别。其中部分型别也可以被使用在行动版应用程序，但建议一定要先做
好适当的转码，或是使用 TBytes来处理 1 byte表示法的字符串。  
 
过去惯用 Object Pascal 的程序人员可能已经积累了许多前 Unicode时期的类
别的程序代码 (或者自己直接写程序来管理 UTF -8)，现在的程序语言几乎都
是直接完整支持 Unicode的。另外，有一些型别，像是 UTF8String ，在桌面
应用程序编译程序仍然还有支持，但也仅止于 RTL的部分支持了。再次重
申，我们可以用位数组来表示简单的数据型别、改写既存的程序代码来处理
这些字符串，但还是建议尽快移转到标准的 Unicode字符串型别吧。  
_________________________________________ ________________________________  
一直以来，对于 Object Pascal 行动版编译程序没有支持部分旧版当中的原
生型别，像是 AnsiString 跟UTF8String 都不断有很多讨论跟批评，平心而
论，几乎没有其他程序语言支持一种以上的原生字符串型别的。多种字符
串型别太过复杂，很难以驾驭，而且可能会有一些我们不想遇到的副作用
(像是自动型别转换的函式，会让程序的执行速度变慢 )，而且会花很多时间
来维护这些字符串管理跟处理的函式。  
 
  UCS4String 型别 
UCS4String 是一个有趣但很少被用到的字符串型别，所有版本的编译程序
都有支持它。这是直接以 UTF32表示字符串的型别，而且已经不是以
UTF32Char 字符数组来实作的，也不是用 4 bytes字符数组来实作的。之前
的篇幅中已经提过为什么这个型别会被保留下来， 是因为它可以直接对应到
所有 Unicode字符。 而明显的代价就是要花上近乎两倍的内存 (跟UTF -16字
符串相比， UTF -16又比 ANSI字符串的内存用量又多上一倍 )来储存相同内
容的字符串。  
 
即使这个数据型别在特定的情形下会被使用，但它不适用于一般的情况。且
这个型别没有支 持”写入时才复制 ”的功能， 也没有任何系统函式或程序是可
以直接拿来处理它的。  
_________________________________________________________________________  
UCS4String 型别可以保证 UTF32Char 与每一个 Unicode字码直接对应，但
不能保证每个 UTF32Char 的显示文字都是同一个图像。  
 
  旧版的 , 只能在桌面版编译程序用的字符串型别  
我们前面已经提过， 桌面版的 Object Pascal 编译程序对旧版的传统字符串型
别仍然提 供支持，这些字符串型别包含有 : 筆記  
筆記   
 201  ShortString 型别，对应到传统的 Pascal语言的字符串型别，这个型别的
长度限制在 255个字符，每个字符都是 ANSIChar 型别 (这个型别也
只能在桌面版编译程序使用 )。 
 ANSIString 型别， 对应可变长度的字符串， 这些字符串会是随机配置的，
支持参考计数，并且也支持 ”写入时才复制 ”的技术，字符串的长度几
乎没有限制 (可以存到 20亿个字符喔！ )当然，这个字符串的字符也
都是 ANSIChar 型别。  
 WideString 型别： 跟 2 byte的Unicode字符串很相似， 储存的 内容是 Char
型别，但跟标准的字符串型别不同的是， WideString 并不支持 ”写入
时才复制 ”的技术，所以在内存配置的效能上没有标准字符串型别来
的好。 对于为什么把这个型别加进 Object Pascal 好奇吗 ? 原因是要兼
容于微软的 COM架构。  
 UTF8String 型别：这个字符串型别奠基于可变字符长度的 UTF -8格式，
一如我们前面介绍的，在 RTL里面对于这个型别的支持已经不多。  
 RawByteString 型别：这是一个没有 code page 设定值的字符数组，  
这个型别也不会让系统进行任何字符的编码转换。 (所以逻辑上这是
重组了 TBytes结构， 但提供了一些数组没有提供的字符串处理方式 )。 
 字符串结构机制允许我们定义一个与特定 ISO Code page 相关的字符串
变量，但这是前 Unicode时期的遗产。  
 
最后再强调一次，以上这些字符串型别可以用在桌面版的编译程序，但建议
只在兼容旧版程序代码的时候使用。我们的目标是尽可能随时都使用
Unicode，TEncoding 以及其他现代字符串管理的技术。  
 
  
 202 第二部 : 用Object 
Pascal做OOP  
 
许 多 现代 程 序语 言 都支 持了 某 种程 度上 的 面向 对 象程 序 设 计
(Objec t-oriented programming, OOP) 的范例。这些语言当中大都会用到以下
三个核心概念中的其中一个：  
 
 类别，具备公开接口与私有数据结构的数据型别，实作出封装概念，
以类别制作出来的实体，通常称之为对象。  
 类别可以被延伸或继承，这是能够扩展数据型别功能，而不用动到
原来程序代码的能力。  
 多型或者延迟绑定，这是让单一接口可以参考到不同类别对象的能
力，并且仍然让对象能够以原来定义的方法运作。  
 
_____________________________________________________ ____________________  
其他程序语言，像是 IO, JavaScript, Lua 和Rebol使用了以原形为基础的面
向对象概念，这个概念类似于类别，但没有继承的功能，动态型别可以用
来实作出多型，但是是完全不同的作法。  
 
在不用懂得太多面向对象程序的情形下，我们仍然可以用 Object Pascal 来
撰写程序。当我们建立一个新的窗体、加入一个组件、处理一个事件的时
候， IDE几乎帮我们把该做的相关宣告跟程序代码都自动处理好了。但多
了解一点程序语言，以及它是怎么实作出一些功能的，会帮助我们更精确
的了解系统的运作，也让我们能完整掌握这个语言的强大功能。  
 
我们也可以在我们的程序中建立复杂的架构，甚至整个函式库，或者把组
件依照我们的需求做功能的延伸，再整合到 IDE里面来。  
 
本书的第二部分，是要聚焦在面向对象程序设计 (OOP)的核心技术。本书的
这个部分是要介绍 OOP的基础概念，以及 Object Pascal 是怎么实作出这些
概念的，并把它跟类似的 OOP程序语言做一些比较。  筆記   
 203 第二部的章节列表 : 
第七章 : 物件  
第八章 : 继承  
第九章 : 例外处理  
第十章 : 属性与事件  
第十一章 : 界面  
第十二章 : 操纵类别  
第十三章 : 对象与内存  
 
 
 
 
  
 204 07:物件 
 
即使我们对 OOP的了解不深，这一章会介绍每一个关键概念。如果您对
OOP已经能够熟极而流，您也可以从本章的介绍中快速的聚焦在 Object 
Pascal是如何制作出这些您已经熟知的功能， 并和其他面向对象程序语言做
个对照或比较。  
 
Object Pascal 对OOP的支持跟 C#与Java有很多的相似之处，同时还加入
了一些 C++跟其他静态、强型别语言的特性。其他动态语言希望能够提供
一些不同的 OOP直译程序，一如它们在处理型别系统那样有弹性。  
____________ _____________________________________________________________  
C#跟Object Pascal 许多的概念极度相似，是因为这两个程序语言的设计者
是同一个人 : Anders Hejlsberg. 他是 Turbo Pascal 编译程序、第一版 Delphi 
Object Pascal 的原始作者，后来他转职到微软，设计了 C#(近期更设计了从
JavaScript 延伸而出的 TypeScript) 。您可以从附录 A当中到更多关于 Object 
Pascal语言的历 史。  
 
 
介绍类别 (Class) 与对象 (Object)   
类别 (Class)跟对象 (Object)这两个名词在 Object Pascal 跟其他 OOP程序语言
中都很常出现。然而也就是因为这两个名词太常被误用了，所以我们在一
开始，要非常清楚的把它们的定义给厘清，子曰：必也正名乎：  
 
 类别，是用户定义的数据型别。类别当中包含状态以及定义了一些
动作。用另外一个说法来描述，类别有一些内部数据，以及一些方
法，以程序或函式的形式呈现。类别通常描述一些类似对象的特征
跟行为，即使有些特别用途的类别所指的就是一个特别的对象。  
 对象则是类别的实体，例如是一个以特定类别作为数据型别而定义
的变量。对象是实际存在的个体，当程序执行时，对象会使用一些
内存空间来做内部储存之用。  
 
译者乱入：讲述程序设计这么多年，上面的说法总觉得学生很不容易理解，
所以我后来用另一个说法来说明，学生们就容易理解的多。类别，我们可
以想象成『人类』 ，人类有许多定义、特征。而对象就是一个个特定的人，筆記   
 205 例如读者你就是一个『人类』这个类别的实体，译者我也是，作者也是。  
类别与对象之间的关系，就跟任何一种数据型别跟变量之间的关系，只是
在这个案例中，变量有特别的名字 (类别名 )而已。  
 
Unicode的设计理念， 是要用单一一个字符集把世界上所有的文字都包含在
内，这样的作法把许多复杂的问题单纯化了，但要实现这个理想的过程却
极为复杂。在 Unicode 的设计中，是要以同一个叙述方式，同时包含图形
化的表示方法，以及独特的数值 (称之为 Unicode的字码 )。 
_________________________________________________________________________  
OOP的这些术语是从早期的一些开始实作 OOP概念的程序语言而来的， 例
如Smallta lk。然而最原始的术语后来在演进的过程中被慢慢以程序化语言
的术语给取代掉。所以像是类别、对象这些名词虽然还是很常用，我们也
很常听到像呼叫某个方法，不像以往会用传递一个讯息给接收者 (当然也是
个对象 )这种说法。完整的把 OOP的术语列出来，并看一下它的演进是很
有趣的，可惜本书的篇幅不够。  
 
  定义一个类别   
在Object Pascal 里面， 我们可以用以下的语法来定义一个新的类别数据型别
(TDate)，来定义一些内部数据字段 (Month, Day, Year) 跟一些方法 (SetValue, 
LeapYear) ： 
type  
    TDate = class  
       Month, Day, Y ear: Integer;   
       procedure SetV alue (m, d, y: Integer);   
       function LeapY ear: Boolean;   
    end;   
_________________________________________________________________________  
我们已经以记录来介绍过很类似的结构，记录在定义上跟类别非常 相似。
但在内存管理和其他领域则很不相同，在本章稍后的篇幅会进行介绍。但
在历史意义上， Object Pascal 的这个语法是首先为类别制作，稍后才为记录
移植回来的。  
 
在Object Pascal 里面， 对类别的约定是使用 T这个字母作为所有类别的第一
个字母，像是定义任何其他型别 (事实上， T是当做 Type这个字的缩写 )。这
个约定，对编译程序来说， T跟其他字母都一样，但只是让我们的程序代码
能够更容易被其他程序人员了解而已。  
 筆記  
筆記   
 206 跟其他程序语言不同，在 Object Pascal 定义类别时，并不会同时把实作的程
序代码写在 一起。只会包含类别的定义 (或者说是宣告 )，这使得类别的程序
代码更为精简，也更容易了解。  
_________________________________________________________________________  
我们已经以记录来介绍过很类似的结构，记录在定义上跟类别非常相似。
但在内存管理和其他领域则很不相同，在本章稍后的篇幅会进行介绍。但
在历史意义上， Object Pascal 的这个语法是首先为类别制作，稍后才为记录
移植回来的。  
 
也请记得除了撰写类别的定义 (包含字段与方法 )，我们还可以只写个宣告，
也就是只写类别的名称 : 
type  
    TMyDate = class;  
 
这种宣告的用意， 是万一我们写了两个类别， 而这两个类别之间相互使用时，
其中之一就需要先进行预先宣告。因为在 Object Pascal 里面，我们不能使用
还没定义的代号，所以要参考到还没定义的类别时，就需要先进行宣告。以
下的程序片段只是要介绍语法，它并没有任何实质作用喔：  
type  
   THusband = class;  
   TWife = class  
      husband: THusband;  
   end;  
   THusband = class  
      wife: TWife;  
   end;   
 
在实际的程序代码中，我们得自己处理类似的相互参考情形，因此这个语法
很重要，请牢记。另外，请记得就像宣告方法一样，在单元文件里面宣告的
类别，必须在同一个单元 文件里面完整的定义宣告的所有方法。  
 
  在其他 OOP语言的类别  
做个比较，我们用 C#跟Java写一个完全相同的  TDate类别 (在这么简单的
情形下也可能完全相同 )使用一个更适合的命名规则以及对应的方法程序代
码: 
// C# and Java langu age  
class Date   筆記   
 207 {  
   int   month;  
   int   day;  
   int   year;  
 
   void setV alue (int m, int d, int y)  
   {  
     // code  
   }  
   bool leapY ear()  
   { 
     // code   
   }  
}  
 
在Java跟C#里面， 方法的程序代码会随着类别的定义一起写好， 而在 Object 
Pascal里面则是把类别的宣告跟实作部分分开来撰写的，但必须在同一个单
元文件里面完成。换句话说，在 Object Pascal 里面，类别永远要在单一一个
单元文件里面完成定义 (当然，一个单元文件里面可以定义很多个类别 )。相
对的， C++的方法也是分开来撰写的，跟 Object Pascal 有一点点类似，但
C++包含类别定义的头文件案，则不用非跟宣告了方法的程序代码放在一
起。对应的 C++类别看起来会是这个样子：  
// C++ language   
class Date {   
       int   month;  
       int   day;  
       int   year;  
 
     void setV alue (int m, int d, int y);   
       BOOL leapY ear();  
     } 
 
  类别方法  
跟记录类似，当我们定义好方法的时候，我们必须判别该方法是属于哪个类
别的一部分 (在这个范例中，是 TDate类别 )，在使用这个方法时，可以先输
入该类别的名称， 加上句点， 就可以加以呼叫， 用以下的程序代码作为范例：  
  
 208 procedure TDate.SetV alue(m, d, y: Integer);   
begin   
    Month := m;  
    Day := d;  
    Y ear := y;  
end;   
 
function TDate.LeapY ear: Boolean;  
begin  
    // call IsLeapYear in SysUtils.pas   
    Result := IsLeapY ear (Y ear);   
end;   
 
大多数其他的 OOP语言把方法定义成函式， Object Pascal 不同的是可以让
方法定义成函式或者程序，只取决在是否需要回传值。这跟 C++的情况就不
同了， C++把方法定义跟实作分开 : 
// C++ me thod  
void Date::setV alue(int m, int d, int y) {   
       month = m;  
       day = d;  
       year = y;  
};  
 
  建立对象  
在跟其他热门的程序语言比较过后， 我们回头来看 Object Pascal 当中要如何
使用类别。一旦类别定义好了，我们就可以以这个类别作为数据型别来建立
对象，就像以下的范例 (是从 Dates1范例项目中取出的程序代码 ): 
var 
   ADay: TDate;  
begin  
 // create  ADay := TDate.Create;  
 // use  
 ADay.SetV alue (1, 1, 2016);  
 if ADay.LeapY ear then   
   Show ('Leap year: ' + IntToStr (ADay.Y ear));   
 
表示法没有任何不寻常，但非常有力。我们可以写很复杂的函式 (像是 
 209 LeapYear) ，然后透过每个 TDate的对象来存取它的内容，一如它是个直觉
的数据型别。请注意， ADay.LeapYear 跟ADay.Year 一样是对象可以存取的
属性，然而前者是个 函式，后者是直接存取数据。等我们进行到第十章的时
候， Object Pascal 用来存取属性的表示法时，存取属性的方法也一样。  
_________________________________________________________________________  
在C阵营的程序语言中，要呼叫不用参数的函式时，无论如何都还是得加
上小括号，以上面的例子来看，就得写成 ADay.LeapYear() 。这样的写法在
Object Pascal 也是合法的，但很少人使用这个写法。在 Object Pascal 里面呼
叫不需要参数的函式时，通常是习惯不加小括号的。这也跟许多呼叫无需
参数的方法时，会直接回传该函式地址的程序语言非常不同。我们曾经在
第四章的 ”程序型别 ”当中介绍过， Object Pascal 在呼叫程序跟函式时是使用
相同的呼叫方法，取决于该判断式的语意内涵。  
 
这段程序代码的结果非常直觉：  
Leap year: 2016  
 
我们再来比较一下 Object Pascal 跟其他程序语言在对象的建立写法 : 
// C# and Java languages (object reference model)   
Date a Day = new Date();   
// C++ language (two alternative styles)   
Date aDay; // local allocation   
Date* aDay = new Date(); // "manual" reference   
 
对象参考模型 (Object Reference Model)  
在一些 OOP语言，像 C++，宣告一个类别型别的变量时就会自动出建立一
个该类别的实体 (多多少少有点像在 Object Pascal 里面的记录 )。局部变量的
对象所使用的内存 会从 Stack配置而来，然后当该函式结束时就会把这些内
存释放掉。在大多数情形下，我们必须使用指针跟参考让管理对象生命周期
的作业更有弹性，但也增加了额外的复杂度。  
 
相反地， Object Pascal 语言是以对象参考模型为基础，完全像 Java或C#。
这个概念是说，每个类别型别的变量并不直接储存对象的数据 (例如以上例
来说，不直接储存 day, month, year) 。而是只储存一个内存参考，或者说指
针，来指向一个真正用来储存对象数据的内存地址。  
________________________________ _________________________________________  
从我的观点来看，使用对象参考模型是早期 Object Pascal 编译程序团队所
做的最好的决定之一，在当时这种模型在程序语言当中已经不常被使用 (事筆記  
筆記   
 210 实上，当时 Java还没完全发展出来，且 C#也还不存在 )。 
 
这也是为什么在这些程序语言中，我们需要额外建立一个对象，然后把它指
派给一个变量，因为对象并不会自动被进行初始化。换句话说，当我们宣告
一个变量，我们并没有在内存里面建立一个对象，而只是预留了一个内存空
间来储存对象的参考地址而已 。对象实体必须由我们撰写的程序来建立，至
少由我们自己定义的类别必须如此。 (在Object Pascal 里面，我们从元键盘
拖拉到窗体上面的各个组件的实体，就是由 RTL自动建立出来的 ) 
 
在Object Pascal 当中，要建立一个对象的实体，我们必须呼叫该类别的特殊
函式 :Create，这个函式是一个建构函式，或者由类别自行定义的建构函式，
写法像是这样 : 
ADay := TDate.Create;  
 
如我们所见，建构函式是由类别 (也就是一个型别 )，而不是由对象 (变量 )来
呼叫的。这是因为我们是要求类别建议一个新的 实体，而结果会是一个新的
实体，我们就可以把这个实体指派给一个变量了。  
 
Create这个方法是从何而来呢 ? 它是 TObject这个类别的建构函式，这个类
别是 Object Pascal 所有对象的起源对象， 所以在 Object Pascal 里面的所有类
别全都依循相同规则。为我们定义的类别建立自行定义的建构函式也很常
见，容我们在本章稍后再进行介绍。  
 
  释放对象与自动参考计数 (ARC)  
在使用对象参考模型的语言中，我们在使用对象前，必须先建立它，然后在
我们不再需要使用该对象的时候， 也要负责把该对象使用的所有内存空 间释
放掉。如果我们没有释放这些内存空间，这些残留在内存里面的空间将不会
有机会被其他变量使用到，就会造成名为内存泄漏 (memory leak) 的问题。为
了解决这个问题，有些语言，像是 C#跟Java，就建立了虚拟执行环境 (或称
虚拟机 )，让整个环境进行垃圾收集机制 (garbage collection) 。这个机制让开
发人员的生活过的轻松了些，但这个功能要达到的要求是很复杂的，会牵涉
到执行效能的问题，这又跟 Object Pascal 的关系不大了，所以我没办法在这
里扯太多。  
 
在Object Pascal 里面，我们通 常呼叫对象里面一个特殊的方法，名为 Free，
来释放该对象所使用的内存空间 (再强调一下，由于这是 TObject 的方法之
一，所以任何一个类别都能使用 )。Free会在呼叫过该类别的解构函式 (这里 
 211 面可能有很特别的清除程序代码 )之后，释放掉该对象所占用的内存空间，
所以我们可以把上例当中的对象这样释放掉：  
var 
   ADay: TDate;  
begin  
    // create  
    ADay := TDate.Create;  
    // use  
    ... 
    // free the memory  
    ADay.Free;  
end;   
 
虽然这是标准的作法，但组件函式库在其中加入了类似对象归属的概念，以
减少手动管理内存的冲击，让处理相关议题来说相对简单。  
 
为了要更深入的简化内存管理的议题， 行动版的 Object Pascal 编译程序提供
了一个额外的机制，称为自动化参考计数。 (Automatic Reference Counting ，
简称 ARC) ARC 模型使用了参考计数，以及其他进阶的技术来自动释放不
再被使用到的对象 (或者说没有任何参考指针指向的内存空间 )。因此在其他
平台上，呼叫一个对象的 Free方法通常是多余的：当上面的程序代码执行
到end的时候， ADay变量就离开了其范围，此时被参考的对象就会被自动
释放。在任何情形中，如果我们把呼叫 Free的叙述句留在程序当中，并不
会造成任何问题， 所有工作都能够在桌面版与行动版应用程序当中顺畅的运
作下去。  
_________________________________________________________________________  
自动参考计数 (ARC)是iOS以ObjectiveC 跟Swift进行开发时所使用的标准
内存管理 (译者 :Appl e从XCode 4.0, iOS 6.0 开始推这个技术， 历经两年多才
真正堪用 )。Object Pascal 从这个模型中取经， 包含了 weak参考跟其他元素，
但在一些功能上进行了功能加强跟更有效率的实作。  
 
在内存管理跟 ARC这个主题上我们应该要更深入了解，但这是一个重要的
课题，且并不简单，所以我决定在此提供一个简短的介绍，并且在第 13章
进行深入的探讨。在该章中，我会让各位看到在不同平台上所使用的这些不
同技术的细节，以及他们是如何在所有平台上都能正常运作的。  
 
 筆記   
 212   什么是 Nil 
我们已经提过，变量可以指向特定 类别所建立的对象，但变量并不能自己为
对象做初始化，也不能把使用到的对象转成不再使用的状态。这时我们就可
以使用 nil了。这是一个特殊的常数值，用来表示变量已经不再指派给任何
对象了 (或者它已经指派到内存地址 0了)。当一个类别型别的变量没有值的
时候，我们可以用这个方式帮它做初始化 : 
ADay := nil;  
 
要确认一个对象是否已经指派给该变量，我们可以用以下任一种写法：  
if ADay <> nil then ...   
if Assigned (ADay) then ...   
 
不要犯下想透过把 nil指派给对象 来释放内存的错。把一个对象设定为 nil
跟把它释放掉是两个完全不同的作业，至少在桌面应用程序是如此 (ARC的
机制使得事情有些不同了，在行动版程序中，把 nil指派一个对象变量，就
能够把该对象给释放掉 )。所以我们通常既需要呼叫 free，也必须把该对象
的变量指向 nil或者呼叫一个特殊功能的程序以同时满足两种需求，这个程
序就是 FreeAndNil 。再预告一下，第 13章里面就会有更多相关信息，以及
实际的范例程序了。  
 
  在内存里面的记录与类别  
一如我们前面所提，记录跟对象的主要不同，在于他们的内存模型。记录型
别变量使 用区域内存，它们被当成参数传递的时候，默认是用传值模式，也
就是说被当成参数传递的变量， 其内容会被复制一份之后， 传递给函式使用。
这跟类别型别变量的配置是从易失存储器 heap而来， 以及会自动以传址 (call 
by reference) 方式传递，并且在复制时还有 ”以参考复制 ”的特性恰好成为对
比(会把该对象的指针复制一份，而不会实际上复制对象内容 )。 
_________________________________________________________________________  
在内存管理上的不 同，是记录型别缺少了继承跟多型的机制，这两个功能
我们会在下一章当中介绍到。  
 
举例来说，当我们在堆栈中宣告了一个记录型别的变量，我们在宣告完之后
就可以立刻开始使用它了，不用呼叫它的建构函式。这表示记录型别变量在
内存管理上是比正规的对象更要来的精简 (而且比较有效率 )，同时记录型别
的变量不需要进行随机内存管理或 ARC。这也是在处理简单、单纯数据结
构时，为何要建议使用记录型别，而不使用对象的关键之处。  筆記   
 213 另一个记录跟类别不同的地方是在当它们被作为参数传递的时候， 比较看看
把记录所使用的所有内存做一份完整的复制，跟把对 象参考复制一份 (数据
没有复制 )。 当然我们也可以透过 var跟 const的参数来修改传递参数时的规
则。  
 
私有、保护、公开  
一个类别可能拥有任何数量的数据字段跟任何数量的方法。然而，以好的面
向对象设计内涵来说，数据应该被隐藏起来，或者说是『封装』在对象内部。
例如当我们试着存取一个日期，直接改变当中的『日』内容是不对的。事实
上，直接改变『日』这个字段可能导致整个日期变得不合逻辑，例如用户可
能改出一个二月三十日这种不存在的日子。透过使用对象的方法，对象内部
的表示法跟规则就可以尽量排除这种风险，例如透过对象的方法来 设定日
期，就可以判断使用者设定的日期有所错误，进而从对象本身直接拒绝新的
错误日期被设定。适当的封装是相当重要的，因为它赋予了类别设计者在未
来的版本中变更内部表示方法的权限。  
 
其实封装的概念相当简单：就把类别想象成一个『黑盒子』 ，只露出一小部
分可以看到里面。可以看到的部份，我们称之为 类别的接口 ，这个部分允许
其他程序代码透过属于这个类别的对象来存取、 使用这个类别的功能。 然而，
当我们使用这个对象的时候，大多数的程序代码是被隐藏的。我们很少会知
道一个对象当中有哪些内部数据，我们也无法直接存取这些数据，我们只能
透过对象的方法来存取这些数据或使用它的方法。  
 
封装使用了私有跟保护区的成员， 这是面向对象解决方案提供给传统程序设
计方法的目标，被称之为信息隐藏。  
 
Object Pascal 有三种不同的基本存取分区描述关键词， 分别是 :private (私有 )、
protected ( 保护 )，以及 public(公开 )。第四个特别的分区关键词则是
published( 已发布 )，这个我们在第十章里面讨论。以下是三个基本分区的特
性，我们来仔细看一下 : 
 
 Private存取分区关键词，在这一区里面的所有字段、方法，都无法被其
他单元文件的程 序所使用。  
 Public存取分区关键词，在这一区里面的所有字段，可以被整个程序的
任何一部分存取，不限于在哪个单元文件里面。  
 Protected 存取分区关键词，在这一区里面的字段，有部分存取的限制。
只有该类别的对象， 以及从这个类别衍生的子类别可以存取这一区的字 
 214 段，我们会在下一章的『保护区的字段以及封装』里面仔细讨论。  
 
_________________________________________________________________________  
有两个延伸的存区分区关键词： strict private跟strict protected 已经被新增到
Object Pascal 里面，以符合其他 OOP程序语言的规则。我们只做简单的讨
论。在这边没有列出，是因为这两个分区关键词极少使用到。  
 
一般来说， 类别的数据字段应该归属于私有区， 而方法则通常归属在公开区。
然而，这并不是永远的规则。方法也可以放在私有区或保护区，如果这些方
法只提供给类别内部使用时。数据字段可能放在保护区，如果我们很确定这
些字段的定义未来不会更改， 而我们未来在次类别当中可能有需要直接存取
这些字段的话 (我们在下一章里面说明 )，不过这只是 建议，请大家还是依照
自己对类别的需求进行设计。  
 
以一般的情形来说，我们应该不去直接把数据放在公开区，在公开区应该透
过属性来提供对数据字段的存取，我们也会在第十章里面一起介绍。 属性  
，是其他 OOP程序语言当中用来提供数据封装机制的延伸，也是 Object 
Pascal里面非常重要的机制。  
 
如前文所述， 存取分区关键词只用来限制其他单元文件的程序代码存取该类
别在这个单元当中所宣告跟实作的类别成员。 这表示如果两个类别在同一个
单元文件里面，在类别当中私有区宣告的数据字段就没有任何保护的作用，
这个特性我们将在下一节里 面详述。  
 
  私有区数据字段的范例  
我们可以用个例子来示范透过分区存取关键词如何实现数据封装的理念， 以
此实作一个 TDate类别的新版本：  
type  
  TDate = class  
  private  
      Month, Day, Year: Integer;  
  public  
      procedure SetV alue (m, d, y: Integer);   
      function LeapY ear: Boolean;   
      function GetText: string;  procedure Increase;   
  end;   
 筆記   
 215 在这个版本中，数据字段现在被宣告在私有区内，并提供了其他方法。第一
个方法是 GetText，这个方法是个会以字符串形式回传日期的函式。我们未
来也可以加入其他方法，像是 GetDay，GetMonth ，GetYear可以用来回传各
个在私有区的日期字段，只是类似的直接存取数据的函式并不会永远需要。
提供可以直接存取每个字段的函式是可以简化封装的过程， 但也使抽象化的
概念被弱化了，同时也让未来要修改该类别的内部实作方式更为困难。  
 
对数据字段存取数据的函式只宜在 该类别有实际需要提供特定字段给其他
程序代码存取时才提供，并不必凡数据字段必有存取函式。  
 
第二个新增的方法是 Increase程序，这个程序会在呼叫时为日期内容向后推
一天。这并不像所描述的这么好做，因为我们得考虑每个月有不同的天数、
以及该年是否为闰年。我们为了要让程序代码变得比较容易写而作的，是使
用用 Object Pascal 的TDateTime 型别作为这个类别内部实作的方法。 所以实
际上我们在 Dates2项目类别里面所看到的类别程序代码会长的像这样：  
type  
   TDate = class  
   priv ate 
       FDate: TDateTime;  
   public  
       procedure SetV alue (m, d, y: Integer);   
       function LeapY ear: Boolean;   
       function GetText: string;   
       procedure Increase;   
   end;   
 
请留意，这里的修改只有类别的私有区，我们不用因此修改任何使用到这个
类别对象的程序代码，这也是信息封装设计的好处之一。  
_________________________________________________________________________  
在这个类别的新版本中，唯一的数据字段的名称第一个字符是以 F开始的。
这是在 Object Pascal 语言里面的不成文规定，我也会在本书中沿用下去。
除了这个官方的格式之外，还有另一个常用的格式，第一个字符会用小写
的f开头。  
 
在这一节的结尾，我们把这个范例项目完成，我们把该类别所有方法的原始
码都列出来，其中会使用一些系统函式来做日期跟内部结构的相互对照：  
procedu re TDate.SetV alue (m, d, y: Integer);   
begin   筆記   
 216    fDate := EncodeDate (y, m, d);   
end;   
 
function TDate.GetText: string;  
begin  
   Result := DateToStr (fDate);  
end;  
 
procedure TDate.Increase;  
begin  
   fDate := fDate + 1;  
end;  
        
function TDate.LeapY ear:  Boolean;  
begin  
   // call IsLeapY ear in SysUtils and Y earOf in DateUtils   
   Result := IsLeapY ear (Y earOf (fDate));   
end;   
 
也请注意到这个函式码是怎么使用这个类别的，它已经不再使用 Year的资
料内容，但可以从日期对象的回传信息中撷取出该项信息：  
var 
   ADay: TDate;   
begin  
   // create  
   ADay := TDate.Create;  
    
   // use  
   ADay.SetV alue (1, 1, 2016);  
   ADay.Increase;  
 
   if ADay.LeapY ear then  
    Show ('Leap year: ' + ADay.GetText);   
 
   // free the memory (for non ARC platforms)   
   ADay.Free;   
 
输出数据跟原来的不同：   
 217 Leap year: 1/2/2016   
 
  当私有区并不是真的私有  
我已经提过，跟其他大多数的 OOP程序语言不同的是， Object Pascal 类别
的分区叙述关键词，例如 private跟protected 只限制了不同单元文件的程序
代码对类别成员的使用。换句话说，任何一个全局的函式或者任何一个跟类
别写在同一个单元文件里面的方法、函式都可以直接存取在同一单 元文件
中， 任何一个类别的私有区的数据。 为了克服这种不正常的现象 (跟其他 OOP
程序语言比较，同时也跟封装概念比较 )，Object Pascal 里面也提出了 strict 
private跟strict protected 这两个特别的分区叙述关键词。  
 
这两个分区叙述关键词就跟其他 OOP语言里面，我们对它们的期望一样，
也表示即使是在相同单元文件里面，不属于该类别的函式或类别，也无法存
取位于 strict private 或strict protected 分区的数据， strict protected 分区的数
据跟方法，只有 次类别才能使用了。  
 
即使现在提供了这两个以 strict开头的分区叙述关键词，他们对封装技术的
实作比较精确，也比较安全，但大多数 Object Pascal 的开发人员还是倾向于
使用传统的，比较没那么精确的版本，而直接把这两个关键词忽略掉了。  
_________________________________________________________________________  
C++语言里面还有个称为 friend类别的概念， 这个类别可以存取其他类别的
私有区。依照这个概念来说，我们可以说在 Objec t Pascal里面，位于同一
单元文件里面的所有类别都是 friend类别。  
 
  封装与窗体  
封装技术的主要要求之一，是减少程序里面使用全局变量的数量。全局变量
可以在一个程序的任何地方加以存取。为了这个原因，全局变量的改变会影
响到整个程序。另一方面，当我们改变了类别中数据字段的设计，我们只需
要修改该类别有使用到该数据字段的部分程序代码，其他部分不用动。所以
我们可以说信息隐藏也引用了封装的改变。  
 
让我们用个实例来厘清这个概念。当我们写了一个多重窗体的程序时，我们
可能会为了让所有窗体可以存取同一份数据，而在全 局变量上宣告它：  
var 
   Form1: TForm1;  
   nClicks: Integer;  筆記   
 218 这样宣告可以正常运作，但有两个问题。第一，数据 (nClicks)并不是跟窗体
上的任何一个字段有所连结，而是跟整个程序链接。如果我们用同样的型别
制作了两个窗体，预期让两个窗体之间互相共享数据，这是可行的。如果我
们希望各个窗体都能有它自己的数据，唯一的方法是在窗体的类别中加入 : 
type  
   TForm1 = class(TForm) public   
      nClicks: Integer;  
   end;  
 
第二个问题则是， 如果我们把该数据定义成全局变量或者一个位于公开区的
字段，我们未来就不能在不影响使用到被修改字段相关程序代码的情形下，
对这个类别的内部进行重新设计了。例如，如果我们只需要从其他窗体读取
目前的数值， 我们可以把该数据字段设计成私有， 并且提供这样的读取方法：  
type  
  TForm1 = class(TForm)   
     // components and event handlers here  
  public  
     function GetClicks: Integer;  
  private  
     nClicks: Integer;  
end;  
 
function TForm1.GetClicks: Integer;   
begin   
    Result := nClicks;  
end;  
 
另一个比较好的解决方法， 是帮窗体加入一个属性， 我们在第十章再慢慢说。
我们现在可以先用 ClicksCount 范例项目来做些实验。简单的说，这个项目
的窗体上方有两个按钮、一个卷标，其他部分的窗体画面则留白让使用者可
以点击 (或触击 )。在这个案例中，计数值会增加，接着该数值会被显示在卷
标上：  
procedure TForm1.FormMouseDown(Sender: TObject; Button: TMouseButton;   
    Shift: TShiftState; X, Y: Single);   
begin  
   Inc (nClicks);   
   Label1.Text := nClicks.ToString;   
end;    
 219 在图 7.1里面可以看到应用程序执行的画面。项目的窗体也有两个按钮，一
个是用来建立一个相同型别的新窗体，第二个按钮则是关闭它 (所以我们就
可以把窗口焦点移回 前一个窗体上 )。这是为了强调每一个不同的实体被点
击时，可以有自己的点击计数数值。以下是这两个方法的程序代码 : 
procedure TForm1.Button1Click(Sender: TObject);   
var  
   NewForm: TForm1;  
begin  
   NewForm := TForm1.Create(Application);   
   NewForm.Show;  
end;  
 
procedure TForm1.Button2Click(Sender: TObject);   
begin   
   Close;   
end;   
_________________________________________________________________________  
 
 
 
 
 
 
  
 
 
 
 
 
 
 
Self关键词  
我们已经看过了很像程序跟函式的一些方法，实际的不同处，是方法会有一
些额外的、预设的参数。该参数是一个指向触发该方法的对象参考。在方法
之内，我们可以透过这个参数来存取正在执行中的对象，或使用 self这个关
键词。这个额外的参数是有需要的，尤其是当我们建立相同类别的多个对象
时。当我们 每次使用该对象的任何一个方法时，这个方法就只会用它自己的圖7.1: 
ClicksCount
範例專案的 表
單，顯示該表
單實體被點擊
的次數 (記錄
在該表單的私
有區 ) 
 
 220 数据来运作，而不会影响到其他相同型别的对象。  
_________________________________________________________________________  
我们已经在第五章里面介绍过 Self这个关键词了，就在讨论记录的时候。
他们的概念跟实作方法非常相似。再提一次， Self是在提出类别的时候先
被提出的概念，后来才延伸为记录的，而当时方法则也已经加入了这个数
据结构当中。  
 
举例来说，在我们稍早提到的 TDate类别里面 的SetValue 方法，我们很简单
的直接用了 Month, Year, Day 来对应目前对象的字段，我们可以直接写出这
样的程序代码 : 
Self.Month := m;   
Self.Day := d;   
 
事实上这也是 Object Pascal 编译程序转换程序代码的方法， 我们不用自己写
出这些程序代码。 Self关键词是会由编译程序建立的程序核心基础，但有时
候程序人员也会自己写出来，可以让程序代码更容易被读懂，也比较不容易
发生同名成员之间的混淆或误解。  
______________________________ ___________________________________________  
C++, Java, C#, JavaScript 语言当中，也有相同功能的关键词，他们使用的是
this。然而 JavaScript 跟C++, C#, Java 不一样， JavaScript 在方法中使用这个
关键词来指定对象参考是必要条件。  
 
我们真的需要知道的是 Self是呼叫方法时的技术实作，跟呼叫一般子程序
是不一样的。方法会有 Self这个额外的隐藏参数存在。因为这一切都会在
不知不觉中就由编译程序处理好了， 我们不需要知道 self在这个情形下是怎
么作业的。  
 
第二重要的思路，是我们可以在整个程序代码当中，自己明确输入 self这个
关键词，来引用目前的对象，例如把目前的对象当成参数传给另一个函式。  
 
  动态建立组件  
在我们刚刚提过的例子里， self关键词在我们需要明确参考到目前这个窗体
或对象时是很常用到的。常见的例子，就是当我们在运行时间的时候需要动
态建立组件时， 因为建立组件的时候需要指定该组件的拥有者作为呼叫建立
组件建构函式 (Create)的参数， 并且把同一个值指派到新建组件实体的 Parent
属性。 在上述的两个情形中， 我们都需要提 供当前窗体的对象参考作为参数，
或者要被指派的数据，而完成这个作业最方便的方式就是使用 Self关键词筆記  
筆記   
 221 了。  
_________________________________________________________________________  
组件的所有权会关系到它的生命周期以及两个对象内存管理的关联性。当
一个组件的所有权者被释放掉了，该组件也会一起被释放掉。 Parent(父代
关系 )所指的，则是在视觉层级上，这个组件要被贴在哪个组件上头。  
 
为了进行这样的展示，我提供了 CreateComps 范例项目，这个应用程序只有
一个干干净净的窗体，以及处理 OnMouseDown 事件的处理程序，这个处理
程序也会把鼠标点击的坐标当成标准参数之一。 因为我们需要这个坐标来当
成新建立组件要放置的位置。以下是这个方法的程序代码 : 
procedure TForm1.FormMouseDown (Sender: TObject;   
     Button: TMouseButton; Shift: TShiftState; X, Y: Integer);   
var 
   Btn: TButton;  
begin  
   Btn := TButton.Create (Self);   
   Btn.Parent := Self;   
   Btn.Position.X := X;   
   Btn.Position.Y := Y;   
   Btn.Height := 35;   
   Btn.Width := 135;   
   Btn.Text := Format ('At %d, %d', [X, Y]);   
end;   
 
请注意，我们需要在 uses叙述句中，加入使用 FMX.StdCtrls 这个单元文件
的描述，这样编译才会过喔。  
 
这段程序代码的作用，是会在鼠标点击的地方建立一个新的按钮，并且把该
坐标当成按钮的卷标文字，就像图 7.2所示。在以上的成ˋ马当中，请特别
留意 self关键词的使用， 尤其在我们呼叫 Create方法跟指派 Parent属性的时
候。  
 
当撰写一个跟上述范例相似的程序时，您可能会很想用 Form1来取代上面
程序代码里面的 Self。在上述这个范例中，如果您这么写，并没有造成任何
实质的变化 (即使它并不算一个好的程序代码范例 )，但如果一个窗体会出现
多个实体的时候，使用 Form1来取代 self，就会出现很严重的错误喔。  
 
事实上，如果 Form1这个变量指向该窗体类别的一个实体 (通常会是第一个筆記   
 222 被建立的实体 )，而我们用相同窗体类别建立了第二个实体，那么，在点击
任何一个窗体的画面时，都只有第一个窗体的画面上会出现新增的按钮，因
为新建组件的 Parent是Form1，而不是被点击的窗体实体了。  
_________________________________________________________________________  
  
 
 
 
 
 
 
 
 
 
 
通常，当我们在撰写一个类别的程序代码，需要使用到当前对象参考时，如
果把它指向特定一 个实体的变量值时， 绝对是 OOP的一个很糟很糟的作法。  
 
建构函式  
在上述的程序代码中，要建立一种类别的对象 (您也可以想做要帮一个对象
配置内存空间 )时，我们会呼叫 Create方法。它是建构函式 (constructor) ，是
所有类别中一个预设的特别方法， 让我们可以用来为类别的一个新建实体配
置内存之用：  
ADay := TDate.Create;  
 
由建构函式回传的实体，我们可以把它指派给一个该类别为型别的变量，然
后后续用这个变量就能使用这个新建的实体了。  
 
当我们建立一个对象，它的内存已经完成了初始化，所有新对 象的数据字段
都该被设定为 0(或者 nil, 或者空字符串，或者该数据型别的适当默认值 )。 
 
如果我们想要让我们的新建实体在建立之时就储存特定数据， 那我们就需要
写一个自定的建构函式来这么做。新的建构函式可以名为 Create，或者它也
可以用任何一个名称。用来决定方法的角色的，并不是名称，而是特定的关
键词 : constructor 。 
_________________________________________________________________________  
换句话说， Object Pasca l支持可命名的建构函式，其他大多数的 OOP程序圖7.2: 
CreateComps
範例的執行畫
面 
筆記   
 223 语言的建构函式大多只能是该类别的名称。透过可命名的建构函式，我们
可以拥有多个建构函式，让这些建构函式的参数是一样的 (也可以直接对
Create进行多载  – 我们在下一节介绍多载 )。Object Pascal 另一个特殊的功
能， 也是在 OOP程序语言中很独特的， 是就够函式也可以是虚构的 (virtual)，
我们会在本书后面花一些篇幅来介绍一些范例。  
 
为一个类别建立自定建构函式的主要原因，是要进行数据的初始化，如果我
们建立了一个对象，但没有为它做初始化，稍后在呼叫它的方法 时，可能会
得到很奇怪的结果，或者甚至得到执行程序错误。与其等到这些错误显示，
我们应该用一些方法预先避免这种情形发生。这些方法的其中之一，就是持
续使用建构函式来对对象数据进行初始化。举例来说，我们在建立 TDate
类别的对象之后，得先呼叫 SetValue 方法来设定一个日期给它。或者我们也
可以提供一个自定的建构函式，在建立对象之时，同时就把预设日期给设定
好：  
constructor TDate.Create;  
begin  
   FDate := Today;  
end;  
 
constructor TDate.Cre ateFromV alues (m, d, y: Integer);   
begin   
   FDate := SetV alue (m, d, y);  
end;  
 
我们可以这样来使用这些建构函式， 这些程序代码我已经在 Date3范例项目
中写好了，在这个范例项目中，以下的程序代码是分别由两个按钮来加以触
发的：  
ADay1 := TDate.Create;   
ADay2 := TDate.CreateFromV alues (12, 25, 2015);   
 
即使我们通常可以使用任何一个名称来做为建构函式， 要记得如果我 们使用
的名称不是 Create，Create这个建构函式仍旧是有效的， 因为它是从 TObject
一路继承下来的。 所以如果我们正在开发要提供给其他程序人员使用的程序
代码，其他程序人员直接呼叫 Create建构函式时，就不会呼叫到你辛苦写
的建构函式了。我们也可以直接新增一个名为 Create带有完全相同参数的
建构函式，这样就能取代掉原来的建构函式，确保使用上不会有失误了。  
 
如同类别可以有自定的建构函式，类别也可以拥有自定的结构函式，以 
 224 destructor 为名宣告的方法，呼叫时直接呼叫 Destroy即可。这个解构函式可
以在对象被从内存毁灭之前， 先把使用过的资源清除掉， 但大多数的情形下，
并不需要自定的解构函式。  
 
就像建构函式会为一个对象配置内存，解构函式则是会释放内存。自定解构
函式只有在该类别的建构函式或者执行过程中要求了额外资源时才需要。  
 
跟预设的 Create建构函式不同，预设的 Destroy解构函式是虚拟的 (Virtual)，
而且强烈建议开发人员重载 (override) 这个虚拟的解构函式 (虚拟函式会在下
一章里面介绍 )。 
 
这是因为与其直接呼叫一个对象的解构函式，不如透过惯用的 Object Pascal
程序实务上的作 法，呼叫名为 Free的特殊 TObject类别方法，这个方法会自
动转为呼叫 Destroy函式，如果该对象有定义它的话，也就是说该对象的
Destroy如果不是 nil的话，所以，如果我们定义了一个解构函式使用的名称
不是 Destory的话，这个解构函式就不会被 Free呼叫了。再次重申，与此相
关的更多主题我们会在第十三章里面的内存管理来介绍。  
_________________________________________________________________________  
如下一章我们介绍的内容， Destroy是一个虚拟方法，我们可以在继承特定
类别，衍生新的次类别时取代原有的定义，透过 override 关键词。顺带一
提，使用静态方法 (static method) 来呼叫一个虚拟方法是很常见的程序风格，
称为模版模式 (template pattern) 。在解构函式中，我们通常只需要撰写清除
资源的程序代码。试着避免太复杂的处理，例如发出例外，或者花上可观
的时间。  
 
  以建构函式跟解构函式来管理区域类别数据  
虽然我们会在本书稍后的篇幅来介绍更复杂的情境， 在此我想先用简单的案
例来介绍以建构函式、解构函式来提供资源 保护的功能。这也是使用解构函
式最常见的情境。假设我们有个如下宣告结构的类别 (是Date3范例项目的
一部分程序代码 ): 
type  
    TPerson = class  
    private  
       FName: string;  
       FBirthDate: TDate;  
    public  
       constructor Create (name: string);  筆記   
 225        destructor Destroy; override;  
       // some actual methods  
       function Info: string;  
   end;   
 
这个类别包含了一个内部对象的参考，名为 FDate。当 TPerson类别的实体
被建立的时候，这个内部 (或者子 )对象应该也要同时被建立，而当这个实体
被摧毁，内部这个对象也要一起被摧毁。以下是我们可以用来撰写这个建构
函式以及重载后的解构函式程序代码， 以及可以永远用来确保内部对象存在
的内部函式。  
constructor TPerson.Create (name: string);   
begin   
   FName := Name;  
   FBirthDate := TDate.Create;  
end;  
 
destructor TPerson.Destroy;  
begin   
   FBirthDate.Free;  
   inherited;  
end;  
 
function TPerson.Info: string;  
begin  
   Result := FName + ': ' + FBirthDate.GetText;  
end;  
 
_____________________________________________ ____________________________  
要了解用来定义解构函式重载 (override) 这个关键词，以及在函式中的
inherited 这个关键词，请等到下一章。目前我们先简单的说，第一个关键词
是用来指出该类别有一个新的定义，要用来取代掉基础的 Destroy解构函
式。而第二个关键词则是用来呼叫该类别上一代的结构函式。也请记得，
override只用在方法的宣告，不会出现在实作的程序代码之中。  
 
现在我们可以在以下的情境中使用外部类别的对象， 而内部对象会适时的在
TPerson对象被建立的时候一起被建立起来，也会在 TPerson被摧毁时一起
被处理掉：  
 筆記   
 226 var 
   Person: TPerson;  
begin  
   Person := TPerson.Create ('John');   
   // use the class and its internal object  
   Show (Person.Info);   
   Person.Free;   
end;   
 
以上的程序代码，可以在 Date3范例项目中找到。  
 
因为这是类似程序在 Object Pascal 的标准写法，支持 ARC功能的编译程序
不会要求我们在上面的程序代码当中精确的呼叫 Free。所以在 ARC的架构
下，解构函式即使不被呼叫、不被撰写，也不会有什么负面影响。  
_________________________________________________________________________  
目前可以直接支持 ARC功能的 Object Pascal 编译程序包含有 Android编译
程序、 iOS仿真器编译程序，以及 iOS装置编译程序。未来还会陆续增加。
在内存使用以及程序代码类型的不同点，会在第十三章里面介绍。  
 
  多载方法以及建构函式  
Object Pascal 支持对函式与方法的多 载：我们可以用同一个名称建立许多方
法，但这些方法的参数必须不一样。我们已经看过全局函式跟程序的多载是
怎么运作的，同样的规则也适用于方法。透过检查参数，编译程序可以判断
出我们想要呼叫的方法是哪个版本。  
 
重申一次，多载的基本规则有两个：  
 每一个版本的方法必须在宣告时最后都加上 overload关键词。  
 每一个版本的参数型别或数量必须有点不同， 然而回传值并不能拿来作
为多载方法的判别条件。  
 
如果多载备用在一个类别里面的所有方法上，这个功能也会跟建构函式有
关，因为我们可以建立多个建构函式，并且都将之命名为 Creat，这会让建
构函式更容易被记忆。  
_________________________________________________________________________  
来谈点历史，多载功能被加入到 C++就是特别为了让多个建构函式可以被
使用， 因为 C++的建构函式必须都是相同名称 (类别的名字 )。在Object Pascal
里面，这个功能相对的不是很需要，因为多重建构函式本来在 Object Pascal筆記  
筆記   
 227 里面就可以有不同的名称，即使如此仍旧把这个功能加入，则是因为在其
他情形底下，多载功能仍然很有用处。  
 
我在 TDate类别里面加了两个不同版本的 SetValue 方法，作为多载的范例：  
type  
   TDate = class  
   public  
      procedure SetV alue (Month, Day, Y ear: Integer); overload;   
      procedure SetV alue (NewDate: TDateTime); overload;   
 
procedure TDate.SetV alue (Month, Day, Y ear: Integer);   
begin  
   FDate := EncodeDate (Y ear, Month, Day);   
end;   
 
procedure TDate.SetV alue(NewDate: TDateTime);   
begin   
   FDate := NewDate;  
end;  
 
在这个简单的步骤之后，我也在这个类别里面加入了两个独立的 Create建
构函式，其中之一不用参数，这个版本把预设的建构函式直接取代掉了，另
一个则会进行数据初始化。 不用参数的建构函式会使用今天的日期作为默认
的数据：  
type  
   TDate = class  
   public  
      constructor Create; overload;  
      constructor Create (Month, Day, Y ear: Integer); overload;   
 
constructor TDate.Create (Month, Day, Y ear: Integer);   
begin   
   FDate := EncodeDate (Y ear, Month, Day);   
end;   
constructor TDate.Create ; 
begin  
   FDate := Date;  
end;   
 228 有了这两个建构函式，我们就可以用以下两种方法来建立新的 TDate对象
了：  
var 
   Day1, Day2: TDate;  
begin  
   Day1 := TDate.Create (1999, 12, 25);   
   Day2 := TDate.Create; // today   
 
这段程序代码是 Dates4范例项目的一部分。  
 
  完整的 TDate类别 
综观这一节，我们已经在不同的程序片段里面看过了 TDate类别。第一个版
本是以三个整 数来储存年月日三个部分的数值。第二个版本则是使用
TDateTime 型别作为内部数据，以下是完整的 TDate类别定义 : 
unit Dates;   
interface   
type  
  TDate = class  
  private  
      FDate: TDateTime;  
  public  
     constructor Create; overload;   
     constructor Create (Month, Day, Y ear: Integer); overload;    
     procedure SetV alue (Month, Day, Y ear: Integer); overload;   
     procedure SetV alue (NewDate: TDateTime); overload;   
     function LeapY ear: Boolean;   
     procedure Increase (NumberOfDays: Integer = 1);   
     procedure Decrease (NumberOfDays: Integer = 1);  function GetText: string;   
  end;   
implementation  
... 
 
新增的两个方法： Increase 跟Decrease( 两个方法都有预设的参数值 )，也都
相当的容易理解。如果呼叫时不给参数，他们会直接把内部数值改成前一天
或下一天，如果 NumberOfDays 参数有被指定，则会依据这个参数把内部数
值改成往前或往后几天：  
  
 229 procedure TDate.Increase (NumberOfDays: Integer = 1);   
begin   
   FDate := FDa te + NumberOfDays;   
end;   
 
GetText 方法则会以格式化的字符串回传内部数值的日期，我们透过
DateToStr 函式来做这个转换：  
function TDate.GetText: string;  
begin  
    GetText := DateToStr (FDate);  
end;  
 
我们已经看过了前一节当中的大多数方法，所以我们不再做完整的列表了，
您可以从 ViewDate 范例中找到这些程序代码。这个窗体的内容比书上其他
的范例都来的复杂。它包含了一个用来显示日期的卷标，以及六个按 钮。这
六个按钮都可以用来变更对象内部的日期数据。您可以从图 7.3里面看到该
项目的窗体画面。为了让卷标组件好看，我用了比较大的字体，让它跟窗体
一样宽，并且把对齐的属性 (Alignment) 设定成 Center，也把 AutoSize 设为了
False。 
_________________________________________________________________________  
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
这个程序第一个被执行的程序代码，会是窗体的 OnCreate 这个事件处理程
序。在对 应的方法中，我建立了一个 TDate类别的实体，然后把这个建立的圖7.3: 
ViewDate 範例
的執行畫面  
 
 230 对象初始化，最后把它的内容以字符串格式显示在窗体上的卷标文字字段，
如上图 (图7.3)所示。  
procedure TDateForm.FormCreate(Sender: TObject);   
begin   
   ADay := TDate.Create;  
   LabelDate.Text := ADay.GetText;  
end;  
 
ADay是TDateForm 这个窗体类别的私有字段。顺带一提，这个类别的名字
是当我们把窗体的名称字段改为 Date Form时，开发环境自动修改的。  
 
指定的日期对象是在窗体被建立时自动建立的 (就像我们刚刚看过的 person
类别跟它的日期子对象关系一样 )，也会在窗体被摧毁时自动被摧毁：  
procedure TDateForm.FormDestroy(Sender: TObject);   
begin   
   ADay.Free;  
end;  
 
当用户点选六个按钮的其中一个，我们需要使用 ADay对象的对应方法，并
把新的数值内容显示在卷标文字上：  
procedure TDateForm.BtnTodayClick(Sender:  TObject);   
begin   
   ADay.SetV alue (Today);  
   LabelDate.Text := ADay.GetText;  
end;  
 
另一个撰写最后一个方法程序代码的替代方案则是直接把目前的对象摧毁
掉，然后建立一个新的：  
procedure TDateForm.BtnTodayClick(Sender: TObject);   
begin   
   ADay.Free;  
   ADay := TDate.Create;  
   LabelDate.Text := ADay.G etText;  
end;   
 
在这个特殊的情形中，这个例子并不够好 (因为建立一个新的对象，并把它
摧毁掉，会花很多额外的时间，尤其是当我们只是想更改对象内容的时候 )，
但透过这个案例，我可以示范一些 Object Pascal 里面的技术。第一个值得一 
 231 提的是我们在指派一个个新的对象前，会先摧毁前一个物件。事实上这个指
派的动作是更换了参考值 (reference) ，把对象留在内存里面 (即使可能并没有
任何指标指向它 )。当我们把一个对象指派给另一个，编译程序只会把对象
在内存里面的参考地址复制到新的对象参考地址。  
 
这是在桌 面型操作系统的情形。在 ARC功能启动的行动装置操作系统则不
是，在行动装置操作系统中，程序就不用呼叫 Free了：  
procedure TDateForm.BtnTodayClick(Sender: TObject);   
begin   
   ADay := TDate.Create;  
   LabelDate.Text := ADay.GetText;  
end;   
 
事实上，当新对象被指派时，原先储存在该变量里的对象，就会被自动释放
掉了。  
 
另一个问题，是我们怎么把数据从一个对象复制到另一个。在上面这个程序
代码的案例非常单纯，因为它只有一个数据字段跟对应的方法用来初始化。
通常如果我们想要改变存在一个既存的对象中的数据， 我们得复制每一个字
段，或者提供一个特殊的方法来复制所有内部数据。部分类别会拥有一个名
为Assign的方法，可以用来进行深度复制的作业。  
_________________________________________________________________________  
更精确一点，在 RTL里面，所有类别都是从 TPersistent 类别衍生而来，这
个类别提供有 Assign方法，但大多数 从TComponent 衍生的类别则没有实
作它，所以呼叫组件的 Assign会造成例外发生。原因是因为 RTL支持的串
流化机制以及对 TPersistent 型别的属性支持，但在这个章节说明这一点还
太复杂。  
 
嵌套类型与巢状常数  
Object Pascal 允许我们在一个单元文件里面的 interface区段宣告新的类别，
在这里宣告的类别，可以被其他单元文件存取，也可以被 implementation 区
段的程序存取。在 implementation 区段里面的程序与类别，则只能被存在同
一个单元文件里面的程序代码或全局子程序 (也只限于写在同一个单元文件
里面 )所存取。  
 
最近比较新的一个作法，是在一个类别当中宣告另一个类别 (或任何一种型
别)的可能性。而该类别的任何其他成员，巢状类别跟其他嵌套类型都会有筆記   
 232 被限制的可见度 (或者用我们已经介绍过的名词 :私有区，或保护区 )。嵌套类
型的相关范例包含同一类别与其他在 implementation 区段支持的类别所使用
的列举作业。  
 
相关的语法允许我们定义一个巢状常数，这个常数可以跟一个类别相关 (再
提一次，如果在私有区宣告，就只允许内部使用，如果在公开区宣告，则在
整个程序的任何一个部分都能使用 )。举例来 说，下面的程序代码就宣告了
一个巢状类别 (这是从 NestedTypes 范例项目中， NestedClass 单元文件所节
录的 ): 
type  
   TOne = class  
   private  
      someData: Integer;  
   public  
      // nested constant   
      const foo = 12;   
      // nested type   
      type  
         TInside = class   
         public   
            procedure InsideHello;  
         private  
            Msg: string;  
         end;  
     public  
       procedure Hello;  
   end;   
 
procedure TOne.Hello;   
var  
   ins: TInside;  
begin  
   ins := TInside.Create;   
   ins.Msg := 'hi';   
   ins.InsideHello;   
   Show ('constant is ' + IntToStr (foo));   
   ins.Free;   
end;    
 233  
procedure TOne.TInside.InsideHello;   
begin   
   msg := 'new msg';   
   Show ('internal call');   
   if not Assigned (InsIns) then   
     InsIns := TInsideInside.Create;  
   InsIns.Two;  
end;   
 
proc edure TOne.TInside.TInsideInside.Two;   
begin   
   Show ('this is a method of a nested/nested class');   
end;   
 
巢状类别可以在类别中直接使用 (例如在前例的范例程序代码中的用法 )，或
者在类别之外使用 (如果巢状类别宣告在公开区的话 )，但必须完整把名称写
上： TOne.TInside 。完整的类别名称也在巢状类别的方法定义中使用。在这
个例子里面，就得写 TOne.TInside 了。主类别可以在宣告巢状类别之后，立
刻拥有一个以巢状类别为型别的数据字段 (就像我们看到在 NestedClass 范例
项目中的程序代码一样 )。 
 
拥有巢状类别的类别可以这样使用：  
var 
   One: TOne;  
begin  
   One := TOne.Create;  
   One.Hello;  
   One.Free;  
 
这段程序代码的输出值如下 : 
internal call   
this is a method of a nested/nested class   
constant is 12   
 
我们从使用 Object Pascal 的巢状类别 到底得到了什么好处 ?这个概念在 Java
里面很常用来实作事件处理程序，也在 C#的类别中无法在同一 文件中的其
他类别隐藏信息时使用。 在 Object Pascal 当中唯一使用到巢状类别的用途是 
 234 当我们在类别的私有区里面宣告一个类别数据字段时， 不想把这个类别加到
全局的命名空间，也不让它被全局程序代码看见，此时，巢状类别就派上用
场了。  
 
如果内部类别只用在一个方法中，我们可以透过在单元文件的
implementation 区段宣告该类别来达成相同的效果。但如果这个内部类别会
在同一单元文件的 interface 区段被参照使用的话 (例如，我们要把它作为类
别的字段或者函式的参数 )，这个类别就必须在相同的 interface区段中宣告，
当然也就会暴露在其他程序代码之下了。在基础型别中宣告这样的字段，然
后把它放在私有区实在是不如使用巢状类别来的干净利落。  
_________________________________________________________________________  
在第十章，我们提供了一个实际的案例，对巢状类别做了一些练习，用了
for-in循环做了一些实作。  
 
 
 筆記   
 235 08:继承 
 
如果撰写类别的主要原因 是为了封装，那么使用继承的主要理由就是为了
弹性。把两个概念结合之后，我们就可以拥有一个强大的资料型别，我们
可以拿来使用，而且以后不用为了改其中的功能而为这个数据型别来建立
许多不同版本了，这个概念一开始被称为 ”开放式封闭概念 (open -close 
principle)” 。继承能够把一些程序代码很紧密的结合起来，也能够让程序人
员发挥很强的功能 (当然，也会带来更大的责任 )。并不是在这里开启对这个
功能的争论，我们在这里要做的，是介绍型别继承是怎么发挥作用的，尤
其在 Object Pascal 中，型别继承是怎么发挥作用 的。  
 
从既存的型别中继承  
我们通常需要使用一些不同的功能，这些功能可能是从我们自己之前写过
的程序代码，或者从别人写过的程序代码里面部分功能提供出来的。例如，
我们可能会需要为已经写好的程序代码加上一些新的方法或者做一些改
变。我们当然可以直接改原来的程序原始码，但有时候我们会同时需要这
两种版本同时存在，在不同的情形中分别使用到。或者有个类别是别人写
的(或者我们从函式库里面找到的 )我们可能想要保留一个我们自己的独立
版本。  
 
传统在学校里面教授过的替代方法，是把原来的类别程序代码留一份下来，
直接改一份新的程序代码 ，两份并存。这样做也可以，不过也可能创造问
题:在重复的程序代码里面，我们可能也重复了原本的程序错误，如果我们
要加一个新功能，我们可能得在两份程序代码里面都各做一次 (可能得多做
很多次也说不定，要看我们最后一共搞了多少个版本出来 )。再者，这几个
不同版本的类别程序代码最后会变成不同的独立型别，编译程序没办法告
诉我们哪个版本才是最好的，也没办法告诉我们两个版本之间有哪些雷同
之处。  
 
为了解决这些因为类别之间相似而导致的问题， Object Pascal 允许我们用既
存的类别直接定义出一个新的类别。这个技术就称为 继承 (或者次类别、或
型别衍生 )，这个技术也是面向对象设计程序语言的基础元素之一。要从一
个既存的类别进行继承，我们只需要在定义类别的第一行，指出我们要从
哪个既存类别衍生出新类别即可。举例来说，这个动作会在我们每次建立 
 236 一个新窗体的时候由 IDE自动帮我们做好 : 
 
type  
  TForm1 = class(TForm)   
  end;   
 
这个简单的宣告表示 TForm1类别会从 TForm继承所有的方法、数据字段、
属性、以及事件。我们可以从 TForm1的对象来使用 TForm类别的任何一
个公开方法。 TForm类别依序继承了 其上每一代的对象所有的方法，一直
回溯到 TObject类别 (这是 Object Pascal 里所有类别的基础类别 )。 
 
跟C++, C#, Java 做个比较，用这三个语言来宣告，则会写成 : 
class Form1 : TForm   
{  
... 
}  
 
作为继承关系的一个简单范例，我们可以用上一章的范例来改写成
ViewDate 范例项目，从 TDate衍生一个新的类别，并且把它的函式 GetText
改写一下。您可以从 DerivedDates 范例项目的 DA TES.pas 文件找到这个程
序代码：  
type  
   TNewD ate = class (TDate)  
   public  
      function GetText: string;  
   end;  
 
在这个范例里， TNewDate 是从 TDate衍生而来。简单的说， TDate是
TNewDate 的父代类别，基础类别或者祖先类别。而 TNewDate 则是 TDate
的子类别、衍生类别，或者次类别。  
 
为了实作新版的 GetText函式，我使用了 FormatDateTime 函式，这个函式
中使用了预先定义的月份名称 (还有其他功能 )，以下是 GetText方法，其中
的’dddddd’代表了长日期格式：  
function TNewDate.GetText: string;   
begin   
   Result := FormatDateTime (‘dddddd’, fDate);   
end;    
 237  
一旦我们定义了新的类别，我们就得在 DerivedDates 项目的窗体程序代码
里面使用这个新的数据型别。直接定义一个以 TNewDate 为型别的对象
ADay，然后在 FormCreate 方法里面呼叫这个类别的建构函式：  
type  
  TDateForm = class(TForm)   
  ...  
  private   
    ADay: TNewDate; // updated declaration  
  end;   
 
procedure TDateForm.FormCreate(Sender: TObject);   
begin   
   ADay := TNewDate.Create; // updated line   
   DateLabel.text := TheDay.GetText;  
end;  
 
不用任何程序代码变更，这个新的范例项目就能执行的很顺畅。新的类别
TNewDate 继承了所有 TDate的方法， 可以把日期设定向后延伸跟使用其他
功能。换句话说，原来呼叫这些方法的程序代码仍旧可以正常运作。事实
上，呼叫新版的 GetText方法时，我们并不用改变任何程序代码！ Object 
Pascal的编译程序会自动把呼叫这个方法跟新版的方法做绑定。 所有事件处
理程序的程序代码也都不用改变，虽然在新版的输出文字上，其意义已经
跟旧版的事件有些不同 (请见图 8.1)： 
_________________________________________________________________________  
  
 
 
 
 
 
 
 
 
 
 
 
 圖8.1: 
DerivedDates 程
式的執行畫面，月
份跟日期的名字
是依照 Windows
的地區與格式設
定而顯示的  
 
 238  
 
常用的基础类别  
我们已经介绍过，要从一个类别衍生新类别时，可以这样写：  
type  
   TNewDate = class (TDate)  
     ...  
   end;   
 
但如果我们指定从基础类别衍生，写成以下这样的话，会发生什么事呢 : 
type  
   TNewDate = class  
     ... 
   end;   
 
在这种情形下，我们的类别就会从基础类别衍生，也就是 TObject。换句话
说，Object Pascal 是单一根源的类别架构。在这种架构之下，所有类 别直接
或间接的都是从 TObject衍生而来的。 最常用的方法就是 TObject的Create, 
Free跟Destroy方法，以及我在本书当中其他篇幅里面所用到的方法。关于
TObject的完整介绍 (包含在语言跟 RTL两个层面 )，我们会在第 17章里面
介绍。  
_________________________________________________________________________  
共享基础类别的概念，除了 Object Pascal 以外，还有 C#跟JavaScript 也是
这样的架构，在这两 个语言里面，基础类别称为 Object。C++则是完全不同
的架构， C++是支持多重基础类别继承的架构。  
 
保护区字段与封装  
TNewDate 类别 GetText方法的程序代码只有在跟 TDate写在同个单元文件
里面才会编译。事实上，它会存取父代类别的 fDate私有区字段，如果我们
想要在不同单元文件里面制作子类别的话，我们要不就得把 fDate这个字段
放在保护区， 或者在父代类别里加入一个简单的保护区方法来读取这个私有
区的字段。  
 
很多开发人员相信第一种作法是最好的，因为把大多数字段宣告在保护区，
可以让类别比较有延伸性 ，要用它来撰写子类别也比较容易。然而，这就抵
触了数据封装的原意。要在大架构的一群类别当中，想把其中基础类别的保筆記   
 239 护区字段做变更，就有如要修改部分全局数据结构一样困难。如果有 10个
衍生类别存取这个数据字段，对这个字段做变更，可能意味着有 10个类别
都必须要跟着做修改。  
 
换句话说，弹性、延伸性，以及封装，这三个目标通常是有所冲突的。当冲
突发生的时候，我们应该试着以封装这个目标为重。如果我们能够做到这一
点，而不牺牲弹性，那就更棒。通常这个中间解决方案，可以透过使用虚拟
方法来达成，虚拟方法我们会在稍后的 ”延迟绑定与多 型”这一节里面来讨
论。如果我们选择不以封装为重，而选择能让次类别的撰写比较容易、快速
一点，那我们的设计很有可能就没办法依循面向对象的原则了。  
 
也要记住，保护区的字段在存取规则上跟私有区是一样的，所以同一个单元
文件里面的其他类别也随时可以存取任何一个同单元文件里面类别的保护
区成员喔。如同前一章我们提过的，我们可以用更强的封装方式，只要使用
分区存取关键词 srtrict protected 即可。  
  
  使用受保护的黑客  (Protected Hack)  
如果您是 Object Pascal 的入门者，而且要迈入面 向对象程序，那么这
一节对您来说就会是相对进阶的章节，您或许会想先略过这一节，因为
这一节可能会比较容易让您觉得难懂。  
 
我们已经知道单元文件保护区的范围， 即使是宣告在同一单元文件的类别所
属的基础类别的保护区成员，也可以被同一单元文件的其他类别直接存取。
这种合于 OOP规则的漏洞，就称为『受保护的黑客』 。这是能够定义一个衍
生类别跟其父代类别完全相同， 但只是为了取得其父代类别保护区成员的访
问权限。以下是其工作的原理：  
 
我们已经介绍过，一个类别的私有区、保护区，是可以被任何跟这个类别位
于相同单元 文件里面的其他类别存 取的。 举例来说， 以下这个简单的类别 (它
是Protection 范例项目的一部分 ): 
type  
   TTest = class  
   protected  
      ProtectedData: Integer;  
   public  
      PublicData: Integer;  
      function GetV alue: string;   
 240    end;  
 
GetValue 这个方法会简单的回传包含两个整数数值的字符串：  
function TTest.GetV alue: string;  
begin  
   Result := Format (‘Public: %d, Protected: %d’, [PublicData, ProtectedData]);   
end;   
 
一旦我们把这个类别放在独立的单元文件里面， 我们就没办法从任何其他单
元文件来存取它的保护区成员了，例如我们写了以下的程序代码 : 
procedure TForm1.Button1Click(Sender: TObject);  
var  
   Obj: TTest;  
begin  
   Obj := TTest.Create;   
   Obj.PublicData := 10;   
   Obj.ProtectedData := 20; // won’t compile   
   Show (Obj.GetV alue);   
   Obj.Free;   
end;   
 
编 译 程 序 会 直 接 提 出 以 下 的 错 误 讯 息 :未 经 宣 告 的 识 别 符 号 : 
“ProtectedData” 。在此时我们或许会想到没有办法存取宣告在其他单元文件
的类别的保护区数据。然而，还是有方法可以处理的。想想，如果我们建立
了一个显然没有用途的衍生类别，像是 : 
type  
   TFake = class ( TTest);  
 
现在，在宣告它的同一个单元文件里面，我们就可以呼叫 TFake类别的所有
保护区方法了。 事实上我们可以呼叫同一单元文件里面所有类别的保护区方
法。但是，这样怎么帮助我们使用 TTest类别的对象呢 ?想象一下，两个共
享完全相同内存架构的类别， 我们可以强迫编译程序把一个类别的对象当做
另一个类别的，通常可以透过不安全的型别转换来达成：  
procedure TForm1.Button2Click(Sender: TObject);   
var  
   Obj: TTest;  
begin  
   Obj := TTest.Create;    
 241    Obj.PublicData := 10;   
   TFake (Obj).ProtectedData := 20; // compiles!   
   Show (Obj.GetV alue);   
   Obj.Free;   
end;   
 
这段程序可以编译，运作也正常，就像我们可以看到 Protection 范例项目执
行一样。重申一次，原因是 TFake类别自动继承了 TTest基础类别的保护区
字段， 且因为 TFake类别也在跟想要存取这些数据的程序代码位于同一个单
元文件里面，所以保 护区的数据是可以被存取的。  
 
现在，我们来探讨为什么这可以行得通 ?我得先警告读者，这个可是违反类
别保护机制的，这个方法可能会让你的程序发生错误 (存取不该存取的数
据)，且还遵循着 OOP记录的规则执行着。然而有些时候，透过这个技术是
最好的解决方法，就像您可以在阅读函式库的原始码时，发现很多组件的原
始程序就是这样做的。  
 
总体来说，这个技术更像是在骇入系统，且不管何时都应该尽量避免，但它
可以跟其他任何效果一样，被视为是 Object Pascal 程序语言的规格，且在任
何操作系统、任何版本的 Object Pascal 都有效。  
 
从继承到多型  
如同字面的意义，继承是个好技术，透过它，我们可以避免程序代码重复，
并在许多不同的类别之间分享方法。然而，其内涵的力量来自让不同类别的
对象使用同一规则的能力，像是常被在 OOP语言里面以 ”多型”或者”延迟绑
定”这两个名词界定的意思。  
 
我们需要先探索一些技术：衍生类别之间的型别兼容性，虚拟方法，以及在
接下来这一节里面要介绍的。  
 
  继承与型别兼容性  
如同我们已经看过的一些主题， Object Pascal 是一个强型别的语言，举个实
例，这表示我们不能把一个整数型别的值指派给一个布尔型别的 变数。至少
不能在没有经过明确写出要求型别转换的情形下是如此的。基本规则是，两
个数据只有在属于相同型别时，才具有型别兼容性，更精确一点来说，他们
所属的数据型别的名称必须完全相同，且定义在同一个单元文件里面才算。   
 242  
这个规则里有一个重要的例外，就是类别型别。如果我们宣告了一个类别，
姑且说它叫做 TAnimal，然后用它衍生出新的类别，就叫 TDog好了，我们
可以把 TDog类别的对象指派给 TAnimal。 这是因为 Dog是Animal的一种 (狗
也是一种 动物 )。从程序语言的角度或许您会觉得讶异，以下呼叫建构函式
的语法都是 合法的：  
var 
  MyAnimal1, MyAnimal2: TAnimal;   
begin  
   MyAnimal1 := TAnimal.Create;  
   MyAnimal2 := TDog.Create;  
 
用更精确的字眼来说，我们可以把子类别的对象当做父类别的变量来使用。
然而反向的使用就不行了， 我们不能把父类别的对象当成子类别的变量来使
用，以下就是这个理论的程序代码体现：  
MyAnimal := MyDog; // This is OK   
MyDog := MyAnimal; // This  is an error!!!   
 
事实上，我们当然可以说狗是一种动物，但不能说动物一定就是狗吧。这在
大多数时候说的通，但不是定律。这相当合逻辑，且程序语言的型别兼容性
也遵循这个逻辑。  
 
在我们仔细深入 Object Pascal 关于这个重要功能的意涵之前， 请先试着执行
Animals1 范例项目，在这个项目里面定义了两个简单的类别， TAnimal 跟
TDog，TDog是从 TAnimal 衍生而来的 : 
type  
   TAnimal = class  
   public  
      constructor Create ; 
      function GetKind: string;  
   private  
      FKind: string;  
   end;  
 
   TDog = class (TAnimal)  
   public  
      constructor Create;  
   end;   
 243  
 
这两个建构函式 Create都只是简单的设定 FKind的值， 这个值会由 GetKind
函式回传。  
 
这个范例的窗体，请参考图 8.2，有两个单选按钮 (放在一个 Panel上面 )，可
以选择属于何种类别的对象。这个对象储存在私有区 ，名为 MyAnimal ，属
于TAnimal 类别。 这个类别的实体会在窗体每次建立或重建的时候依照单选
按钮的选择被建立且进行初始化 (在此我们只显示第二个单选按钮对应的程
序代码 )： 
procedure TFormAnimals.FormCreate(Sender: TObject);   
begin   
    MyAnimal := TAnimal.Create;  
end;  
 
procedure TFormAnimals.RadioButton2Change(Sender: TObject);   
begin   
    MyAnimal.Free;  
    MyAnimal := TDog.Create;  
end;  
_________________________________________________________________________  
  
 
 
 
  
 
 
 
 
 
最后， Kind按钮会呼叫目前这个 animal的GetKind方法来把结果显示在窗
体下方的 Memo里面：  
procedure TFormAnimals.BtnKindClick(Sender: TObject);   
begin   
    Show(MyAnimal.GetKind);  
end;  
 圖8.2: Animals1
範例專案的表單
在開發環境內的
樣子  
 
 244  
 
  延迟绑定与多型  
Object Pascal 函式跟程序通常都是静态绑定，或者也称为早期绑定。这表示
一个方法在程序撰写时，编译程序或链接程序就已经进行解析，且程序代码
会在编译结果的 文件中，被置换成该程序呼叫所要对应到的内存位置。 (这
内存位置也被称为函式地址 )。面向对象程序语言则同时允许另一种绑定，
称之为延迟绑定，或者动态绑定。在这种情形下，要被呼叫的函式或方法的
实际地址，得等到运行时间，由用来呼叫该函式的对象实体的型别来决定。  
 
这个技术的好 处也被称之为 多型。 多型意味着我们可以撰写程序来呼叫一个
方法，当然是得从一个对象变量来发起，但 Delphi会依照该对象的实际类
别来决定要使用哪个方法。 Delphi在运行时间确定对象变量的实际型别之
前，无法决定要使用哪个函式或方法，就因为前一节我们讨论过的型别兼容
性。  
_________________________________________________________________________  
Object Pascal 的方法预设是使用早期绑定式，跟 C++, C#一样。其中一个原
因是因为这 样比较有效率。而 Java则不一样， Java使用延迟绑定 (并提供一
些方法让编译程序可以使用早期绑定来对方法进行优化 )。 
 
假设一个类别跟它的子类别 (就用刚提到的 TAnimal 跟TDog做范例吧 )，两
者都定义了一个方法，这个方法就会是延迟绑定。现在我们可以用一个通用
的变量，例如 MyAnimal 来呼叫这个方法，在运行时间，这个变量可以是
TAnimal 或TDog型别。实际上在运行时间会用到哪个类别的方法，就得看
当时该对象是属于哪个类别了。  
 
Animals2 范例项目则延伸了 Animals1 项目来做为这个技术的范例。 在新版
本中， TAnimal 跟TDog类别都提供了一个新的方法 :Voices，这个方法表示
被选中的动物所发出的声音，同时以文字跟声音表示。这个方法在 TAnimal
类别中以虚拟方式定义 (Virtual)，在稍后我们定义 TDog类别时进行重载
(override) ，透过 virtual跟override这两个关键词 : 
type  
   TAnimal = class  
   public  
     function V oice: string; virtual;   
 
   TDog = class (TAnimal)  筆記   
 245    public  
     function V oice: string; override;   
 
当然，这两个方法也需要被实作喔，以下是简单的实作程序代码 : 
function TAnimal.V oice: string;  
begin  
   Result := 'AnimalV oice';  
end;   
 
function TDog.V oice: string;  
begin  
   Result := 'ArfArf';  
end;  
 
那我们呼叫 MyAnimal.Voice 会有什么反应呢 ?要看情况而定。 如果 MyA nimal
变量目前是储存 TAnimal 类别的对象，就会呼叫 TAnimal.Voice 。如果储存
的是 TDog类别对象，就会呼叫 TDog.V oice 。这个情形是因为该方法是虚拟
的(Virtual)。 
 
对所有 TAnimal 类别的任何子类别对象来呼叫 MyAnimal.Voice 方法都会正
常执行，即使该类别是在这个方法的程序代码之后才定义的，或者已经超出
了它的可视范围。编译程序不会需要一一知道衍生类别的族谱，就能让上面
的这个函数调用兼容， 编译程序只需要知道被呼叫的对象所属类别的父代类
别。换句话说， MyAnimal. Voice这个方法可以在所有 TAnimal 的子类别兼
容。  
 
这就是为什么 OOP的程序语言在重复使用性这一点很强的关键性科技因素
了。我们就算不用知道类别架构跟特定类别之间的关系，也可以直接写一段
使用该类别的程序代码， 。换句话说，该架构 (或者说该程序 )仍然具备可延
展性，即使当我们用它写了数千行的程序代码。当然，有个前提条件，就是
这个架构的父代类别得要仔细设计。  
 
Animals2 项目示范了这些新类别的用法，并提供了类似前一个范例的窗体。
以下的程序代码会在点击按钮的时候被执行，显示输出文字，并播放一些声
音出来：  
begin  
 Show (MyAnimal.V oice);  
 MediaPlayer1.FileName := SoundsFolder + MyAnimal.V oice + '.wav';    
 246  MediaPlayer1.Play;   
end;   
 
 
_________________________________________________________________________  
这个项目使用了 MediaPlayer 组件来播放项目内嵌的两个声音 文件的其中
之一 (声音文件是用实际的声音字符串来 命名的， 这个声音字符串会由 Voice
回传 )。相对随机的噪音是提供给 TAnimal，而狗叫声则是提供给 TDog来
播放的。现在这段程序代码在 Windows 上面可以很容易执行了，只要声音
档放在适当的文件夹里面，但如果在行动装置平台上开发，就需要一些额
外的设定，好让这些 文件能自动放到对应的文件夹去。看一下实际的范例，
来看一下发布到行动装置平台时的文件夹是要怎么设定了。  
 
  重载(Override) 、重新定义 (Redefine) 、重新介绍    
  (Reintroduce) 方法 
如我们刚刚看过的，在衍生类别里面要重 载一个延迟绑定的方法，我们得使
用override这个关键词。请注意这个方法只能用在父代类别中，宣告为虚拟
(virtual)的方法。否则，如果该方法是静态方法，就无法进行延迟绑定，在
子类别也不能更改程序代码了。  
_________________________________________________________________________  
您可能还记得我们在前一章就使用了这个关键词来重载 Destroy这个从
TObject继承而来的预设解构函式。  
 
这个规则很简单 : 只要一个方法被定义成静态 方法，则这个方法在任何一代
的子类别里面也都是静态方法， 除非我们在某一代子类别里面特别去用虚拟
的同名方法把它给替代掉。而定义成虚拟方法之后，这个方法在任何一代的
子类别也都会是延迟绑定的，而且没有任何方法可以改变这一点，因为编译
程序为延迟绑定的方法建立程序代码的方式是不同的。  
 
要重新定义一个静态方法，我们只需在子类别里面加入同样名称的方法，不
管参数是否相同，也无须加入任何关键词。要重载一个虚拟方法，我们则需
要在子类别里面用相同名称、相同参数来定义这个方法，并且结尾要加上一
个override关键词：  
type  
   TMyClass = class  
     procedure One; virtual;  筆記  
筆記   
 247      procedure Two; // static method  
   end;  
 
   TMySubClass = class (MyClass)  
     procedure One; override;  
     procedure Two;  
  end;   
 
被重新定义的方法 Two，就不再使用延迟绑定。所以当我们透过基础类别的
对象来呼叫这个方法，就会执行基础类别的方法了。 (也就是说，如果该变
量是指向衍生类别的对象，则透过该对象呼叫 Two这个方法时，执行的结
果跟基础类别对象执行的结果将会不同 )。 
 
有两种传统的方法可以重载一个方法。 第一是把父代类别的方法改写一个新
版本，第二则是在已经存在的方法里面加入一些程序代码。以第二个作法实
作时，可以透过使用 inherited 这个关键词来呼叫父代类别的同名方法。举例
来说，我们可以这样写：  
procedure TMySubClass.One;  
begin  
   // new code   
   ...  
   // call inherited procedure  TMyClass.One   
   inherited One;   
end;   
 
您可能会觉得有点讶异，为什么需要使用 orverride 关键词 ? 在其他程序语
言里，当我们在子类别里面重新定义一个虚拟方法时，就已经会自动重载原
来的方法了。然而透过关键词的使用，编译程序可以检查在父代类别跟子类
别之间同名方法之间的名称与关系 (重新定义方法时，把名称打错是很常见
的错误，在其他 OOP语言里面也一样 )，检查看看该方法在父代类别是否是
虚拟方法，以及其他项目。  
______________________________ ___________________________________________  
另一个热门的 OOP程序语言  C# 也使用相同的 override关键词。这一点都
不令人讶异， 因为 C#跟Object Pascal 的程序语言设计者是同一个人。 Anders 
Hejlsberg 曾经写了不少文章来说明为何 override这个关键词是设计函式库
中 基 础 可 视 化 工 具 的 原 因 ， 您 可 以 从 这 里 读 读 看 : 
http://www.artima.com/intv/nonvirtual.html 更近期的语言， Apple的Swift语
言也是使用 override关键词让衍生类别来修改方法的。  筆記   
 248  
这个关键词的另一个优点， 是如果我们在从函式库的类别中衍生任何类别时
定义了静态方法，并不会发生问题，即使函式库已经用了一个新的虚拟方法
来取代我们在子类别所定义的同名方法。因为我们定义的方法并没有使用
override关键词，所以会被自动认为新的这个方法是一个新的独立方法，并
不是被加入到函式库那个方法的新版本。 (如果编译程序认为是重载版本的
话， 父代类别这样的程序修改可能会让我们在子类别中重新定义的程序无法
执行 ) 
 
支持多载 (overloading) 为这个功能 蓝图添加了一些复杂度，子类别当中可以
透过 overload关键词来帮一个方法加入新的版本。 如果这个方法的参数跟基
础类别中同名方法的参数不同，就会很有效率的变成多载方法，如果参数相
同，则会直接取代掉基础类别的同名方法，以下是个范例：  
type  
   TMyClass = class  
      procedure One;  
   end;  
   TMySubClass = class (TMyClass)   
      procedure One (S: string); overload;   
   end;   
 
请留意，这方法并不需要在基础类别中标注为 overload。然而，如果基础类
别中的这个方法是个虚拟方法，编译程序就会提出这样的警告讯息 : ‘One’
这个方法会把基础类别 ’TMyClass’ 里面的虚拟类别隐藏掉 。为了避免编译程
序提出这个警告讯息，并提供编译程序更精确的指令，让它知道我们想要的
结果，我们可以使用 reintroduce 这个关键词：  
type  
   TMyClass = class  
     procedure One; virtual;  
   end;  
   TMySubClass = clas s (TMyClass)  
    procedure One (S: string); reintroduce; overload;   
   end;   
 
我们可以在 ReintroduceTest 范例项目里面找到这个程序代码， 并用它来做一
些进阶的实验。  
_________________________________________________________________________  
另一个我们常用到 reintroduce 的情形，就是我们想要为组件类别新增一个
筆記   
 249 自定的建构函式 Create之时。因为组件类别都已经有从 TComponent 这个
基础类别继承而来的虚拟建构函式 Create了。  
 
  继承和建构函式  
一如我们看过的， 我们可以用 inherited 这个关键词在子类别中呼叫父代类别
的同名方法 (当然也可以呼叫不同名称的方法 )。对于建构函式也有一样的效
果。在其他程序语言中，像是 C++, C#, 或者 Java，呼叫父代类别的建构函
式是不用特别指名且会要求我们强制进行的 (当我们必须把参数传给父代类
别的建构函式之时 )，而在 Object Pascal 里面，子类别并不一定要呼叫父代
类别的建构函式。  
 
然而，在 大多数情形下，我们主动去呼叫父代类别的建构函式是很重要的。
举个例子，以下就是这种情形，在任何一个组件类别中，当组件的初始化在
TComponent 类别层次已经完成：  
constructor TMyComponent.Create (Owner: TComponent);  
begin   
   inherited Create (Owner);  
   // specific code...  
end;  
 
这是非常重要的，因为组件的 Create是虚拟方法。跟所有的类别相似，解
构函式 Destroy也是个虚拟方法，我们必 须记得透过 inherited 来呼叫父代类
别的同名方法。  
 
还剩下一个问题：如果我们正在建立一个类别，它只继承了 TObject，在它
的建构函式里面，我们还需要呼叫 TObject的建构函式 Create吗?从技术观
点来看，是不需要的，假如该建构函式是空的，并没做什么事。然而，从养
成好习惯的观点来看，无论如何，永远要记得呼叫父代类别的建构函式。然
而如果您对效能有很高的要求，我得承认，这会拖慢速度，虽然影响层面只
有小小的几个毫秒 (microsecond, 不是 minisecond 耶)。 
 
打屁结束， 有几个好理由让我们 使用以上两个技术， 但特别是对入门者来说，
我会建议一定要呼叫父代类别的建构函式，要养成这个好习惯。大家一起来
推广安全的程序写法。  
 
  虚拟与动态方法   
 250 在Object Pascal 里面，有两个方法可以启动延迟绑定。我们可以把一个方法
宣告为虚拟方法，透过 virtual关键词，或者也可以用我们在前面的篇幅介
绍过的，把它宣告成动态方法，透过 dynamic关键词。这两个关键词的用法
都一样，直接把关键词放在方法宣告的最后面，它们的效果也一样。唯一的
不同，是编译程序在实作延迟绑定时的内部机制不同。  
 
虚拟方法是以虚拟方法 列表 (Virtual method table ，也可以简写为 vtable)来实
作的。虚拟方法列表是一个用来储存方法地址的数组。要呼叫虚拟方法时，
编译程序会建立一个程序代码，把程序执行点跳到该对象的第 N个虚拟方
法列表的纪录去。  
 
虚拟方法列表允许方法被快速呼叫。 这个作法主要是把每个子类别所有虚拟
方法的进入点收集起来，即使该方法并没有在子类别里面被重载也一样。这
样一来， 虚拟方法列表里面就可以在整个架构中把每个子类别的虚拟方法快
速的传播 (即使对于没有被重新定义的方法也一样 )。这方法可能会使用许多
的内存，就只为了储 存同一个方法的内存进入点地址。  
 
另一方面，呼叫动态方法则是使用每个方法的唯一代号来进行识别与派发。
搜寻特定函式通常是比单次从列表中寻找会花上更多的时间。 动态方法的优
点，是只会在子类别重载了方法的时候，才会进行方法进入点的传播。对于
庞大且多层的对象架构来说，使用动态方法，而不使用虚拟方法，可以省下
很可观的内存，但速度上的落后并不严重。  
 
从程序人员的观点来看，这两种技术的差异只在内部的表示法，以及不同的
内存与速度而已，排除这几个差异，虚拟方法跟动态方法几乎是完全相同的
技术。  
 
现在我们已经说明了这两种模型的 差异， 让我们强调一下， 在许多的案例中，
应用程序开发人员大多使用虚拟方法， 而非动态方法， 这点也是不可不察的。  
 
  在Windows 系统中的讯息处理程序  
当我们在建立 Windows 应用程序时，有一个特殊要求的方法可以用来处理
Windows 系统讯息。为了这个要求， Object Pascal 提供了另一个关键
词:message 用来定义讯息处理的方法， 这个方法必须是带有一个适当型别的
var参数的程序。 Message这个关键词之后必须跟着一个 Windows 讯息代号，
也就是这个程序要处理的讯息代号。例如以下的程序代码，会 让我们处理一
个用户自定的讯息， 讯息代号是以 Windows 的系统常数 :wm_User 来定义的：   
 251  
type  
 TForm1 = class(TForm)   
    ...  
    procedure WmUser (var Msg: TMessage); message wm_User;  
  end;  
 
程序的名称跟实际的参数型别我们可以自己决定，只要实际的数据结构跟
Windows 讯息的结构相同即可。这个单元文件使用了 Windows API 来引入
一些已经位多种 Windows 讯息定义好的记录型别。这个技术对于 Windows
应用程序的熟手尤其有用，我们都知道 Windows 讯息跟 API函式，但这些
跟其他操作系统真的无法兼容 (像是 iOS, OSX 跟Android)。 
 
把方法跟类别抽象化  
当我们建立一整个架构的类别时，通常很难决定用哪个类别当成基础类别，
假如这个类别不会实际标示进入点，但只会用来表示一些共享的规则。我们
之前介绍过的范例就是一个很好的例子， 以 Animal来做为基础类别， 让 cat, 
dog来做为子类别。我们并不期待为这样的类别建立对象，只让它用以表示
一些特性， 因此把它称为抽象类， 因为这个类别不需要完整的实 作程序代码。
抽象类可以拥有抽象方法，这些方法也不用撰写真正的程序代码。  
 
  抽象方法 (Abstract Methods)  
关键词 abstract是用来宣告只会在子类别当中定义的虚拟方法。透过这个关
键词，已经完整定义了方法，这并不是预先宣告。如果我们企图为这个方法
提供实质程序代码，编译程序可是会发出警告的。  
 
在Object Pascal 里面，我们可以为拥有抽象方法的类别建立实体。然而当我
们试着这样做，编译程序还是会发出警告讯息的 :”企图为拥有抽象方法的 <
类别名称 >建立实体 ”。如果我们刚好在运行时间呼叫了一 个抽象方法，
Delphi会抛出一个运行时间例外。  
_________________________________________________________________________  
C++, Java 跟其他程序语言则有更多限制，在这些语言中，我们根本不被允
许建立抽象类的实体。  
 
您可能会觉得奇怪，为什么我们会想使用抽象方法。原因是使用了多型。如
果TAnimal 类别拥有一个名为 Voice的虚拟抽象方法，每个子类别都可以重筆記   
 252 新定义它。 好处是我们可以透过共通的对象 MyAnimal 来指向每一个动物型
别对象，然后呼叫这个方法。如果这个方法没有在 TAnimal 类别中出现，这
样的呼叫方法可是不会被编译程序允许的， 因为编译程序会执行静态型别检
查。使用共享的 MyAnimal 对象，我们可以只透过 TAnimal 定义的方法来呼
叫。  
 
我们不能呼叫子类别当中才有提供的方法， 父代类别必须至少也得宣告过要
呼叫的方法才行 -也就是抽象方法的一个种类。下一个范例项目， Animals3 ，
就将示范抽象方法跟抽象呼叫错误，以下是在新版范例中这个类别的定义：  
type  
   TAnimal = class  
   public  
      constructor Create;   
      function GetKind: string;   
      function V oice: string; virtual; abstract;   
   private  
     Kind: string;  
   end;   
 
   TDog = class (TAnimal)  
   public  
      constructor Create;   
      function V oice: string; override;   
      function Eat: string; virtual;   
   end;   
 
   TCat = class (TAnimal)  
   public  
      constructor Create;   
      function V oice: string; override;   
      function Eat: string; virtual;   
   end;   
 
最有趣的部分是 TAnimal 类别的定义，它包含了一个虚拟抽象方法 : V oice。
而每个子类别都重载了这个定义， 并加入了一个新的 虚拟方法 :Eat也很值得
一看。这两个不同的功能是指什么呢 ?要呼叫 Voice函式，我们可以用之前
的范例程序中一样简单的写法 : 
Show (MyAnimal.V oice);   
 253  
那我们要怎么呼叫 Eat方法呢 ?我们没办法从 TAnimal类别的对象来呼叫它，
这个指令 : 
Show (MyAnimal.Eat);  
 
会导致编译程序发出错误讯息 : 无法识别的字段  (Field identifier expected)  
 
要解决这个问题， 我们可以使用动态且安全的型别转换来 TAnimal 对象当成
TCat或当成 TDog对象来对待 ，但这样的作法相对繁复，而且容易出错：  
   begin  
       if MyAnimal is TDog then  
         Show (TDog(MyAnimal).Eat)  
       else if MyAnimal is TCat then  
         Show (TCat(MyAnimal).Eat);  
 
这段程序会在稍后的 『安全的型别转换指令』 那个小节里面介绍。 在 TAnimal
类别里面加入虚拟方法的定义，是解决这个问题的传统方法， abstract关键
词的出现强化了这个选择。 上面的程序代码看起来很杂乱，避免这样的程序
代码出现，正是使用多型这个技术的用意。  
 
最后请注意，当一个类别拥有抽象方法时，这个类别通常会被当成抽象类对
待。我们也可以用 abstract关键词来把某个类别特地标注成抽象类，如果我
们觉得有必要的话 (当然，抽象类并不一定要拥有抽象方法 )。重申一次，在
Object Pascal 里面，这个功能不是要阻止我们为该类别建立实体，所以这程
序语言中，宣告没有用的抽象类是相当罕见的。  
 
  弥封类别 (Sealed Classes) 跟最终方法 (Final Methods)  
如同前面 介绍过的， Java预设对于延迟绑定 (或说是虚拟方法 )有着非常动态
的功能。为了这个理由， Java提出了一个概念，也就是无法再被继承的类别
(弥封类别 )，以及我们无法在子类别中加以重载的方法 (最终方法，或者称为
非虚拟方法 )。 
 
我们无法再从弥封类别衍生出子类别。 这对于我们要发布不带原始码的组件
时非常需要，或者我们需要发布限制开发人员修改我们组件功能的函式库
时，也是非常重要的。这功能的原始设计也是为了提升运行时间的安全性，
但这些功能我们在完全编译的程序语言，像 Object Pascal 里面，就不需要。  
最终方法 是我们无法在衍生类别中加以重载的方法。重申一次，这个概念在 
 254 Java(在Java里面所有方法预设都是虚拟方法，最终方法会很明显的得到优
化)里面很有帮助，也被引入到 C#里面，因为 C#的虚拟函式需要精确标注，
所以相对重要。因此同样的概念也被加入到跟 C#很相似的 Object Pascal 里
面来了，但并不常被使用。  
 
以下是弥封类别的范例程序代码，请大家留意其语法：  
type  
   TDeriv1 = class sealed (TBase)  
      procedure A; override;  
   end;  
 
企图从这个类别衍生子类别的话， 编译程序会发出错误回报 : “无法延伸弥封
类别 TDeriv1”。以下则是最终方法的语法：  
type  
   TDeriv2 = class (TBase)  
      procedure A; override; final;  
   end;  
 
从这个类别衍生子类别时，如果企图重载 A方法，也会得到编译程序的错
误回报:”无法重载最终方法 ”。 
 
安全的型别转换指令  
一如稍早的篇幅所介绍的， Object Pascal 的子类别型别兼容性规则让我们可
以把子类别当成父代类别来使用， 然而不能把父代 类别直接当成子类别来使
用。  
 
现在我们假设 TDog类别拥有一个 Eat方法，这个方法在 TAnimal 类别里面
并没有出现过。如果 MyAnimal 变量指向了 TDog类别的对象，那我们要怎
么呼叫 Eat方法呢 ? 如果我们试着把变量直接转型成另一个类别，是会发生
错误的。透过指令来进行的强制转型，我们可能会引发一个运行时错误 (或
者更糟，可能出现不预期的内存重复写入问题 )，因为编译程序无法判定该
对象到底是哪种型别，且我们到底想呼叫哪个存在的方法。  
 
为了解决这个问题，我们使用了运行时间型别信息 (Run -Time Type 
Information, 简称 RTTI)。因为每个对象在运行时间一定都知道自己的型别，
以及它自己的父代类别。我们就直接询问对象这项信息，可以透过 is这个
指令，或者使用 TObject类别的一些方法。 Is这个运算符号的参数是一个对 
 255 象跟一个类别型别，会回传布尔值：  
if MyAnimal is TDog then   
  ...  
 
这个  is判别式如果回传 true，就表示 MyAnimal 对象目前是指向一个 TDog
类别的对象，或者是从与 TDog兼容的类别衍生出的型别。这代表如果我们
检查存在 TAnimal 变量里的对象 是TDog时，回传值就会是正确的。换句话
说，如果回传值是 true，我们就可以安全的把这个对象 (MyAnimal) 指派给
TDog型别的变数了。  
_________________________________________________________________________  
is这个运算符号实际上的实作方式，是由 TObject的InheritsFrom 方法所提
供的。所以我们可以用在 MyAnimal 对象上使用同样的判别式，写成
MyAnimal.InheritsFrom(TDog) 。直接使用这个 方法的原因，是因为这个方
法也可以被类别参考跟其他用途的型别所使用，且这些型别有可能不支持
is运算符号。  
 
透过这个判断式，我们可以确定在 MyAnimal 里面的对象是 TDog类别的对
象了，所以我们可以直接用型别强制转换 (通常直接进行转换会有安全疑虑，
但我们已经确认了型别是相同的，所以可以这样做 )，写成以下的范例程序
代码 : 
 if MyAnimal is TDog then  
 begin   
   MyDog := TDog (MyAnimal);   
   Text := MyDog.Eat;  
 end;  
 
相同的动作也可以直接用另一个跟型别转换相关的运算符号  as 来达成。这
个运算符号可以把对象进行转换， 但只会在要求转换的对象兼容于想转换成
为的类别时才转换。 As运算符号的要求的参数是一个对象，以及要转换成
为的类别，回传的值则是转换成新型别之后的对象。我们可以简单的写成这
样的程序代码：  
MyDog := MyAnimal as TDog;  
Text := MyDog.Eat;   
 
如果我们只想呼叫 Eat函式，我们也可以使用一个简单的写法 : 
(MyAnimal as TDog).Eat;   
 
这个表达式的回传结果，会 是一个 TDog型别的对象，所以您可以透过这个筆記   
 256 对象来使用 TDog类别的任何方法。在传统的型别转换跟 as所呈现的型别
转换之间的不同，是透过 as进行型别转换的时候，会先进行该对象的型别
兼容性检查，如果要转换的型别跟该对象不兼容，系统就会发出例外警告，
这个例外是 EInvalidCast( 我们在下一章里面会介绍 )。 
_________________________________________________________________________  
对照一下，在 C#里面的 as表达式在型别不兼容的时候，会 传回 nil，如果
进行直接强制转型，发生不兼容的时候，则会产生例外事件。所以 C#跟
Object Pascal 的as表达式在回传值上面刚好是相反的。  
 
为了避免这个例外，请先使用 is运算符号进行判别，如果型别是兼容的，
就可以直接做强制转型 (事实上好像没有必要把 is跟as依序使用，因为这么
一来相同的型别测试会做两次，所以通常不是使用 is，就是使用 as，很少两
个并起来一起用的 ): 
if MyAnimal is TDog then   
  TDog(MyAnimal).Eat;   
 
两种型别转换的运算符号在 Object  Pascal里面都很有用， 因为我们通常会想
要撰写通用的程序代码，可以套用在不同的组件中，来进行相同型别检查，
甚至是不同型别之间的检查。举例来说，当一个组件被当做参数传递到一个
处理事件的方法时，会是使用通用的数据类别 (TObject) 来传的。所以我们常
常要先把型别转换回该组件的真正型别：  
procedure TForm1.Button1Click(Sender: TObject);  
begin   
   if Sender is TButton then  
     ... 
end;   
 
这是一个很常见的技术， 我也在很多之后的范例里面都会使用 (事件会在第
十章里面介绍到 )。 
 
这两个型别转换的运算符号， is跟as，功能是非常强大的，我们也可能会想
要考虑在基本的程序撰写中用到它们。就因为它们真的很强大，所以在使用
的时候要记得适当的在特定情形下规范使用的方法。 当我们需要引入多个类
别来解决复杂的问题时，记得先使用多型的技术。只有在特别的情形下，多
型才无法被单独使用， 此时我们就只能试着透过型别转换运算符号来解决它
了。  
 
 筆記   
 257 __________________________________________________ _______________________  
型别转换运算符号在效能上会有明显的负面影响，因为它得把整个类别的
族谱跑一次，才能确实判别型别转换是否合法。跟我们介绍过的技术对照
一下，虚拟方法的呼叫也需要进行内存搜寻，但相对快的多了。  
 
可视化窗体继承  
继承这个技术并不只用在函式库的类别，或者我们自己写的类别，但在整个
以Object Pascal 为中心的 IDE环境里面，这个技术是无所不在的。一如我
们所见的，当我们在 IDE里面建立一个窗体的时候，我们其实是建立了一
个TForm类别的实体。所以任何可视化应用程序都 是建立在继承这个技术
之上的。因此我们在写程序的时候，大多是在写一些简单的事件处理程序。  
 
然而，对于比较有经验的开发人员来说，还比较不知道的作法，是我们可以
从我们已经写好的窗体再衍生出另一个窗体， 这个功能通常被称为视觉窗体
继承 (这也是 Object Pascal 开发环境中相当奇特的一部分 )。 
 
这个功能有趣的地方，是你可以直接看到继承的威力，而且可以直接了解他
的规则。这既有用又实用吧 ?也是，这大多时候会跟我们正在建立的应用程
序类型有关。如果应用程序里面有多个窗体，其中部分窗体可能很相似 (外
表很相似、功能也很相 似)，这样一来我们就可以把这些相似的窗体做成一
个基础窗体，事件处理程序也放在基础窗体里面，然后每个确切的窗体再从
这个基础窗体衍生出来制作。另一个类似的情景，是使用可视化窗体继承的
技术来为特定客户进行客制窗体，但不复制任何程序代码 (这也是第一时间
使用继承这个技术的核心理由 )。 
 
我们也可以使用可视化窗体继承来为同一个应用程序在不同操作系统的外
观进行客制化跟窗体的元素 (例如从手机到平板 )，不复制任何程序代码，或
者窗体的定义，只从标准的窗体为客户衍生出一个特定的版本。请记得，视
觉继承的主要优点，是我们可以稍后再修 改原始窗体，且自动更新所有的衍
生窗体。这是在 OOP语言里面广为人知，关于继承的优点。但也有一个正
面的副作用：多型。您可以为基础窗体加入一个虚拟方法，然后在衍生的窗
体之中把它重载。然后我们可以引入两个窗体，然后呼叫每个窗体的这个方
法。  
_________________________________________________________________________  
以相同元素建立窗体的另一个方法是透过 frame。 这作法是把一些原本放在
窗体上的视觉组件改为放在 frame上面。在设计时间，我们可 以同时处理
两个版本的窗体。然而在视觉窗体继承中，我们是定义了两个不同的类别，筆記  
筆記   
 258 一个是父代类别，另一个是衍生类别。但使用 frame十，我们则是新制作
了一个 TFrame的衍生类别，以及用来承载 TFrame的窗体类别。  
 
  从基础窗体进行继承  
一旦我们对继承的内涵有了清楚的认知， 管理视觉窗体继承的规则其实就相
当简单。基本上，衍生的子窗体跟父代表单会有同样的视觉组件。我们不能
移除父代表单上面的组件，不过我们可以把该组件 (如果该组件是个视觉组
件)设定成隐形。重要的是我们可以很容易更改继承后的组件属性。  
 
请注意，如果 我们更改了衍生窗体上组件的属性，之前在父代表单中对相同
属性的修改，在衍生窗体中都将失去作用。变更组件的其他属性，则仍会影
响衍生窗体中各组件的视觉表现。我们可以透过使用对象查看器上面的
Revert to Inherited 这个选单指令，让两个属性的内容重新一致化。这样的效
果也可以透过手动把两个属性的内容修改成一致之后， 再重新编译程序来达
成。改变多个属性之后，我们仍然可以透过 Revert to Inherited 这个选单指令
来把被变更的值回复成跟父代表单中的属性设定相同。  
 
除了继承组件， 新的窗体也继承了基础窗 体的所有方法， 包含事件处理程序。
我们可以在衍生窗体中新增，也可以重载已经存在的事件处理程序。  
 
为了示范视觉窗体继承的效果，我建立了一个简单的范例，名为
VisualInheritTest 。我会逐步介绍如何编译这个项目。首先，建立一个新的行
动应用程序项目，然后在主窗体中加入两个按钮。然后选择 File->New，接
着在 New项目的对话窗口中选择 ”Inheritable Items” 分页 (请参考图 8.3)。以
下是我们可以从窗体来选择想要继承的项目。  
_______________________________ __________________________________________  
  
 
 
  
 
 
 
 
 
 
 圖8.3: New項目
對話視窗 讓我們
可以建立一個衍
生表單  
 
 259 新的窗体会同样有两个按钮，以下是该窗体最开头的文字描述：  
inherited Form2: TForm2  
  Caption = ‘Form2’  
  ...  
end  
 
且以下是该类别刚建立时的宣告内容， 我们可以看到其基础类别不是我们常
见的 TForm，而是一个实际的基础类别窗体了：  
type  
 TForm2 = class(TForm1)  
  private   
     { Private d eclarations }  
  public  
     { Public declarations }  
  end;  
 
请注意 inherited 关键词在文字描述的使用， 还有窗体实际上是拥有其他组件
的，只是它们是被定义在基础类别里面而已。如果我们改掉了其中一个按钮
的文字，并且加上一个新的按钮，窗体的文字描述就会变成这样：  
inherited Form2: TForm2  
   Caption = 'Form2'  
   ... 
   inherited Button1: TButton  
     Text = ' Hide Form'  
   end 
   object Button3: TButton  
      ... 
      Text = 'New Button'  
      OnClick = Button3Click  
   end 
end  
 
只有属性的值不同的项目被列出了， 因为其他的项目都是从基础窗体直接继
承而来的。  
 
图8.4里面的第一个窗体中，每个按钮都有 OnClick事件处理程序，第一个
按钮的处理程序会呼叫第二个窗体的 Show方法，让它显示出来。第二个按
钮则是简单的把窗体给隐藏起来。   
 260  
_________________________________________________________________________  
  
  
 
 
  
 
 
 
 
在衍生窗体中发生了什么事？我们首先要改变 Show按钮的规则，让它变成
一个隐藏按钮。这样就不会执行基础窗体的事件处理程序了 (所以我也把预
设呼叫的 inherited 程序代码给批注掉了 )。相反地，我在 Hello按钮上加入
了第二个讯息给基础类别建立出来的窗体，这个函式只留下了 inherited 呼
叫：  
procedure TForm2.Button1Cl ick(Sender: TObject);  
begin   
  // inherited;  
  Hide;   
end;   
 
procedure TForm2.Button2Click(Sender: TObject);   
begin   
   inherited;   
   ShowMessage ('Hello from Form2');   
end;   
 
记得这跟衍生方法的差异，衍生方法可以使用 inherited 关键词来呼叫衍生  
类别中的同名方法， 在事件处理程序里面使用 inherited 关键词则会呼叫基础
类别中对应的同名方法。  
 
当然，我们也该把基础窗体中的每个方法视为子窗体的方法，并且视需要自
由呼叫它们。这个范例允许我们了解一些可视化窗体继承的功能，但要真正
看到它的威力，我们需要多看一些复杂的，真实世界的范例，而不要被绑死
在书上喔。  圖8.4: 
Virtual InheritT est
範例在執行階段的兩
個表單  
 
 261 09:例外处理  
 
在我们开始继续介绍 Object Pascal 类别的其他功能之前，我们需要先聚焦
在处理错误条件的特定对象群组上，这个错误条件称之为例外。  
 
例外处理的含意，是要透过加入一致性、简单的处理软件或硬件错误的能
力，让程序更为自动化。一个程序可能在这样的错误发生后还继续执 行，
也可能安全的结束掉，让使用者能够在结束之前储存一些数据。例外事件
允许我们把错误处理的程序代码从一般程序代码分离开来。这样我们就不
用在程序代码之间交错一般程序功能跟错误处理的程序代码了。这样我们
的程序代码可以更精简、不凌乱，把跟实际程序目标不相关的程序代码拢
在一起。  
 
另一个好处，是例外定义了一个统一、放诸四海阶准的错误回报机制，这
个机制也同时用在组件函式库里面。在运行时间中，系统会在出错的时候
发出例外事件。如果我们的程序代码已经适当处理了例外事件，我们的程
序就会被通知，也会试着解决这个错误。反之，这个例 外会被传递到它所
呼叫的程序代码，一层一层扩散。最终，如果我们的程序代码里面没有处
理这个例外，系统通常会处理它，轮到系统处理时，画面上就会显示一个
标准的错误讯息，并且试着继续执行程序。在大多数的情形下，我们的程
序都是在例外处理区外面运作的，发出了例外讯息会使程序终止。  
 
在整个 Object Pascal 的例外处理机制当中，是建构在五个关键词之上的 : 
 
 try 界定一个程序代码保护区的开始  
 except 界定这个程序代码保护区的结束，并宣告开始进入例外处理的
程序代码  
 on 标示每个特定的例外处理叙述句，与特定的 例外进行连结，每个 on
的叙述句语法都是 on 例外型别  do 叙述句  
 finally 是用来标示不论如何都要被执行的程序代码，即使例外发生也
一样。  
 Raise是用来触发例外的叙述句，它的参数则是一个例外类别的对象 (在
其他语言中，使用的语法则是  throw)  
 
以下是一个简单的比较表，用来比较 Object Pascal 跟其他以 C++语法为基 
 262 础的程序语言 (像是 C#跟 Java)处理例外的语法 : 
try   try 
except on  catch  
finally   finally  
raise   throw  
 
Try-Except 区块 
让我们从一个相对简单的 try-except例子开始 (这是 ExceptionsTest 范例项目
的一部分 )，以下则是一个通用的例外处理区块：  
function DividePlusOne (A, B: Integer): Integer;  
begin  
   try 
     Result := A div B; // raises exception if B equals 0   
      Inc (Result);   
   except   
     Result := 0;   
   end;  
   //more   
end;   
_________________________________________________________________________  
当我们在除错模式下执行一个程序时，除错程序会默认在例外发生的时候
停下程序，即使我们已经在程序中写好了异常处理程序也一样。这也是我
们通常乐见的，当然，因为我们并不知道例外会在什么时候发生，然后才
能一行行的看着程序代码执行。如果我们想让程序在例外发生时适当的处
理它，然后看看一般使用者会看到的画面，我们可以用 IDE里面的”以非侦
错模式执行 ”的指令来执行程序。  
 
并不是说，要例外闭嘴，然后把回传值设定为 0这样是对的，但这个程序代
码已经够简单，我们可以了解程序撰写情境的核心机制了。以下是事件处理
程序用来呼叫该函式的程序代码 : 
var  
   N: Integer;   
begin   
    N := DividePlusOne (10, Random(3));  
    Show (N.ToString);  
 
就像我们看到的，程序代码使用了一个随机产生的数值，因此当我们点击按筆記   
 263 钮的时候，我们可以处于合法的情形下 (2乘以 3以外的值 )或者处于错误的
情形下。以下是可能发生的两种不同程序流程：  
 如果 B不是 0，程序会进行除法计算，然后把结果加一，最后忽略例外
处理区块。  
 如果 B是0，程序执行除法的时候会发生例外，在发生例外之后的其他
程序代码会自动被跳过 (在这个范例里面只有一行程序会被跳过 )，直接
跳到 try-except区块的第一行继续执行。在进入例外程序区之后，程序
就不会再回到原来的程序代码了， 但会接着再把例外程序区里面的所有
程序代码都执行完毕。  
 
我们可以用一个方法来描述这个例外模型， 就是它遵循的工作目标是不会再
回头。在发生错误的情形下，试着处理错 误情况，并回到导致这个错误发生
的程序代码，是很危险的作法。在这个情形下，程序可能已经进入了未预期
的状况。例外很明确的改变了程序执行的流程，跳过了接下来的程序代码，
回复到错误未发生前的状态，直到适当的错误处理程序代码出现。  
 
上面的程序代码包含了一个很简单的例外程序区，但没有包含 on这个叙述
句。当我们需要处理多种不同的例外情形时 (或者多种例外类别型别 )，或者
想要存取被触发、传递到例外程序区的例外对象，我们就需要有一个或多个
的叙述句：  
function DividePlusOneBis (A, B: Integ er): Integer;  
begin  
  try 
     Result := A div B; // error if B equals 0  
     Result := Result + 1;   
   except  
       on E: EDivByZero do  
       begin   
          Result := 0;   
          ShowMessage (E.Message);  
       end;  
  end;   
end;   
 
在例外处理的叙述句中，我们拦截到 EDivByZero 例外，这是由 RTL(运行时
间函式库 )所定义的。 在 RTL里面定义了许多这样的例外型别 (像这里所介绍
的除以 0的例外，或者错误的动态型别切换都是其中之一 )，也有一部分例
外型别是由系统所定义 (例如内存不足的例外 )， 或者组件错误 (像是索引值错 
 264 误)。所有这些例外的类别都是从例外的基础类别 Exception 衍生而来的，在
这里面提供了最低限度的功能，例如 Message 属性，在上面的范例程序中我
们就用到了这个属性。 这些类别也依循一些逻辑结构组成了一个不小的类别
架构。  
_____________________ ____________________________________________________  
请注意，在 Object Pascal 里面一般只要是类别都会用 T这个字母开头来命
名，但例外类别是这个规则中的例外，它们是以 E这个字母开头来命名的。  
 
  例外类别架构  
以下的列表是 RTL核心例外类别里面的一部分，这些例外类别都定义在
SysUtils 这个单元文件里面 (大多数其他的系统函式库还另外会在新增自己
的例外型别 ): 
Exception  
       EArgumentException  
         EArgumentOutOfRangeException  
         EArgumentNilException  
       EPathTooLongException  
       ENotSupportedException  
       EDirectoryNotFoundException  
       EFileNotFoundException  
       EPathNotFoundException  
       EListError  
       EInvalidOpExce ption  
       ENoConstructException  
       EAbort  
       EHeapException  
         EOutOfMemory  
         EInvalidPointer  
       EInOutError  
       EExternal  
         EExternalException  
         EIntError  
           EDivByZero  
           ERangeError  
           EIntOverflow  
         EMathError  
           EInvalidOp  筆記   
 265            EZeroDivide  
       EOverflow   
       EUnderflow  
     EAccessViolation  
     EPrivilege  
     EControlC  
     EQuit  
   EInvalidCast  
   EConvertError  
   ECodesetConversion  
   EV ariantError  
   EPropReadOnly  
   EPropWriteOnly  
   EAssertionFailed  
   EAbstractError  
   EIntfCastError  
   EInvalidContainer  
   EInvalidInsert  
   EPackageError  
   ECFError  
   EOSError  
   ESafecallException  
   EMonitor  
     EMonitorLockException  
     ENoMonitorSupportExcepti on 
   EProgrammerNotFound  
   ENotImplemented  
   EObjectDisposed  
   EJNIException  
_________________________________________________________________________  
我不知道大多数人会怎么做，但我自己仍然会先把实际的使用情境中可能
遇到的奇怪例外做个设想，像是 EProgrammerNotFound 这样的例外。  
 
现在我们已经介绍过了核心的例外类别架构，我们可以在先前 的except -on
叙述句上面多加一点信息了。这些叙述句会一一被比对，直到系统找到跟目
前发生的例外相符的例外类别。目前所使用的比对规则是检查其型别兼容
性，这个主题我们在前一章已经介绍过了：例外对象会跟其所属的类别以及
所有父代类别兼容 (就像 TDog对象会兼容于 TAnimal类别 )。 筆記   
 266  
这表示我们可以提供多个例外处理型别是跟目前发生的例外相符的。 如果我
们想要使用更精确相符的规则来处理该例外的话 (在类别架构中比较末端的
例外类别 )，我们就需要更精确的列出要处理的例外类别 (列的越末端越能精
确命中特定的例外 )。当然我们 也可以写一个异常处理程序，直接使用
Exception 这个型别，这样所有的例外发生的时候都会由它来处理。以下就
是在一个区块中包含两个处理程序的程序范例：  
function DividePlusOne (A, B: Integer): Integer;  
begin  
   try 
     Result := A div B; // error if B equals 0 Result := Result + 1;   
   except  
     on EDivByZero do  
     begin  
        Result := 0;  MessageDlg (‘Divide by zero error’,   
         mtError, [mbOK], 0);  
     end;  
     on E: Exception do  
     begin  
        Result := 0; MessageDlg (E.Message,   
         mtError, [mbOK], 0);  
     end;  
   end; // end of except block  
 end;  
 
在上面这段 程序代码里面，同一个 try区块当中，包含有两个不同的异常处
理程序。我们可以在同一个 except区块当中写入任意数量的异常处理程序，
在例外发生的时候，它们会被系统一一比对，就像前文所述。  
 
也请记得，为每一种可能发生的例外都写一个处理程序通常并不是好主意。
最好还是把一些我们不知道的例外留给系统。 预设的异常处理程序通常会把
该例外的类别名称用讯息窗口加以显示，然后回复该程序的正常运作。  
________________________________________________________________ _________  
我们也可以透过实作 Application.OnException 这个事件的处理程序来把一
般异常处理程序替换掉。例如把例外的讯息存到 文件里面，而不要显示给
用户看。  
 
 筆記   
 267   触发例外  
我们在 Object Pascal 里面会遇到的绝大多数的例外，都是由系统所建立的，
但当我们发现在运行时间当中有不合法或者不连续的资料时， 我们也可以在
我们自己的程序代码里面触发例外。  
 
在大多数的情形下，我们需要先定义我们自己的例外型别，好让我们需要触
发时可以用到。我们可以用以下的程序代码简单的建立一个新的例外型 别，
只需要从预设的例外基础型别 Exception 衍生一个即可：  
type  
  EArrayFull = class (Exception);   
 
在绝大多数的案例中，我们不用在新的例外类别中加入任何方法，只需纯粹
宣告一个新的例外类别即可。  
 
用到这个例外型别的情境，可能会是在一个方法试着在数组中加入元素时，
当数组已经满了，而触发这个例外。实际上的写法只需建立例外对象，然后
把它用 raise关键词传递即可：  
if MyArray.Full then  
 raise EArrayFull.Create ('Arra y full');   
 
这个 Create方法 (从Exception 类别继承而来的 )要求一个字符串作为参数，
来描述该例外的情形让使用者知道。  
_________________________________________________________________________  
我们不用担心这个例外对象要怎么被释放，因为它会自动被例外处理机制
给删除掉。  
 
Raise关键词还有一种情形下会使用到。 就是在我们自己写的 try-except区块
当中，当我们所写的程序代码并没有真的抓到该例外，这时候该例外处 理区
块里面的程序代码应该都不会派上用场， 此时我们就应该把这个例外再次触
发，让系统去处理，这时我们只需要执行 raise，不用参数了。这个动作我
们称为再次触发 例外。  
 
  例外与堆栈  
当程序触发了一个例外，而目前的程序代码无法处理它，那么在我们方法或
函式堆栈里面会发生什么事呢？程序会在已经触发的所有函式或方法堆栈
当中一层一层的搜寻可以处理这个例外的处理程序。 这表示程序代码会从当筆記   
 268 时正在执行的程序代码里面跳脱，不会再继续执行剩下的程序代码。要了解
其中的工作原理， 我们可以用侦错程序或者在目前执行的程序代码里面加一
些简单的输出值。在下一个范例项目， ExceptionFlow 里面，我选择以第二
种方式来做示范。  
 
举例来说，当我们按下 ExceptionFlow 项目里的窗体上面的 Raise1按钮，就
会触发一个没有被处理的例外，所以程序代码的最后一部分并不会被执行
到：  
procedure TForm1.ButtonRaise1Click(Sender: TObject);   
begin   
   // unguarded call  
  AddToArray (24);  
  Show ('Program never gets her e');  
end;   
 
请注意，这个方法呼叫了 AddToArray 程序，这个程序将会触发例外。当这
个例外有被处理时，程序的流程会从该处理程序之后继续下去，而不是从例
外发生的程序代码继续下去。以下面这个方法来看 : 
procedure TForm1.ButtonRaise2Click(Sender: TObject);   
begin   
   try  
      // this procedure raises an exception  
      AddToArray (24);  
      Show (' Program never gets here');   
   except  
      on EArrayFull do  
         Show ('Handle the exception');  
   end;   
   Show ('ButtonRaise1Click call completed');  
end;   
 
最后一行的 Show会在例外被处理完毕以后继续执行下去，第一个 Show则
永远不会有被执行到的机会。我建议在执行这个程序之前，先把程序代码做
些修改，做些对应的实验，好帮助您能够理解例外被触发 时，程序流程是怎
么运作的。  
_________________________________________________________________________  
如果我们写来准备处理例外的程序代码跟该例外发生的位置不同，如果能
够确切知道该例外是发生在哪个方法会是很有帮助的。虽然的确有方法可筆記   
 269 以在例外被触发的时候，取得函数调用堆栈的信息，但这是比较进阶的主
题，我并不打算在此介绍。在绝大多数的案例中， Object Pascal 的开发者会
依靠第三方组件跟函式库 (像是 Jedi组件函式库里面的 JclDe bug、
MadExcept ，或者 EurekaLog) 来取得这个信息。  
 
Finally 区块 
例外处理还有第四个关键词，我们之前提到过，但还没有使用到，它就是
finally。Finally区块是用来定义一些一定要被执行到程序代码 (通常是用来做
清理的程序 )。事实上，在 finally区块里面所撰写的程序代码，不管是否有
例外事件被触发，都一定会被执行到。而一般的程序代码则是写在 try跟
finally之间，只有在没发生例外的时候或者发生了例外且被妥善处理了，这
些程序代码才会被执行。换句话说，不管有没有发生例外事件， finally区块
的程序代码都会被执行到。  
 
以下面这个方法为例 (它是 ExceptFinally 范例项目的一部分 )，它会执行一些
耗时间的指令，并在窗体的标题上显示它当时的状态：  
procedure TForm1.btnWrongClick(Sender: TObject);   
var  
   I, J: Integer;  
begin   
   Caption := 'Calculating';  
 
   J := 0; // long (and wrong) computation...   
   for I :=  1000 downto 0 do   
      J := J + J div I;   
 
   Caption := 'Finished';  
   Show ('Total: ' + J.ToString);  
 end;  
 
因为在这个算法里面有一个错误 (在我们可以改动的变量值当中，包含了 0，
所以会发生除法除以 0的错误 )，程序会被中断，但并不会重设窗体的标题。
这种情形就需要 try-finally区块来解决了：  
procedure TForm1.BtnTryFinallyClick(Sender: TObjec t);  
var  
   I, J: Integer;  
begin    
 270    Caption := 'Calculating';  
   J := 0;  
   try 
     // long (and wrong) computation...  
     for I := 1000 downto 0 do  
       J := J + J div I;  
     Show ('Total: ' + J.ToString);  
   finally   
     Caption := 'Finished';  
   end;  
end;   
 
当这个函式被执行的时候，它永远都会记得把状态给重设，不管是否有发生
任何一种例外。这个版本的函式唯一的缺点，应该就是它没有真的处理例外
事件吧。  
 
  Finally跟例外  
够奇怪的吧， 在 Object Pascal 里面， try区块后面只能跟着 except或者 finally
区块，但却不能两者一起出现。假设我们想同时处理两种区块，通常只能把
两种 try区块互相包含着使用，在里面那层 try区块里面使用 finally，而在外
层的 try区块使用 except，或者反过来用，要视当时的情况而定。以下是
ExceptFinally 范例中的第三个按钮的事件处理程序 : 
procedure TForm1.BtnTryTryClick(Sender: TObject);   
var  
   I, J: Integer;  
begin   
   Caption := 'Calculating';  
   J := 0;  
   try  
      try 
         // long (and wrong) computation...  
         for I := 1000 downto 0 do  
            J := J +  J div I;  
         Show ('Total: ' + J.ToString);  
      except  
         on E: EDivByZero do  
         begin   
 271             // re -raise the exception with a new message  
            raise Exception.Create ('Error in Algorithm');   
         end;   
     end;   
   finally  
      Caption := 'Finished';  
   end;  
end;   
 
真实世界的例外  
例外对于在大范围 (也就是说并不是只针对单一程序，而是整个大架构的一
部分 )的程序设计中进行错误回报以及错误处理，是个很棒的机制。通常我
们不应该完全依赖例外机制，而不仔细的进行区域错误条件检查 (当然有些
开发人员是喜欢这样用的 )。举例来说，如果我们不确定特定档名是否可以
使用，我们就应该在开启 文件之前先检查一下 文件是否存在，而不要依赖例
外发生时才透过例外处理机制来处理 文件不存在的情形。然而，如果在写档
之前检查是否有足够的磁盘空间，就不是那么实用了，因为磁盘空间不足的
情形并不常发生。  
 
所以我们应该在 程序撰写的时候，先自行处理常发生的问题，然后把不常发
生的问题留给例外处理机制。当然常发生与不常发生之间的界线很模糊，端
赖程序人员的判断，因此不同程序人员也会有不同的方法来加以界定。  
 
我们应该持续的在不同的类别跟模块之中使用例外处理， 让例外事件可以在
不同的类别跟模块之间互相传递。回传错误码的作法相当乏味，且使用例外
更容易比对错误情形。在组件或函式库的类别中触发例外，比在事件处理程
序里面触发更为常见。我们可以不用再写大量的程序代码，而直接使用例外
处理来替代这些程序代码。  
 
在日常的程序代码中越来越常见，且格外 重要的是使用 finally区块来预先
保护程序的资源免于因例外发生而失控。 我们应该永远在使用外部资源的程
序代码当中使用 finally来避免万一例外发生而导致资源发生内存泄漏。我
们每当需要对 文件做启闭、对网络进行联机、断线，在单一区块中建立、释
放某些资源时，我们就应该派 finally区块上场了。  
 
最后， finally区块让我们在即使万一发生例外事件时，也能够使程序保持稳
定，这样用户就可以继续使用，或者还能依序 (万一有很明确的问题发生时 ) 
 272 的关闭应用程序。  
全局例外处理  
如果例外是由一个事件处理程序所触发，停止了 标准的执行流程，此时如果
没有找到对应的例外处理程序， 整个程序也会停止运作吗 ? 在文本模式应用
程序或者一些特别用途的程序结构里的确会这样。 但大多数的窗口应用程序
(包含使用 VCL或FireMonkey 架构的窗口应用程序 )则有全局的讯息处理循
环，会把整个程序代码包在一个 try-except区块里面，所以如果有未被处理
的例外被触发，就会在这里被捕捉到。  
 
在例外被捕捉到的时候，就要看函式库怎么处理它了，在这里我们仍然可以
写一个全局的异常处理程序来处理，或者显示例外事件的讯息。尽管细节处
理规则可能稍有不同，但这个大原 则在 VCL跟FireMonkey 则是都一样的。
在前一个范例中，您会在例外事件发生时看到一个简单的错误讯息显示。  
 
如果您想要改变这个规则，可以为全局的 Application 对象建立 OnException
事件的处理程序。 虽然这个动作的归属更偏向视觉函式库以及应用程序的事
件处理，它也还是跟例外处理相关，所以我们在这个章节也加以介绍。  
 
我已经把前一个例子做成范例程序，名为 ErrorLog，现在我们再来它的主窗
体上面加一个新的方法 : 
public  
   procedure LogException (Sende r: TObject; E: Exception);   
 
在OnCreate 事件处理程序中，我加入了下面这个程序代码，把这个方法跟
全局的 OnException 事件做了绑定，在这里面我们就可以来实作全局的异常
处理程序了 : 
procedure TForm1.FormCreate(Sender: TObject);   
begin   
   Application.OnException := LogException;  
end;  
 
procedure TForm1.LogException(Sender: TObj ect; E: Exception);   
begin   
   Show('Exception ' + E.Message);  
end;  
 
_________________________________________________________________________   
 273 我们会在下一章里面介绍怎么把方法的指标指派给一个事件 (就像我们刚
在前一个程序片段刚介绍过的 )。 
 
透过新的方法来处理全局例外事件之后， 这个程序会在未被处理的例外发生
时，直接显示错误讯息，不会把程序停止下来了。  
 
例外与建构函 式 
在例外这个主题上还有一个明显比较进阶的问题， 就是当例外发生在一个对
象的建构函式执行时。 大多数的 Object Pascal 程序人员都不知道在这个情形
下，该对象的解构函式就会被自动呼叫。  
 
这个作法非常重要，我们必须记住，因为这种情形表示解构函式会在对象初
始化进行到一半的时候就被呼叫。 假设解构函式中本来就已经预备着把内部
对象释放掉， 也是因为我们一开始已经假设在建构函式中已经把这些内部对
象建立好了，此时就可能在解构函式中试图释放还没有建立的这些内部对
象，这种情形着实是很危险的 (这表示可能会在第一个例外事件还没 被处理
好之前，就又诱发了第二个例外事件 )。 
 
这也同时指出了在建立对象的时候，最好使用 try-finally区块来确保安全，
因为 try-finally可以自动被编译程序加以保护。所以如果建构函式执行中发
生了例外，就可以不用释放该对象了。这是为什么标准的 Object Pascal 程序
模式会用以下这种写法来保护一个对象：  
AnObject := AClass.Create;  
try  
   // use the object...  
finally   
   AnObject.Free;  
end;  
________ _________________________________________________________________  
类似的情况也会发生在 TObject 类别的两个方法 : AfterDestruction 跟
BeforeConstruction 上面。这两个方法是为了与 C++兼容而提供的虚构建构
函式与虚构解构函式 (但在 Object Pascal 当中倒是很少被使用到 )。如果在
AfterConstruction 跟BeforeDestruction 被呼叫的时候发生例外情况，就会跟
一般的建构函式、解构函式 的情况有些相似。  
 
请注意，当我们在支持 ARC功能的 Object Pascal 编译程序中开发，我们是
不需要使用 finally区块的，因为在这种情形下，对象的内存会自动被释放，筆記  
筆記   
 274 我们会在第 13章里面介绍。假设我们已经适当的在解构函式中适时的释放
对象时显示了错误。我们可以更深入的用实例来说明可能的问题，包含如何
处理，以及如何修复。假设我们有一个类别，内部包含一个字符串列表，而
我们写这以下的程序来建立与释放这个类别 (以下是 ConstructorExcept 范例
项目的一部分 ): 
type  
 TObjectWithLi st = class  
  private   
     FStringList: TStringList;  
  public  
     constructor Create (V alue: Integer);  
     destructor Destroy; override;  
  end;   
 
constructor TObjectWithList.Create(V alue: Integer);   
begin   
   if V alue < 0 then  
    raise Exception.Create( 'Negative value not allowed');   
   FStringList := TStringList.Create;  
   FStringList.Add('one');  
end;  
 
destructor TObjectWithList.Destroy;  
begin  
   FStringList.Clear;  
   FStringList.Free;  
   inherited;  
end;   
 
乍看之下，这两个程序代码没有什么不同。建构函式会配置子对象，而解构
函式则会把它适当的释放掉 (这在不支持 ARC的Object Pascal 编译程序是必
须的 )。呼叫的程序代码则是写成如果在建构函式之后触发了例外事件，就
会呼叫 Free方法，但如果例外在建构函式中并没有发生 : 
var  
   Obj: TObjectWithList;  
begin   
   Obj := TObjectWithList.Create ( -10); 
   try   
 275      // do something  
   finally   
     Show ('Freeing object');   
     Obj.Free;  
   end; 
 
这样行吗 ?当然不行，当建构函式在建立字符串列表之前就发生例外的话，
系统就会立刻呼叫解构函式，这时就会试着释放还没建立的字符串列表对
象，而引发第二个存取错误，或是类似的错误了。  
 
为什么会这样 ?如果我们把建构函式的顺序颠倒 (先建立字符串列表，然后触
发例外事件 )，则一切都不会有问题，因为解构函式需要把该字符串列表对
象给释放掉。 但这不算真的解决， 它只是一个暂时的解法。 我们真的该做的，
是先考虑怎么保护程序代码， 让解构函式在执行时不要假设建构函式已经完
整执行过。以下可以作为一个简单的范例：  
destruct or TObjectWithList.Destroy;  
begin  
   if Assigned (FStringList) then   
   begin   
     FStringList.Clear;  
     FStringList.Free;  
   end;  
   inherited;  
end;  
 
进阶例外  
这一节也是本书当中您可能在第一次读到的时候想要直接跳过的，
因为这一节可能有点太过复杂。除非您已经对 Object Pascal 很有
经验，不然我也会建议您直接跳到下一章。  
 
在本章的最后一部分，我想 介绍关于例外处理的一些进阶主题。我要来届要
巢状例外 (RaiseOuterException) 跟 在 类 别 中 拦 截 例 外 的 概 念
(RaisingException) 。这些功能并不是早期版本 Delphi所兼容的，而新版的
Delphi也因此多了很强大的功能。  
 
  巢状例外与内部例外机制   
 276 如果我们触发了例外事件，而没有例外事件处理程序来处理，会怎么样 ?传
统的答案是新的例外事件会取代已经存在的例外事件， 这也是为何一般的作
法至少都要把错误讯息结合，然后用类似下面范例的写法 (没有实际的处理，
只显示例外相关的讯息 ): 
proced ure TFormExceptions.ClassicReraise;   
begin   
   try  
      // do something...  
      raise Exception.Create('Hello');   
   except on E: Exception do   
      // try some fix...  
      raise Exception.Create('Another: ' + E.Message);   
   end;   
end;   
 
上面的程序代码是 Adva ncedExcept 范例项目的一部分。当呼叫方法并处理
例外时，我们会看到单一一个例外事件，其讯息是组合过的：  
procedure TFormExceptions.btnTraditionalClick( Sender: TObject);   
begin   
   try  
      ClassicReraise;  
   except  
     on E: Exception do  
       Show ('Message: ' + E.Message);  
   end;  
end;  
 
相当直觉的输出就是 : 
Message: Another: Hello  
 
现在在 Object Pascal 里面，已经全系统都支持巢状例外了。透过异常处理程
序我们可以建立、触发一个新的例外，并保留现存的例外对象，并把新旧两
个例外结合起来。 要达到这个要求， Exception 类别中的 InnerException 属性，
它会参照前一个例外，而 BaseException 属性则让我们可以存取前一个例外
事件，因此例外事件得以透过递归方式存在。以下是 Exception 类别相关，
用来管理巢状例外的元素：  
type  
   Exception = cl ass(TObject)   
 277    private  
     FInnerException: Exception;  
     FAcquireInnerException: Boolean;  
   protected  
     procedure SetInnerException;  
   public  
    function GetBaseException: Exception; virtual;  
    property BaseException: Exception read GetBaseExc eption;   
     property InnerException: Exception read FInnerException;  
    class procedure RaiseOuterException(E: Exception); static;  
    class procedure ThrowOuterException(E: Exception); static;   
end;  
____________________________________________________ _____________________  
静态类别方法是类别方法中一个特别的形式。这些跟语言相关的功能我们
会在第 12章里面介绍。  
 
从使用者的观点来透视一下，在保留已发生的例外时，触发一个新的例外，
我们应该呼叫 RaiseOuterExcept 这个类别方法 (或者使用 C++导向命名的星
同方法 ThrowOuterException) 。当我们正在处理一个类似的例外，我们可以
使用这个新的属性来存取更多的信息。请注意我们在异常处理程序中呼叫
RaiseOuterException ，只能像原始码的里面注明的文件所述：  
 
使用这个函式从一个例外事件处理程序来触发一个例外实体， 您可以获
得运作中的例外，并把新的例外事件与之串连、保留着原有例外事件的
内容。这会使得 FInnerException 字段被设定为正在运作的例外实体。  
 
您应该只从要处理这个新的例外事件的 except区块来呼叫这个程序， 其
他任何情形都不该呼叫它。  
 
我们可以从 AdvancedExcept 范例项目来看一下实际的范例。在这个范例中，
我加入了一个方法，会用新的方法触发一个巢状例外 (跟前面的范例中的
ClassicReraise 方法做比较 ): 
procedure T FormExceptions.MethodWithNestedException;   
begin   
   try 
     raise Exception.Create ('Hello');   
   except   
     Exception.RaiseOuterException ( Exception.Create ('Another'));   筆記   
 278    end;   
end;   
 
现在在异常处理程序中，我们就可以同时存取两个例外对象了 (也可以看到
呼叫新的 ToString方法 ): 
   try  
      MethodWithNestedException;  
   except  
     on E: Exception do  
     begin  
        Show ('Message: ' + E.Message);   
        Show ('ToString: ' + E.ToString);   
        if Assigned (E.BaseException) then   
           Show ('BaseException Message: ' + E.BaseExce ption.Message);   
        if Assigned (E.InnerException) then Show ('InnerException Message: ' +   
           E.InnerException.Message);  
     end;  
   end;  
 
这个程序的输出结果如下 : 
 Message: Another  
 ToString: Another  
 Hello  
 BaseException Message: Hello  
 InnerException Message: Hello  
 
有两个相关的元素值得留意。第一个是在单一巢状例外的案例中，例外对象
的BaseException 属性与 InnerException 属性，这两个属性都是指向同一个
例外对象，也就是原来的例外对象。第二个则是新例外对象的讯息只包含了
实际的讯息。而呼叫了 ToString之后，我 们就得到了所有被包含在巢状例外
事件的对象的所有讯息组合在一起的字符串， 每个讯息之间会以 sLineBreak
这个符号做区隔 (您可以看一下 Exception.ToString 这个方法的程序代码 )。使
在这个例子里面使用换行符号作分隔，会让产生的结果看起来很奇怪，但我
们是可以用我们想显示的方法加以重新组合的， 只要把换行符号换成我们想
要的符号，或者把回传的字符串直接指派给字符串列表的 Text属性即可。  
 
我们接着来看个更深入的范例， 看看当两个巢状例外被触发时会怎样？以下
是新的方法：   
 279 procedure TFormEx ceptions.MethodWithTwoNestedExceptions;   
begin   
   try  
     raise Exception.Create ('Hello');   
   except  
       begin  
           try 
              Exception.RaiseOuterException ( Exception.Create ('Another'));   
           except   
              Exception.R aiseOuterException ( Exception.Create ('A third'));   
           end;  
       end;   
   end;   
end;   
 
这会呼叫一个方法，和前面我们看过的相同，并产生以下的输出 : 
     Message: A third  
     ToString: A third  
     Another  
     Hello  
     BaseException Message: Hello  
     InnerException Messa ge: Another  
 
此时 BaseException 属性跟 InnerException 属性就会指向不同的对象，而
ToString的输出值就会变成三行了。  
 
  拦截例外  
另一个随着新版本被加到例外处理系统的进阶功能是这个方法 : 
procedure RaisingException(P: PExceptionRecord); virtual;   
 
根据原始码里面的说明文件所述 : 
这个虚拟函式会在该例外将要被触发之前被呼叫。在外部例外的案例
中，这个函式则会在例外对象建立完成，且触发的条件已经在处理时，
尽快被呼叫。  
 
在Exception 类别中这个函式的实作会管理内部例外 (透过呼叫内部的
SetInnerException) ，这或许可以解释为何它会放在首位加以介绍，跟内部例 
 280 外机制放在一起。  
 
现在，我们已经可以在任何情形下透过使用这个功能来获益。透过重载这个
方法，事实上，我们在建立对象之后会有单一的函式被呼叫，不论是否透过
建构函式来建立这个例外对象。换句话说，我们可以避免为我们的例外类别
定义自定的建构函式，让使用者呼叫基础例外类别的任一个建构函式，然后
再套用我们自定的规则。例如我们可以把特定类别的任何一个例外做记 录
(或者是例外的子类别 )。 
 
以下是一个自定的例外类别 (在AdvancedExcept 范例项目中 )，重载了
RaisingException 方法：  
type  
  ECustomException = class (Exception)   
  protected   
     procedure RaisingException(  P: PExceptionRecord); override;   
  end;   
 
procedure ECustomException.RaisingException(P: PEx ceptionRecord);  
begin   
   // log exception information  
   FormExceptions.Show('Exception Addr: ' + IntToHex (  
     Integer(P .ExceptionAddress), 8));  
   FormExceptions.show('Exception Mess: ' + Message);  
   // modify the message  Message := Message + ' (filt ered)';   
   // standard processing  
   inherited;  
end;  
这个方法实作的程序代码所做的，就是记录下关于例外的一些信息，把例外
的讯息做修改，然后呼叫例外基础类别的标准处理流程 (需要巢状例外机制
才能运作喔 )。这个方法会在例外对象被建立之后、触发之前被呼叫。这一
点也值得留意，因为由 Show函式所建立的讯息通常在例外被侦错程序所捕
捉之前就已经建立好了。相似的，如果我们在 RaisingException 方法里面放
一个断点，侦错程序也会在捕捉到例外事件之前就停在该断点上 面。  
 
巢状例外跟这个拦截机制在应用程序的程序代码里面并不常用到， 因为这个
功能对于函式库跟组件的开发人员比较有用。   
 281 10:属性与事件  
 
在过去三章里面，我们介绍了 Object Pascal 在OOP当中的基础，解释了当
中的原理、并介绍了目前在大多数面向对象程序语言当中的功能是如何被
实作出来的。从早期的 Delphi开始， Object Pascal 就已经是一个完整的面
向对象程序语言，但还包含了一些特别的作法。事实上，当时 Object Pascal
也被质疑只是一个以组件为主的视觉开发工具。  
 
还有一些不相关的功能 ：这个开发模型的支持是基于一些核心的语言功能
而来，例如属性与事件，这两个特性是 Object Pascal 最早提出的，之后才
有部分功能被一些 OOP的语言复制过去使用。像是属性，也可以在 Java
跟C#里面看到，后来也普及在各种语言中，但这都是直接从 Object Pascal
学习过去的，即使我自己偏好最原始的实作版本，我稍后会简短的说明一
下。  
 
Object Pascal 能够支持快速应用程序开发工具 (RAD)以及可视化程序设计
的原因，就是属性、 published 存取描述关键词、组件的原理，以及在这一
章里面会介绍的 一些其他的原理。  
 
定义属性  
什么是属性 ?属性可以被想成是让我们可以用来存取跟变更一个对象的状
态，具有潜在的可能性可以透过其副作用来影响对象的规则。在 Object 
Pascal里面，属性把对字段、方法的数据存取进行了抽象化与隐藏，使得他
们达成了数据封装的主要实作。对属性的一个描述，可以说是『 最极致的
数据封装 』。 
 
从技术面来说，属性是可以说是一个具有型别的识别符号，而这个识别符
号是透过 read跟write叙述字来跟实际的数据或方法进行链接的。跟 Java, 
C#不同的是，在 Object Pascal 里面 read跟write叙述字可以链接到一个取
得数据 /设定数据的方法，也可以直接连结到数据字段。  
 
举个实例，以下是一个使用一般功能日期对象的属性 (从数据字段读取，透
过方法来写入 ): 
private    
 282     FMonth: Integer;  
    procedure SetMonth(V alue: Integer);  
public  
    property Month: Integer read FMonth write SetMonth;   
 
要存取 Month这个属性时，这段程序代码必须读取私有字段 FMonth，而要
变更 Month的内容时，则会去呼叫 SetMonth 这个方法。更改这个数据 (只
会排除负值而已 )的方法，程序代码会长的像这样 : 
 
procedure TDate.SetMonth (V alue: Integer);  
begin  
   if V alue <= 0 then  
     FMonth := 1  
   else   
      FMonth := V alue;  
end;  
 
请注意，数据字段跟属性的数据型别必须完全一致 (如果当中有不同点，我
们可以使用简单的方法来进行转换 )。设定数据的方法当中的唯一参数、取
得数据的回传值，以及属性这三者的型别，必须完全一致才行。  
 
属性的定义当中也可能出现不同的组合 (例如我们也可以用一个方法来读
取资料，或者直接把一个数据字段指派在 write关键词之后直接让其他程序
代码来修改 )，但使用方法来修改属性的数值是最常见的。以下是一些定义
属性的不同组合，仍以上面这个属性做例子 : 
property Month: Integer read GetMonth write SetMonth;   
property Month: Integer read FMonth write FMonth;   
_________________________________________________________________________  
当我们写了程序代码要存取属性时，了解一个方法是怎么被呼叫的就很重
要。问题是在于有些方法要花上一些时间来执行，这些方法可能会有一些
副作用，通常会包含 (延迟 )更新屏幕上的视觉组件。即使这些副作用并不常
被既载下来，我们仍然应该要记得会有这些副作用，尤其当我们想要优化
程序代码的时候。  
 
一个属性的 write关键词如果没有被写出来的话，就代 表该属性是只读的：  
property Month: Integer read GetMonth;   
 
技术上来说，我们也可以不写 read关键词，直接定义一个只能被更新的属筆記   
 283 性，但通常这样做没什么实质作用，所以也不常被这样用。  
  和其他程序语言的属性做比较  
现在，我们如果把这一点跟 Java或C#做个比较，会发现这两个语言在属性
都是直接对照到方法，但 Java是隐晦的对照 (属性基本上是进行转换 )，而
C#比较像 Object Pascal 是要直接写明了如何对照，即使只是跟方法对照：  
// properties in Java language  
private int mMonth;  
public int getMonth() { return mMonth; }   
public void setMonth(int value) {   
  if (value <= 0)  
    mMonth = 1;  
  else   
      mMonth = value;  
} 
int s = date.getMonth ();  
date.setMonth (s+1);  
 
// properties in C# language  
private int mMonth;  
public int Month {  
  get { return mMonth; }  
  set {  
     if (value <= 0)  
       mMonth = 1;  
     else   
        mMonth = value;  
  } 
}  
 
date.Month++;  
 
并不是我想要深入讨论不同程序语言中对于属性的相关优点， 不过就像我们
在本章的介绍当中所述，在属性定义的时候务必要明确定义，另外透过把属
性对应到数据字段提升抽象化的等级， 而不造成方 法的额外负担也是一个好
的作法。这也是为什么我在这么多种程序语言里面，特别偏爱 Object Pascal
对属性的实作方法了。  
  
 284 属性是非常 OOP的机制，一个非常棒的作法，让应用程序能够达成数据封
装的概念。尤其必要的是，我们必须提供个名称来隐藏一个类别实际上是如
何存取信息的 (不管是直接存取或是呼叫一个方法 )。事实上，当我们在一个
完成的接口中使用了属性，就不可能再去改变它了。同时，如果我们只想让
使用者存取到这个类别中的部分数据字段， 我们可以把这些字段透过属性加
以公布，而不用把数据字段直接搬移到公开区。使用属性，我 们不用特别多
写什么程序代码 (特别写个 Get跟Set方法是很无聊的事 )，而且我们仍旧可
以更改类别的实作程序代码。 就算我们把直接存取数据字段的作法改成了以
方法来存取，我们也不用修改这些属性的原始码。我们只需重新编译程序就
行了。请把这个好处归功于数据封装理论的强大功能吧。  
_________________________________________________________________________  
您可能会觉得奇怪，如果我们在属性里面定义让该属性直接存取一个私有
区的数据字段，难道不会因此失去 数据封装的优点之一吗。用户不就可以
直接动到私有区的变量内容，不用透过 getter或setter方法，这样不会失去
对数据的保护吗 ?然而假设用户会直接透过属性存取数据，设计这个类别的
开发人员也可以随时更改数据型别， 并加入新的 getter或setter方法来因应，
这样就算有其他程序代码使用到该类别，那些程序代码也不用因此需要修
改。 这就是我所谓 『封装到极致』 的意思。 另一方面， 这也展示了 Object Pascal
程序化的一面，开发人员可以选择任何一种较简单的方法 (或者程序执行效
率较高的方法 )来处理当前的状况，并在有需 要的时候，和缓的把程序转换
成适当的 OOP方法。  
 
然而，在使用 Object Pascal 的属性时，也有一个限制。我们可以把一个数值
指派给属性，也可以从属性读取数值，我们也可以自由的在判断式里面使用
属性，但我们不能把属性当成传址型的参数来传递给函式或程序。这是因为
属性并不是一个实际的内存地址，而是一个抽象的概念，所以不能够用 var
加以传递。举例来说，我们不能把属性传给 Inc函式，但 C#可以。  
___________________________________________________________ ______________  
相关的功能，把属性以传址的方式传递，在本章稍后会加以介绍。然而这
样的用法非常罕见，而且需要透过对编译程序特别的设定，这并不是主流
的用法。  
 
  在宣告属性时使用代码自动完成的功能  
在类别里面加入属性是件很枯燥的工作，所以 IDE的编辑器让我们可以简
单的透过『 代码自动完成 』这个功能来处理。当我们在宣告属性的时候 (当
然是在类别宣告的时候 )，只需要写好前面开头的部份，如以下的例子 : 
type  筆記  
筆記   
 285   TMyClass = class  
  public  
     property Mont h: Integer;  
  end;  
 
先把编辑的文字光标停在这个新增的属性上面，然后按下 Ctrl+Shift+C ，编
辑器就会自动帮我们把这个属性相应的数据字段、 用来修改该属性的方法一
起产生出来。不仅是宣告的程序代码，编辑器会连着实作的程序代码，例如
用来修改该属性的方法，需要宣告什么参数，里头该怎么写，都一起产生出
来。换句话说，透过这个热键，上面的属性宣告立刻会变成 : 
type  
   TMyClass = class  
   private   
      FMonth: Integer;  
      proc edure SetMonth(const V alue: Integer);   
   public   
      property Month: Integer read FMonth write SetMonth;   
   end;   
 
{ TMyClass }   
procedure TMyClass.SetMonth(const V alue: Integer);   
begin   
   FMonth := V alue;  
end;  
 
如果我们想要修改 getter方法，只要把 read部分的定义修改成 GetMon th，
像是 : 
property Month: Integer read GetMonth write SetMonth;   
 
然后再按一次 Ctrl+Shift+C ，GetMonth 这个方法也又会自动被建立出来了，
不过 GetMonth 这个方法的内容我们就得自己写了：  
function TMyClass.GetMonth: Integer;  
begin  
end;  
 
  为窗体加入属性  
我们来看一个使用属性进行封装的特例。这次我们不建立自定的类别，改成 
 286 修改 IDE建立的窗体类别，当然我也会用到类别自动完成的功能。  
当应用程序中有多个窗体时，我们通常为了方便，会让窗体之间可以互相存
取彼此的信息。 我们可以用暴力的作法， 就是直接把数据字段宣告在公开区，
但这样做在 OOP的程序概念中其实不好。每当我们需要让窗体之间交换数
据的时候，我们应该使用属性。  
 
我们在窗体类别里面宣告简单的属性名称跟型别 : 
property Clicks: Integer;   
 
然后按下 Ctrl+Shift+C ，启动代码自动完成功能，我们就会看到以下的效果 : 
type  
   TFormProp = class(TForm)  
   private  
      FClicks: Integer;  
      procedure SetClicks(const V alue: Integer);   
   public   
      property Clicks: Integer  read FClicks write SetClicks;   
   end;  
implementation  
procedure TForm1.SetClicks(const V alue: Integer);   
begin   
    FClicks := V alue;  
end;  
 
不用说，这功能真的帮我们省下很多打字的时间 (更别说有时候会打错字 )。
现在当用户点击窗体的时候， 我们就可以透过下面这行程序把计数器的数字
递增，我们可以从 FormProperties 范例项目里面的 OnMouseDown 事件处理
程序看到 : 
Clicks := Clicks + 1;  
 
您可能会觉得奇怪，怎么不直接对 FClicks做递增呢 ? 当然，在这个例子里
面，直接做递增也是可行的，但我们可能会在 SetClicks 这个方法里面同时
更新一些用户接口，然后把目前的数值做更新：如果我们不管属性，直接存
取数据字段， setter方法的副作用可能就不会被执行，例如数值的更新就不
会同时被在接口上同步更新了。  
 
这个封装的另一个优点， 是我们可以从另一个窗体来读取这个窗体被点击的
数字，当然，是透过适当的抽象方式。事实上，窗体类别的属性可以用来读 
 287 取自定的数据，也可以封装窗体的组件存取。举个例子，如果我们有一个窗
体，上面有个卷标用来显示一些信息，而我们想要透过另一个窗体来修改上
头的文字，我们可能会用这种暴力写法 : 
Form1.StatusLabel.Text := 'new text';   
 
这是通常的实用写法，但并不是个好作法，因为它并没有 对窗体的结构或组
件提供任何封装。如果我们在整个程序项目中有很多地方都这样写，而稍后
我们决定要修改窗体上面的用户接口 (例如把 StatusLabel 对象改成其他控
件)，我们就得修改很多地方了。  
 
另一个替代方案则是使用方法，或者使用属性来隐藏特定的控件。我们可以
透过上面的步骤加入一个可擦写的属性，或者直接完整的输入宣告 : 
property StatusText: string read GetStatusText write SetStatusText;   
 
然后按下 Ctrl+Shift+C ，让编辑器帮我们把这 两个方法的宣告都先产生好 : 
function TFormProp.GetStatusText: string;  
begin  
   Result := LabelStatus.Text  
end;  
procedure TFormProp.SetStatusText(const V alue: string);   
begin   
   LabelStatus.Text := V alue;  
end;  
 
请注意，在这个案例中，属性并没有跟任何类别中的数据字段对应，而是跟
一个子控件，也就是卷标对应 (万一我们使用了代码自动完 成功能，请记得
先把编辑器帮我们产生的 FStatusText 数据字段给删掉喔 )。 
 
在程序中的另一个窗体，我们就可以直接参照这个窗体的 StatusText 属性，
就算用户接口做了一些修改，到时候也只要改 Get跟Set这两个方法，其他
窗体的程序都不用再修改了，所以这两个属性也更独立了：  
procedure TFormProp.SetClicks(const V alue: Integer);   
begin   
   FClicks := V alue;  
   StatusText := FClicks.ToString  + ' clicks';   
end;   
 
  
 288   为TDate类别加入属性  
我们在第七章里面建立了一个名为 TDate的类别， 现在我们来用属性帮这个
类别做些延伸。这个新的范例项目名为 DateProperties ，基本上是第七章的
ViewDate 范例项目的延伸。以下是这个类别的重新宣告，里面包含了一些
新的方法 (作为取得与设定属性的内容 )以及四个属性 : 
type  
   TDate = class  
   private  
      fDate: TDateTime;   
      function GetY ear:  Integer;  
      function GetDay: Integer;   
      function GetMonth: Integer;   
      procedure SetDay (const V alue: Integer);   
      procedure SetMonth (const V alue: Integer);   
      procedure SetY ear (const V alue: Integer);   
   public  
      constructor Cr eate; overload;   
      constructor Create (y, m, d: Integer); overload;   
      procedure SetV alue (y, m, d: Integer); overload;   
      procedure SetV alue (NewDate: TDateTime); overload;   
      function LeapY ear: Boolean;   
      procedure Increase (NumberOf Days: Integer = 1);   
      procedure Decrease (NumberOfDays: Integer = 1);   
      function GetText: string; virtual;   
      property Day: Integer read GetDay write SetDay;   
      property Month: Integer read GetMonth write SetMonth;   
      property Y ear: I nteger read GetY ear write SetYear;   
      property Text: string read GetText;   
   end;  
 
Year, Day, 跟 Month属性的读写都是透过对应的方法，以下是其中两个跟
Month属性相关的方法：  
function TDate.GetMonth: Integer;  
var 
   y, m, d: Word;   
begin   
    DecodeDate (fDate, y, m, d);   
 289     Result := m;  
end;  
 
procedure TDate.SetMonth(const V alue: Integer);   
begin   
   if (V alue < 1) or (V alue > 12) then   
     raise EDateOutOfRange.Create (‘Invalid month’);   
   SetV alue (Y ear, V alue, Day);  
end;  
 
呼叫 SetValue 会对日期进行实际的编码，万一有错的时候也会触发例外。我
定义了一个自定的例外类别，会当数值超过范围的时候 被触发：  
type  
  EDateOutOfRange = class (Exception);   
 
第四个属性， Text只对应到一个读取的方法。这个方法被宣告为虚拟方法，
因为它会被 TNewDate 子类别取代。而属性的 Get或Set方法没有理由，不
应该使用延迟绑定 (这个技术在第八章里面已经用很长的篇幅介绍过 )。 
_________________________________________________________________________  
在这个范例里面值得一提的，是属性不要直接对应到数 据字段。属性可以
简单的从储存在不同型别的信息中被计算出来，并用不同的数据结构加以
储存。  
 
在类别里面加入了新的属性之后， 我们现在可以把范例程序透过属性做一些
适当的修改了。例如我们可以直接使用 Text属性，我们也可以使用一些文
字框让用户读写这三个主要属性的数值 (如图 10.1所示 )。 我们可以让用户按
下btnRead按钮来读取数据 : 
procedure TDateForm.BtnReadClick(Sender: TObject);   
begin   
   EditY ear.Text := IntToStr (Th eDay.Y ear);  
   EditMonth.Text := IntToStr (TheDay.Month);  
   EditDay.Text := IntToStr (TheDay.Day);  
end;   
 
btnWrite按钮则是提供写入的动作，我们可以用以下两种方式来达成这个功
能: 
// direct use of properties  
 TheDay.Y ear := StrToInt (EditY ear.Text);  筆記   
 290  TheDay.Month := StrToInt (EditMonth.Te xt); 
 TheDay.Day := StrToInt (EditDay.Text);  
// update all values at once TheDay.SetV alue (StrToInt (EditMonth.Text),   
   StrToInt (EditDay.Text),  
   StrToInt (EditYear.Text));  
_________________________________________________________________________  
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 
这两个方法之间的差异，是在使用者没有输入正确的日期时要怎么处理。当
我们让每个数值分开设定的时候，程序可能只修改了年，然后触发例外，并
跳过其他的程序代码，所以到时候日期就只有一部分被修改。当我们把所有
的数值一起设定时，要不就格式正确，全部一起设定好，要不就格式错误，
原来的日期数值都不变。  
 
  使用数组属性  
通常属性是让我们存取一个数据， 甚至是一个复杂的数据型别。 Object Pascal
也可以定义数组属性，在 C#里面这样的属性也被称为 indexer。数组型别透
过进一步的参数，是可以 包含任意数据型别的，只要该型别可以被当成索引
或者实际数值的撷取者。  
 
以下是定义一个数组属性的范例，在这个范例里面使用了整数作为索引值，
储存的内容也是整数：  
private  
   function GetV alue(I: Integer): Integer;   圖10.1: 在
DynamicEvents
範例專案 中，由
動態建立的按鈕
所顯示的訊息  
 
 291    procedure SetV alue(I: Integer; const V alue: Integer);   
public  
   property V alue [I: Integer]: Integer read GetV alue writ e SetV alue;   
 
数组属性必须有对应的读取与写入方法， 这两个方法都得有个额外的参数用
来作为索引值，我们可以透过代码自动完成的功能来定义一般的属性。在
RTL里面有一些类别很常使用数组属性，它们的索引值跟数据有很多种组
合。例如，在 TStrings类别里面就定义了以下五个数组属性：  
property Names[Index: Integer]: string read GetName;   
property Objects[Index: Integer]: TObject   
     read GetOb ject write PutObject;   
property V alues[const Name: string]: string   
     read GetV alue write SetV alue;   
property V alueFromIndex[Index: Integer]: string   
     read GetV alueFromIndex write SetV alueFromIndex;   
property Strings[Index: Integer]: string   
     read Get write Put; default;  
 
这些数组属性当中，大多数都是用整数索引值作为列表的参数，少部分则是
直接用字符串作为搜寻值 (像是上面所列出的 Values属性 )。上面这五个定义
当中的最后一个，使用了另一个重要的功能，它被标示了 default这个关键
词。这也是一个很强大的语法助手 : 这个数组属性的名称就可以直接被省
却，所以我们可以直接在对象后面加上方括号来存取该属性的内容。换句话
说，当我们有个 TStrings型别对象 sList时，以下两种写法都是相同的意义：  
sList.Strings[1 ] 
sList[1]  
 
也就是说，默认的数组属性，可以让任何对象透过方括号直接存取里面的数
据。  
 
  以参考设定属性  
这是一个相对进阶的主题 (且这个功能也很少被用到 )，所以如果您
对Object Pascal 还没有很精通的话，可能会想直接跳过这一节。  
 
在Object Pascal 编译程序被延伸去支持 Windows COM 程序的时候，就被赋
予了处理 ”以参考设定 ”(put by ref) 属性的能力 (用COM的术语来说 )， 或者说
可以接受指针参考值的属性，这属性中储存的不是实际数据。   
 292  
______________ ___________________________________________________________  
”以参考设定 ”(put by ref) ，是由 Chris Bensen 为这个功能命名的，它是在该
功能被介绍之后，在 Chris的部落格上介绍的 : http://chrisbensen.blogspot  
.com/2008/04/delphi -put-by-ref-properties.html (Chris 当时是这个产品的研发
工程师 ) 
 
在它的设定方法 (setter method) 当中，是以 var参数来描述的。假设这会导致
相对尴尬的情况，这个功能就该被认为是例外，而不是规则了，这也是为何
它为何预设是不使用的。  
 
换句话说，如果我们要使用这个功能，得要自己写上这么一行指令来设定编
译程序：  
{$VARPROPSETTER ON}  
 
没有写上这行指令的话，以下的程序代码就无法被编译，而且编译程序会显
示这个错误讯息 : ”E2282 Property setters cannot take var parameters”:  
type  
 TMyIntegerClass = class   
  private   
     fNumber: Integer;   
     function GetNumber: Integer;   
     procedure SetNumber(var V alue: Integer);   
  public  
     property Number: Integer read GetNumber write SetNumber;   
  end;   
 
这个类别是 VarProp范例项目的一部分。现在我们会在这个属性的 setter方
法里面看到很奇怪的副作用了 : 
procedure TMy IntegerClass.SetNumber(var V alue: Integer);   
begin   
   Inc (V alue); // side effect  
   fNumber := V alue;  
end;  
 
另一个非常不寻常的效应，是我们无法把常数数据指派给属性，不是变量喔
(变量应该是可以的，就像把变量当成任何一个传址函式的参数一样传递 )： 筆記   
 293 var  
   mic: TMyIntegerClass;  
   n: Integer;   
begin   
   ...  
   mic.Number := 10; // Error: E2036 V ariable required   
   mic.Number := n;   
 
这跟我们常用的功能不同，这是相对比较进阶的功能，让我们思考一下是要
为一个属性初始化，或是为即将指派给它的数值资料提出警告。这可能导致
很奇怪的程序代码：  
   n := 10;  
   mic.Number := n;  
   mic.Number := n;  
   Show(mic.Number.ToString);  
 
这两种写法效果都一样，但看上去就很奇怪，但它们也都产生了副作用，就
是把实际的数字变成了 12。这也许是取得运算结果的方法中，最让人无法
理解、觉得荒谬的一种。  
 
发布(Published) 存取关键词  
除了 public, protected, 以及 private这几个存取关键词之外 (当然还有比较不
常用的 strict private 跟strict protected) ，在Object Pascal 里面还有另一个奇特
的存取关键词，叫做 published( 发布 )。一个发布区的属性 (或数据字段、方
法)，不只可以在运行时间具备公开属性的特性，同时也会建立出延伸的运
行时间型别信息 (Run -time Type Information, RTTI) 以供查询。  
 
事实上在一个编译后执行的语言里面，编译过的符号会被编译程序处理过，
在测试程序的时候，可以被侦错程序所使用，但在运行时间并不会被追踪。
换句话说 (至少在早期的 Object Pascal 是如此 )，如果一个类别拥有一个名为
Name的属性，我们就可以在程序代码里面跟该类别进行互动，但我们并不
知道，一个类别当中是否有 ”Name”这个属性存在。  
_________________________________________________________ ________________  
Java跟C#也都是编译后执行的语言，两者也都从复杂的虚拟执行环境而获
得了优势，也因为虚拟执行环境，在这两者当中都可以取得延伸的执行时
期信息，通常称为 reflection 。Object Pascal 在几年以后也提供了 reflection
的功能 (也称之为延伸的 RTTI)，所以仍有一些基本的 RTTI信息是跟着筆記   
 294 published 关键词，在本章里面被提到的，在第十六章里面会对 reflection 有
更全面的介绍。  
为什么类别会需要延伸的信息呢 ?它是 Object Pascal 函式库所 依赖的组件模
型与可视化程序模型的基础之一。这些信息当中，有一部分会在设计时间的
开发环境中被使用到，例如当我们点击了视觉组件时，该组件的相关属性、
事件就会被显示在对象查看器中。这可不是写死的程序行表，它们是由编译
完成的程序代码在运行时间实时产生出来的。另一个例子，或许现在来介绍
有点太复杂了，则是在建立 FMX跟DFM文件时背后使用到的串流机制。
串流机制我们会在第十八章里面介绍， 因为它比较属于运行时间函式库的一
部分，跟程序语言的核心比较没那么相关。  
 
为这个概念做个整理， published 关键词一般的重要使用时机 ，是当我们在
写组件给自己的程序或者给其他人使用的时候。通常组件的 published 部分
只会包含属性， 而窗体类别的则还会把 published 用来宣告数据字段跟方法，
我们稍后会介绍。  
 
  设计时间属性  
我们在本章的前面已经介绍过， 属性在类别的数据封装技术中扮演了重要的
角色。它们也在视觉开发模型的功能中扮演了基础角色。事实上，我们可以
写一个组件类别，让它能够在设计时间的窗体中，透过 IDE的组件列表直
接用拖拉的方式被加到一个视觉窗体上面去， 并且可以透过对象查看器来跟
它的属性做互动。并非所有的属性都可以透过这样的情 形来使用，只有在组
件类别中被标注为 published 的属性才可以。  
 
这也是为什么 Object Pascal 的开发人员要把属性在 设计时间 跟运行时间 之
间做出区隔了。设计时间的属性必须被宣告在类别的 published 区里面，这
些属性可以在设计时间的 IDE跟程序代码里面使用。而其他宣告在 public
区里面的属性，则不能在 IDE里面使用，只能在程序代码里面使用，所以
这些属性通常也被称为 运行时间专用 (Runtime only) 。 
 
换句话说，我们可以在 Object Pascal 设计时间的 IDE中，透过对象查看器
里面看到该属性的内容，也可以修改它。这个工具也是 Delphi的视觉开发
工具提供来存取属性之用。在运行时间，我们可以从程序代码里面用同样的
方法来存取所有类别宣告在公开区或发布区的属性。  
 
并不是所有的类别都有属性。属性只会在组件，以及 TPersistent 类别的衍生
类别才会出现， 因为属性可以被串流化， 并且存到 文件里面。 像是窗体 文件， 
 295 就只是窗体上面所有组件的 published 属性的集合而已，也没有记录什么其
他的了。  
更精确一点，我们不需要从 TPersistent 衍生类别，也可以把属性宣告在
published 区，但我们 需要在编译类别的时候设定 $M这个编译程序开关。每
个透过这个编译程序开关进行编译的类别， 或者从这样的类别所衍生的子类
别，都可以支持 published 区。假设 TPersistent 类别就是包含着这个编译程
序开关做编译的，所以其下的所有衍生类别也都获得了支持。  
_________________________________________________________________________  
接下来的两小节在默认程序可见区域跟自动化的 RTTI中都加了额外的信
息以支持 $M编译程序开关跟 publish ed关键词。  
 
  发布(published) 与窗体  
当IDE建立了一个窗体， 就会把它的组件跟方法放在初始的定义中， 在 public
跟private关键词之前。这些放在初始部分的数据字段跟方法都会被视为该
类别的 published 区块。当没有在组件类别的数据或方法字段前特别写关键
词的时候，就会预设被视为 published 。 
_________________________________________________________________________  
更精准一点来说， published 只有以 $M作为编译程序开关，或者从这一类的
类别衍生出的子类别中，才会是默认的关键词。就因为在 TPersistent 类别
中使用了这个开关，所以函式库里面大多数的类别，以及大多数的组件类
别都默认是 publish区。 然而非组件的类别 (像是 TStream跟TList)则是以 $M-
这个设定编译的，所以预设只有到 public区。  
 
以下是一个例子 : 
type  
   TForm1 = class(TForm)  
      Memo1: TMemo;  
      btnTest: TButton;  
 
要被指派给任何事件的方法，都 必须是被发布的 (published) 方法，且在窗体
中对应到组件的数据字段也该是被发布的， 这样才能自动跟窗体 文件中的对
象链接起来，并且自动被建立在窗体里面。也只有被宣告在窗体中最初那区
的组件跟方法才能在对象查看器里面显示出来 (在窗体的组件列表或者当我
们在对象查看器里面以下拉选单选取可以被对应到的事件处理程序时 )。 
 
为什么类别的组件应该要被宣告为被发布的呢 ?如果放在私有区，不是更依
循OOP的封装规则吗 ?原因是因为这些组件会在读取串流化表示的数据时筆記  
筆記   
 296 就被建立出来，但一旦建立出来，它们就需要被指派给对应的表单域。这 必
须透过 RTTI为被发布的字段来产生 (这原本只是为了让 Object Pascal 可以使
用RTTI的格式，直到延伸 RTTI提出，在第十六章里面我们再加以介绍 )。 
_________________________________________________________________________  
技术上来说，组件并没有义务要使用被发布的字段。我们可以把这些字段
放在私有区，这样更符合 OOP的精神。然而，这也需要更多额外的运行时
间的程序代码。我会在本章的最后『 RAD跟OOP』那个小节来做些说明。  
 
  自动RTTI 
另一个在 Object Pascal 编译程序当中的特别规则， 则是如果我们在类别当中
加入 published 关键词，而这个类别并不是从 TPersistent 类别衍生而来，编
译程序就会自动启动 RTTI，加入 {$M+}的规则。  
 
假设我们建立了以下这个类别：  
type  
   TMyTestClass = class  
   private  
       FV alue: Integer;  
       procedure SetV alue(const V alue: Integer);  
   publis hed 
       property V alue: Integer read FV alue write SetV alue;   
end;   
 
编译程序就会显示以下的警告讯息 : 
[dcc32 Warning] AutoRTTIForm.pas(27): W1055 PUBLISHED caused RTTI ($M+) to be added to type 
'TMyTestClass'   
 
编译程序就自动的把 {$M+}加入了程序代码。我们可以从范例项目
AutoRTTI 里面找到这段程序代码。在这个程序中，我们 可以写成以下的程
序代码，使用动态方式来存取一个属性 (使用传统的 TypInfo单元 ): 
uses   
   TypInfo;   
 
procedure TFormAutoRtti.btnTetClick(Sender: TObject);   
var  
   test1: TMyTestClass;  
begin   筆記   
 297    test1 := TMyTestClass.Create;  
   try  
       test1.V alue := 22;  
       Memo1.Lines.Add (GetPropV alu e (test1, 'V alue'));   
   finally   
      test1.Free;   
   end;   
end;   
_________________________________________________________________________  
虽然我不常使用 TypInfo单元跟其中的函式，像是 GetPropValue ，RTTI的
真正力量是来自于更现代的 RTTI单元文件，以及在其中对 reflection 的外
延支持。由于这是比较复杂的主题，我觉得应该要用单独的一章来介绍 它，
并同时介绍 Object Pascal 支持的 RTTI功能的两个效益。  
 
事件驱动程序写作  
在以组件为基础的函式库 (当然还有其他很多情境也是 )中，我们写的程序代
码并不是把一连串的动作摊开来， 而是许多动作在不同的时间点触发的动作
累积而成的。以这个概念来看，我想我们在写程序时，都只是在定义程序遇
到这些触发的动作时应该如何反应。而这个『动作』可能是使用者的操作，
例如点击按钮，可能是操作系统的动作，例如某个传感器的状态改变，或者
是远程联机的数据已经准备好了，可能是我们想得到或想不到的任何情形。  
 
这些外部或内部的动 作，都被通称为事件。事件最初是与讯息导向的操作系
统对应的，像 Window，但已经跟原始的理论有很大的不同了。事实上在比
较新的函式库里面，大多数的事件都是当用户在设定属性、呼叫方法，或者
跟特定的组件互动时由内部驱动的 (或者间接由其他类别驱动 )。 
 
事件跟事件驱动是怎么跟 OOP产生关连的 ?这两个要求在建立新的衍生类
别的方式以及时间点都是不同的。  
 
在纯粹 OOP的格式当中，当一个对象的行为 (或方法 )跟另一个对象不同时，
他们就该被归类为不同的类别。我们已经看过了一些关于这些效应的范例。
让我们思考一下这个情形。一个有 四颗按钮的窗体，让每个按钮在被点击时
都需要有不同的反应。所以在纯粹的 OOP名词里，我们应该为这个窗体上
的四个按钮都单独做出一个不同的衍生类别， 再单独赋予不同的 click方法。
这样的要求理论上是对的，但实际上会产生很多程序的工作要做，而且没有
什么弹性。  筆記   
 298  
事件驱动的程序写法，则考虑到相似的情境，并建议开发人员为按钮对象加
上一些不同的规则，这些按钮对象仍然可以属于同一个类别。规则上变成了
为可以为每个对象的状态进行扩充，而不用衍生不同的类别。这个模式称为
委任 (delegation) ，因为一个对象的行为是委任给一个 类别的方法，而不是由
该对象所属的类别来处理的。  
 
事件在不同的程序语言中可以用不同的方式加以实现，例如：  
透过方法参考 (在Object Pascal 里面则称之为方法指标 )，或者在内部方法中
使用事件对象 (像C#的作法 )。 
 
把处理事件的程序代码委任给一个特定的类别，实作一个接口 (像在 Java里
面最常见的作法 ) 
 
使用程序区块， 就像 JavaScript 里面最常使用的 (在Object Pascal 里面也支持
了匿名方法，我们在第 15章里面介绍 )，虽然在 JavaScript 里面所有的方法
也都是程序区块，但在这语言里面 ，这两个概念就有点混淆了。  
 
如果事件跟事件驱动的程序写作概念，在过去十几年里面已经变得很平常，
且在大多数不同的程序语言里面都已经支持， 那么 Object Pascal 实作事件的
方法就是相当独特的，我们在接下来这一小节里面来谈谈。  
 
  方法指标 (Method Pointers)  
我们在第四章的最后一部分已经介绍过 Object Pascal 的函式指标概念。 这是
以一个变量来储存函式的内存地址，我们可以依此间接的使用这个函式。一
个函式指标是以一个特别的方式来宣告的 (以一系列的参数型别跟回传值加
以宣告，如果该函式有 参数跟回传值的话 )。 
 
跟函式指标很像， Object Pascal 里面还有方法指标。方法指针是记录属于一
个类别的方法的内存地址。就像函式指标型别，方法指标型别也有一个特殊
的宣告方法。然而，方法指针带有更多的信息，像是该方法指标是属于哪个
对象的 (或者换句话说，这个方法里面如果需要使用到对象的内容时，应该
透过 self来作为参考 )。 
 
换句话说，方法指针是一个对象所属方法的参考 (亦即该方法在内存中的进
入地址 )。当我们把一个值指派给方法指标时，我们必须以特定的对象来作
为该方法的拥有者。   
 299 ______________ ___________________________________________________________  
如果能够看一下方法指针的定义与数据结构是如何建构出来的，一定会对
了解方法指标的实作过程有更深入的了解，这个型别就称为 TMethod。这
个记录型别有两个数据字段 Code跟Data， 分别表示方法的地址跟它所属的
对象。在其他的语言里面，程序参考是由委任类别 (C#)或者由接口的方法
(Java)来掌控的。  
 
方法指针型别的宣告跟程序方法也很像， 除了方法指标需要在结尾加上一个
object关键词：  
type  
   IntProceduralType = procedure (Num: Integer);   
   TStringEventType = procedure (const s: string) of object;   
 
当我们宣告了一个方法指标，就像上面这样的宣告，我们可以宣告一个以这
个方法指针作为型别的变量，并把任何对象中兼容的方法指派给这个变量。
什么是兼容的方法 ?第一是需要跟方法指标拥有相同的参数，例如上述的例
子中的方法指针是要求一个字符串为参数。  
___________________ ______________________________________________________  
任何一个对象所属方法的参考，只要兼容于方法指标型别，就可以被指派
到以该方法指标为型别所宣告的变量里面。  
 
现在，我们有了一个方法指标型别，就可以用这个类型声明一个变量，然后
把一个兼容的方法指派给这个变量了：  
type  
   TEventTest = class  
   public  
      procedure ShowV alue (const s: string);  
      procedur e UseMethod;  
   end;  
procedure TEventTest.ShowV alue (const s: string);  
begin  
   Show (s);  
end;  
 
procedure TEventTest.UseMethod;   
var  
   StringEvent: TStringEventType;   
begin   筆記  
筆記   
 300     StringEvent := ShowV alue;  
    StringEvent ('Hello');  
end;  
 
目前这简单的程序代码还无法真的解释 事件的好用， 因为上面这程序代码还
聚焦在方法指标型别的低阶理论上。事件就是以此为基础建立起来的，并以
储存一个对象的方法指针，指派给不同的对象的作法，超越了这个简单的概
念(例如，我们把窗体的 OnClick事件处理程序指派给按钮 )。在大多数的情
形下，事件也被透过属性加以实现。  
_________________________________________________________________________  
这作法不太常见，在 Object Pascal 我们则也可以使用匿名方法来定义一个
事件处理程序 。不太常见的原因或许是当这个功能在 Object Pascal 里面最
近才支持，而许多函式库已经存在很久了。而且这功能的复杂度又更高一
些。我们可以在第 15章里面找到一些范例是关于这个公囊的。另一个可能
的延伸则是对单一一个事件定义了多种事件处理程序，像是 C#就支持这作
法，虽然不是标准的功能，但我们可以自己实作出这样的功能。  
 
  委任的原理  
猛一看，这个技术的目的不太清楚，但他的确是 Object Pascal 组件科技的奠
基石之一。秘密就在于 委任这个名词。如果我们建立了一个对象，在对象里
面有一些方法指针，我们就可以 很自由的把对象的规则改来改去，只需要把
这些指标指派给新的方法就行了。这听起来很习惯吗 ?你应该习惯的。  
 
当我们为按钮加入一个 OnClick事件，开发环境就是帮我们做了这件事。该
按钮有一个方法指针，名为 OnClick，我们可以直接或间接的把窗体的方法
指派给它。当用户点击了这个按钮，这个方法就会被执行，即使我们把这方
法定义在另一个类别里面 (通常是在窗体中 )。 
 
以下我们列出在 Object Pascal 函式库里面的一些实战程序代码， 用来把一个
按钮的事件处理程序跟窗体的方法关连在一起 : 
type  
   TNoti fyEvent = procedure (Sender: TObject) of object;   
   TMyButton = class  
     OnClick: TNotifyEvent;  
   end;   
 
   TForm1 = class (TForm)   筆記   
 301      procedure Button1Click (Sender: TObject);   
     Button1: TMyButton;   
   end;   
 
var 
  Form1: TForm1;  
 
接下来是一个内部的方法，我们 可以这样写：  
MyButton.OnClick := Form1.Button1Click;   
 
上面的程序代码跟实际上在函式库里面的只有一点点不同， 不同的是在函式
库里面是以 OnClick 作为属性的名称，而实际的数据则将之命名为
FOnClick 。组件的事件会被列在对象查看器的事件分页里面。事实上，事件
这种属性也就是方法指针。  
 
这表示我们可以在设计时间动态的把事件处理程序改为与特定对象连接， 或
者在运行时间建立一个新的组件， 然后把事件处理程序指派给新的对象当中
的方法。 DynamicEvents 范例项目中有这两 种作法的案例。窗体中有一个按
钮，使用标准的 OnClick事件处理程序。然而我也在窗体中加入了第二个公
开方法，这个方法的参数跟该事件处理常数一致 (具备方法兼容性 ): 
public  
   procedure btnTest2Click(Sender: TObject);   
 
当按钮被点击的时候，除了显示讯息，还会把事件处理程序指派到第二个风
法去，把额外的动作加入到点击的处理程序中：  
procedure TForm1.btnTestClick(Sender: TObject);   
begin   
   ShowM essage ('Test message');   
   btnTest.OnClick := btnTest2Click;   
end;   
 
procedure TForm1.btnTest2Click(Sender: TObject);   
begin   
   ShowMessage ('Test message, again');   
end;   
 
这样一来，当用户第一次点击按钮的时候，原先的事件处理程序会被执行，
点第二次的时候，我们就会看到第二个事件处理程序被执行了。   
 302 __________________ _______________________________________________________  
当我们要输入程序代码，把一个方法指派给一个事件的时候，代码自动完
成的功能会建议我们可用的事件名称，并把它转成一个实际的程序呼叫写
法，连小括号都会附上。这是不对的。我们是要把它指派给一个事件处理
程序，不是要呼叫它。否则编译程序就会试着把该方法执行的结果指派到
事件处理程序的变量去 (但如果是一个程序，没有回传值，就又会出错 )，最
后就会发生错误了。  
 
项目程序代码的第二个部分，介绍了完整的动态事件关连。 当我们点击了窗
体的画面，就会随机建立出一个新的按钮出来，并把所属的按钮的文字显示
出来 (Sender对象 )： 
procedure TForm1.btnNewClick(Sender: TObject);   
begin   
   ShowMessage ('Y ou selected ' + (Sender as TButton).Text);   
end;   
 
procedure TForm1.FormMouseDown(Sender: TObject; Button: TMouseButton;   
    Shift: TShiftState; X, Y: Single);   
var 
   AButton: TButton;  
begin   
   AButton := TButton.Create(Self);   
   AButton.Parent := Self;   
   AButton.SetBounds(X, Y , 100, 40);   
   Inc (FCounter);   
   AButton.Text := 'Button' + IntToStr (FCounter);   
   AButton.OnCli ck := btnNewClick;   
end;   
 
透过这段程序代码，每一个随机建立出来的按钮都会在自己被点击的时候，
把自己的按钮文字显示出来，即使使用的是共享的一个事件处理程序，感谢
事件里面有使用到 sender这个参数。这个程序的执行画面，如图 10.2所示：  
 
 
 
 
 
 筆記   
 303 _________________________________________________________________________  
 
 
  
 
 
 
 
 
 
 
 
  事件也是属性  
在Object Pascal 里面的事件，几 乎都是使用方法指针型别的属性来实作的，
这一点也很重要。这表示要处理一个组件的事件，我们只需要把方法指派给
对应的事件属性即可。用程序的术语来说，这代表着我们可以把一个对象的
方法指派作为一个事件处理程序， 我们用前几节里面的程序代码作为范例来
看一下 : 
Button1.OnClick := ButtonClickHandler;   
 
再提一次，规则是该事件的方法指标型别必须跟我们想要指派的方法兼容，
不然的话编译程序会指出这个错误。 系统中原就为事件定义了几种方法指标
型别，这些型别很常用到，我们从简单的开始看：  
type 
  TNotifyEvent = procedure (Sender: TObject) of object;   
 
这就是最常见的 OnClick事件处理程序的型别， 我们用以上这个型别做个简
单的方法宣告 : 
procedure ButtonClickHandler (Sender: TObject);   
 
这听起来如果有点疑惑，请回想一下在开发环境中我们的动作。当我们点选
任何一个按钮，例如叫它 Button1，我们在按钮上面双击， OnClick 事件就
会在开发环境的组件查看器当中被列出来了， 并且会在该组件的类别 需告终
加入一个空白的方法实作程序代码：  
procedure TForm1.Button1Click (Sender: TObject) begin   
end;   
 圖10.2: 
DynamicEvents
專案的執行畫
面，動態產生按
鈕與訊息  
 
 304 我们要自己在上述的这个空的方法里面撰写程序代码， 把任何我们想要的功
能加进去。这是因为事件处理程序的方法已经在背景被指派给该事件了。我
们在设计时间中，为任何其他的属性进行数值、方法的设定，也都会以完全
相同的方法被指派给该组件。  
 
从上面的描述里，我们可以了解到，在事件跟被指派给该事件的方法之间并
没有一步一步的对应。相当奇怪。我们可以让很多个事件共享 一个事件处理
程序，这也说明了为何要很常用到 Sender这个参数的原因，这个参数让我
们知道是哪个对象驱动了这个事件。举例来说，如果我们把 OnClick这个事
件处理程序指派给两个按钮， Sender这个值在一个按钮对象被点击的时候，
就会包含被该按钮的指针。  
_________________________________________________________________________  
我们可以透过程序代码把同一个方法指派给不同的事件，如上所述，但在
设计时间也行。当我们从组件查看器的事件当中点选 特定的一个事件，我
们可以点选该事件右方的下拉选单钮，它会把目前类别中兼容于该事件的
方法都列上来。我们就可以从当中选取一个要用来处理该事件的方法。透
过这个方法，我们可以让不同的组件所属的事件用同一个方法来处理。  
 
  为TDate类别加入一个事件  
我们刚刚已经为 TDate类别加入了一些属性，现在我们再来加入一些方法
吧。这个事件将会很简单，它的名字是 onChange ，可以用来告诉用户组件
的内容已经改变了。要定义一个事件，我们只需定义一个与之对应的属性，
然后加入一些数据字段来储存对应的方法指标即可。以下就是 DateEvent范
例项目中，新增的一些定义：  
type  
   TDate = class  
   private  
     FOnChange: TNotifyEvent;  
     ... 
   protected  
     procedure DoChange; dynamic;   
     ...  
   public   
     property OnChange: TNotifyEvent read FonChange write FOnChange;   
     ... 
   end;   
 筆記   
 305 这些属性的 定义实在相当简单。 使用这个类别的开发人员可以指派一个新的
值给它，然后这个值会被存放在私有区的数据字段 FOnChange 里面。在程
序启动的时候，这个数据字段通常是未被指派的 : 事件处理程序是给组件的
用户用的， 不是给组件的制作者用的。 组件的制作者如果需要一些规则的话，
则需要在组件方法中加入。  
 
换句话说， TDate类别单纯的接收到一个事件处理程序，当日期数据被改变
成，就呼叫储存在 FOnChange 字段的方法。当然，这个方法只会在事件的
属性有被指派的时候才会被呼叫。  
 
DoChange 方法 (以动态方法来宣告，是传 统对事件触发方法的处理准则 )会
先进行检测，并呼叫该方法：  
procedure TDate.DoChange;  
begin  
   if Assigned (FOnChange) then   
     FOnChange (Self);   
end;   
_________________________________________________________________________  
您可能还有印象，在第八章里面，动态方法跟虚拟方法是类似的，但在实
作上有些不同，动态方法节省了内存的用量，并节省了相 当多的时间。  
 
DoChange 方法会在每次数值改变的时候被呼叫，就像以下的程序所示：  
procedure TDate.SetV alue (y, m, d: Integer);   
begin  
   fDate := EncodeDate (y, m, d);  
   // fire the event  
   DoChange;  
 
现在，如果我们深入看一下使用这个类别的城市，我们可以简化一下程序代
码。首先我们为窗体类别加入一个自定的方法 : 
type  
   TDateForm = class(TForm)  
     ...  
     procedure DateChange(Sender: TObject);   
 
这个方法里面的程序代码会简单的把目前的卷标文字改为 TDate对象的
Text属性的文字内容。  
 筆記   
 306 procedure TDateForm.DateChange;   
begin   
   LabelDate.Text := TheDay.Text;  
end;  
 
而事件处理程序则会在 FormCreate 方法里面被指派 : 
procedure TDateForm.FormCreate(Sender: TObject) ;  
begin   
   TheDay := TDate.Init (7, 4, 1995);   
   LabelDate.Text := TheDay.Text;   
   // assign the event handler for future changes   
   TheDay.OnChange := DateChange;   
end;   
 
这看起来动作很多， 难道我们刚刚说事件处理程序可以省下很多程序代码是
骗人的吗 ?并没有，我们在加入一些程序代码之后，现在我们可以完全不用
再去管日期内容被修改的时候 要怎么更新文字卷标了。 以下是另一个简单的
按钮的 OnClick事件：  
procedure TDateForm.BtnIncreaseClick(Sender: TObject);  
begin   
   TheDay.Increase;  
end;  
 
相同的简单程序代码也在很多其他的事件处理程序中出现。 一旦我们指派了
事件处理程序，就不用再一直去想着要更新文字卷标了。这把程序中一个很
明显的潜在原始码错误给去除了。 我们还得记得要在程序开始的地方写一些
程序代码，因为这是个简单的类别，不是组件。如果我们处理的是组件，就
只要在组件查看器的事件列表中建立一个事件处理程序， 然后在里面写一行
程序，更新文字卷标的内容，就打完收工了。  
 
这也带出了另一个问题，到底在 Object Pascal 里面写个组件是有多困难 ?其
实真的很简单，我们在接下来这几个小节来介绍一下。  
_________________________________________________________________________  
其实以下的篇幅只是很简短的以属性、事件的角色来稍微提一下写组件的
方法，对这些功能的基本理解，是对每个 Object Pascal 都很重要的。本书
不会讲解太多关于撰写自定组件的细节。  
 
 筆記   
 307 建立TDate组件 
现在，我们已经理解属性跟事件了，下一步我们要来看一下，什么是组件。
我们透过把 TDate类别转换为组件来简单的探索一下这个主题。首先，我们
必须从 TComponent 类别来衍生出我们的新类别，这里不再从 TObject来衍
生了，以下是范例程序代码：  
type  
   TDate = class (TComponent)  
     ...  
   public   
      constructor Create (AOwner: TComp onent); overload; override;   
      constructor Create (y, m, d: Integer); reintroduce; overload;   
 
我们可以看到，第二步就是帮这个类别加入一个建构函式，我们把默认的组
件建构函式重载，以提供一个适当的数据初始化。因为有一个多载的版本，
我们也需要为它用上 reintroduce 这个关键词，以避免编译程序显示警告讯
息。新的建构函式就简单的设定了今天的日期，在呼叫基础类别的建构函式
之后 : 
constructor TDat e.Create (AOwner: TComponent);   
var  
  Y , D, M: Word;  
begin  
   inherited Create (AOwner);  
   // today...  
   fDate := Date;  
 
完成到这里之后，我们需要在撰写这个新的组件类别的单元 文件里面，加入
一个名为 Register的程序 (DateComp 范例项目里面的 Dates单元文件 )。(这
个程序的第一个字母 R务必大写，以免它被误认 )。加入这个程序则是 IDE
要新增一个组件的规范。简单的宣告这个程序， 它不需要任何参数，在这个
单元文件的 interface区段宣告，然后再于 implementation 区段里面撰写程序
代码 : 
procedure Register;  
begin  
   RegisterComponents ('Sample', [TDate]);   
end;   
 
这程序代码把新的组件加入到工具盘的 Sample分页当中，如果当时没有这 
 308 个分页，系统就会自动新增这个分页。  
最后一个步骤就是把这个写好的组件安装好。我们得建立一个套件
(Package) ，这是一种特殊的项目，专门用来安装组件用的。我们只需要 先点
选IDE的File->New ->Other menu 选单项目，打开新增项目的对话窗口，然
后选 Package。 
 
最后把这个套件取个名字存盘 (可以在该组件的目录中直接把这个套件项目
档存起来 )。 
 
在新建的套件项目中，请看 Project Manager 这个画面，在内容节点上点鼠
标右键，然后为这个项目加入一个新的单元文件，当然就是把刚刚制作好的
TDate组件类别的 文件加入啰。  
 
现在我们再次在 Project Manager 画面上用鼠标右键点击套件项目，先选取
里面的 Build选单项目， 建置整个套件， 然后再选取鼠 标右键选单中的 Install，
就可以把我们刚刚写好的 TDate当成一个组件安装到 IDE的工具盘了。  
 
如果您下载了本书的范例项目， 那您开启套件项目之后就只需要做上述最后
的两个步骤：建置、安装即可。  
 
我们现在建立一个新的项目，然后把目光移到工具盘上面，应该就可以在
Sample分页里面看到刚刚这个新的组件 (TDate)了。我们可以直接键入
TDate，应该就可以直接搜寻到这个组件了。此时我们就可以把该组件直接
拖拉到窗体上面，也可以从组件查看器上面来处理它的属性了，就如图 10.3
所示。我们也可以更简单的处理 OnC hange这个事件了，很简单，对吧 ? 
_________________________________________________________________________  
  
 
 
  
 
 
除了我们自己写一个新的项目来使用这个组件 (我强烈建议您应该要试试
看)，您也可以打开 DateComponent 范例项目，这是我们在上一节里面一步
一步制作出来的组件的更新版。这是 DateEvent 范例项目的简化版，因为现
在事件处理程序已经可以直接从对象查看器来处理了。  
 
 圖10.3: 在物件
檢視器當中顯示
我們剛做好的
TDate元件屬性  
 
 309 __________________ _______________________________________________________  
如果您在编译、安装好组件之前就打开 DateCompTest 范例项目的话， IDE
会认不得当中的组件，所以会有错误讯息，记得先把组件安装好喔。  
 
在类别中实作对于列举功能的支持  
我们在第三章里面介绍了以 for-in循环来作为传统的 for循环的替代方案，
在该节里面，我们介绍了如何对数组、字符串、集合以及其他的系统数据型
别使用 for-in循环。对任何类别都可以用这种循环来处理，只要该类别有支
持列举功能。 大多数的例子都是内部有一些列表的类别， 从技术的观点来看，
这个功能是相当具有扩充性的。  
 
我们在 Object Pascal 中实作让类别支持元素列举的功能时， 有两个规则是我
们必须要依循的：加入一个名为 GetEnumerator 的方法，让它回传一个类别
(真的会处理列举动作的类别 ); 为这个列举动作的类别定义 Next方法与
Current属性。 Next方法提供在元素之间来回移动的功能， Current则回传实
际的元素。一旦这两个规则加好了 (我也会介绍如何使用 Current这个属性 )，
编译程序就能够解析 for-in循环，在这循环里面，要处理的目标是我们的类
别，当中的每个元素都必须跟列举功能的 Current属性型别相同。  
 
即使这并不是非要不可的，看起来为类别实作列举功能，把类别当做嵌套类
型(我们在第七章已经对这个功能做了介绍 )会是个好主意，因为硬要在特定
的型别上面用到列举这个功能，其实也没什么意义。  
 
以下的类别是 NumbersEnumerator 范例项目的一部分， 会储存一个范围的数
字(抽象集合的一种 )，并允许从这些数字之中进行列举。这也就使得该类别
可以定义列举功能，以嵌套类型进行宣告，并以 GetEnumerator 函式进行回
传: 
type  
   TNumbersRange = class  
   public  
      type  
        TNumbersRangeEnum = class   
        private  
             nPos: Integer;  
             fRange: TNumbersRange;  
        public  筆記   
 310            constructor Create (aRange: TNumbersRange);   
           function MoveNext: Boolean;   
           function GetCurrent: Integer;   
           property Current: Integer read GetCurrent;   
        end;   
     private  
         FnStart: Integer;  
         FnEnd: Integer;  
     public  
         function GetEnumerator: TNumbe rsRangeEnum;   
         procedure set_nEnd(const V alue: Integer);   
         procedure set_nStart(const V alue: Integer);   
         property nStart: Integer  read FnStart write set_nStart;   
         property nEnd: Integer read FnEnd write set_nEnd;  
     end;   
 
GetEnumerator 方法建立一个嵌套类型的对象用以储存列举出来的状态信
息。 请留意列举类别的建构函式是如何在该对象被列举时保留该对象的参考
的(对象会以 self这个参数被传递 )，并在最初设定好起始对象的位置 : 
function TNumbersRange.GetEnumerator: TNumbersRangeEnum;   
begin   
   Result := TNumbersRangeEnum.Create (self);   
end;   
 
constructor TNumbersRange.TNum bersRangeEnum. Create(aRange: TNumbersRange);   
begin  
    inherited Create;  
    fRange := aRange;  
    nPos := fRange.nStart - 1; 
end;   
_________________________________________________________________________  
为何建构函式会把第一个数值设定成 -1呢，而不是如一般期望的设定成第
一个数值呢 ?这披露了编译程序 为for-in循环建立的程序代码中，对应着建
立出的列举功能，以及程序代码 while Next 没有使用 Current这属性。测试
的动作会在取出第一个值之前就先进行，当整个列表里面还没有任何值存
在时。这也披露了 Next会在第一个元素被使用前就先被呼叫过。这样的作
法不需要太复杂的逻辑，上述的例子就简单的把初始值设定成 -1，好让第
一个值被使用前就会呼叫 Next方法的副作用消匿于无形。  筆記   
 311  
最后，列举方法会提供一个能够存取到资料的途径，以及可以读取列表中下
一个元素的方法 (或者在范围中下一个元素 ): 
function T NumbersRange.TNumbersRangeEnum. GetCurrent: Integer;   
begin  
   Result := nPos;  
end;   
 
function TNumbersRange.TNumbersRangeEnum. MoveNext: Boolean;   
begin  
   Inc (nPos);  
   Result := nPos <= fRange.nEnd;  
end;   
 
我们在上述的程序代码里面可以看到， Next方法满足了两种不同的需求，
一到列表中的下一个元素， 以及检查列表是否已经到了尽头，如果已经到了
尽头，这方法就会回传 false。 
 
完成了所有程序代码以后，我们现在就可以用 for-in循环来列举出整个饭物
的物件了：  
var 
   aRange: TNumbersRange;  
   I: Integer;  
begin  
   aRange := TNumbersRange.Create;   
   aRange.nStart := 10;   
   aRange.nEnd := 23;   
 
   for I in aRange do  
     Show (IntTo Str (I));  
 
执行的结果就很单纯的把列表中的数值列出来，从 10到23之间 : 
 10 
 11 
 12 
 13 
 14 
 15  
 312  16 
 17 
 18 
 19 
 20 
 21 
 22 
 23 
 
结合RAD开发环境跟 OOP的15个小提示  
在这一章里面，我们介绍了属性、事件、发布 (published) 关键词，这些功能
把核心的语言功能跟快速开发环境，或者说视觉开发，也可以说是事件驱动
程序写法 (这三个名词在概念上几乎是相同的模式 )关连在一起。这个模式非
常强大，它是以非常坚固的 OOP为基础的。 RAD的要求与功能常 常让开发
人员忘却了好的 OOP实务作法。 与此同时， 回归纯粹的程序撰写， 忘却 RAD
的要求与功能则常常失去效率。在本章的最后一节，我要列出一些结合这两
个功能的提示跟建议。 我们也可以把这一节称为 ”超越在 RAD之上的OOP”。 
_________________________________________________________________________  
本章最后一小节的材料，是从 1999年七月份发行的 ”The Delphi Magazine”
的第 17个议题而来的。当时该篇文章的标题是 ”用Delp hi写OOP的20个
规则”。现在我删去了部分规则，把其他的做了些整理，剩下来的这些，每
个都很必要。  
 
  提示一 :窗体是个类别  
开发人员常常会把窗体当作对象，但事实上窗体是类别。之间的差异在于我
们是否会拿相同的窗体类别来建立多个窗体对象。  
 
让人搞不懂的原因，是 IDE会预设建立出全局变量以及 (要看我们怎么设定 )
会在程序启动时帮每个项目里面的窗体类别都先产生一个窗体对象出来。 这
对初学者来说很友善，很容易上手，但对于任何并不直觉的应用程序来说，
并不是个好习惯。  
 
当然， 帮每个窗体 (以及窗体型别 )、 单元文件取个有 意义的名字是很重要的。
不幸的，这两个名字必须不同，但我们可以自己定个不成文的规则让两者之
间容易被辨识 (例如 AboutForm 跟About.pas) 。 
 筆記   
 313 当我们在处理以下的步骤时， 就会发现到 ”窗体是个类别 ”这个概念是很实用
的了。  
 
  提示二 :为组件命名  
为组件取个容易一眼看出其功能的名字也是很重要的。最常用的命名方法，
是用一些小写字母为类别型别， 然后把该组件的角色放在前面， 例如 btnAdd
或者 editName 。这些都是使用这类规则，很类似的注记法。很难说哪种命
名方法最好，这要看你自己的喜好了。  
 
  提示三 :为事件命名  
为属性或者事件处理方法命名也一样的重要。如果我们把组件命名得宜，例
如预设的名称是 ButtonClick ，变成 btnAddClick 。即使我们可以从按钮的名
字猜出那个方法的作用，但能够从方法的名称一眼看出该方法的作用，而不
是该方法何时会被触发还是比较好的。举例来说， btnAdd按钮的 OnClick
事件可能被命名为 AddToList ，如果这是该方法要做的动作。  
 
这会让程序代码更具可读性， 特别是当我们需要从另一个类别的法中呼叫事
件处理程序时， 也可以帮助开发人员把同一个方法指派给多个不同组件的事
件，即使我得说使用 Actions来把同一个事件指派给多个用户接口的元素是
比较好的作法，尤其是对任何一个不直觉的程序来说。  
 
  提示四 :使用窗体的方法  
如果窗体是类别，它的程序代码就会被集结成方法。除了事件处理程序，事
件处理程序扮演了一个特别的角色，但还是可以像其他方法一样被呼叫，它
对于在窗体类别中加入自定方法是很有用的。 我们可以加入方法来执行动作
与存取该窗体的状态。为窗体加入公开的方法，比让其他窗体直接存取这个
窗体上头的组件来的好上许多。  
 
  提示五 :建立窗体建构函式  
在运行时间建立的第二个窗体，可以在默认 的建构函式之外，在另外提供特
定功能的建构函式 (从TComponent 类别衍生而来的窗体 )。我的建议是为
Create方法进行多载，加入需要的初始化参数，就像以下的范例程序代码 : 
public  
 constructor Create (Text: string); reintroduce; overload;    
 314  
constructor TFormDialog.Create(Text: string);   
begin   
   inherited Create (Application);   
   Edit1.T ext := Text;   
end;  
 
  提示六 :避免使用全局变量  
应该避免使用全局变量 (在此是指宣告在单元文件的 interface部分的变量 )。
以下是一些协助您做到这点的建议。如果您需要为窗体加入额外的储存数
据，请在私有区加入一些数据字段。这样一来每个窗体实体就都可以有自己
的一份数据了。  
 
我们也可以使用单元文件变量 (在单元文件的 implementation 区段宣告 )，这
种变量是期望在同一窗体类别的多个实体之间进行数据共享， 但这个作法比
使用类别的数据字段更好 (我们会在第十二章说明 )。 
 
  提示七 :绝不要在TForm1 的方法中使用 Form1  
我们绝不能在类别的方法中提及特定的对象。换句话说，在 TForm1类别的
任何方法里面，绝对不要直接用 Form1这个变量。如果需要参考到目前的
窗体对象，请用 self关键词。请牢记在心，大多数的时间都不需要直接写出
变量名称，当我们希望能够参考到目前这个对象的方法或数据时。如果您不
遵循这个规则，在建立多个窗体实体的时候，就会遇上大麻烦了。  
 
  提示八 :少在其他窗体里面用 Form1  
即使是在其他窗体的程序代码里面，也尽量不要直接参考到全局对象，例如
Form1。最好还是宣告局部 变量，或者私有区的数据字段来参考其他窗体。
例如，一个程序的主窗体可能拥有一个参考到对话框的私有数据字段。显然
的，如果我们计划要让第二个窗体类别建立多个实体时，这个规则就变得很
必要了。我们可以在主窗体里面建立一个动态数组，或者直接用全局对象
Screen的Forms变量来参考目前应用程序中的任何一个窗体。  
 
  提示九 :去除全局的 Form1变数 
事实上，我的建议是，当我们把一个窗体加入项目的时候，拿掉 IDE自动 
 315 帮我们建立的全局 form对象，像是 Form1。这个可能性只在我们取消自动
建立该窗体的功能时。我建议的这 个动作是让您可以摆脱 IDE的某些副作
用。而您可以删掉某些对应的程序代码，就是被放在项目档里面那些用来自
动建立窗体实体的程序代码。  
 
我想，对于 Object Pascal 的初学者来说，去除全局的窗体对象是很有用的，
因为初学者就不会再被类别跟全局对象搞混了。事实上，移除了全局对象之
后，所有参考到这个对象的程序代码都会发生错误了。  
 
  提示十 :加入窗体属性  
犹如我在本章的 ”为窗体加入属性 ”小节所说的， 当我们需要在窗体里储存数
据的时候，就加一个私有的数据字段。如果我们需要从别的类别存取这个数
据，并且为这个窗体加入 属性。为了这个要求，我们可以改变窗体的程序代
码跟它的资料 (包含在它的用户接口中 )而不改动任何其他窗体或类别的程
序代码。我们应该也要使用属性跟方法来为第二个窗体或对话框做初始化，
然后读取它的最终状态。初始化的动作也是使用建构函式，如我已经说过的
那样。  
 
  提示十一 :把组件属性披露  
当我们需要存取另一个窗体的状态，我们无法直接参考它的对象。这样会把
其他的窗体或类别的程序代码跟用户接口 (这是应用程序的移植当中变化最
大的 )绑定在一起。另外，宣告一个窗体的属性会对应到关联到组件的属性：
这会以一个用来读取组件状态的 Get方法，以及用来写入它的 Set方法。假
设我们现在修改了用户接口，把组件替代另一个。而我们能够做的，就是把
Get跟Set方法修得跟零一个组件一样。我们不用检查或更改任何一个使用
到这个组件 文件得方法。  
 
  提示十二 :适时的在需要使用数组属性  
如果我们需要在窗体里面处理一系列的值，可以宣告一个数组属性。假如这
个信息对窗体来说很重要，我们也可以把它设定为窗体的默认属性，那我们
就可以直接存取这些属性了，语法上可以直接写成 SpecialForm[3] 。这个作
法已经在本章里面 ”使用数组属性 ”那一小节里面透过几个一般的 案例介绍
过了 (不过该案例没有使用窗体类别就是了 )。 
  
 316   提示十三 :使用属性的副作用  
记得使用属性，而不要直接存取全局数据的优点之一，就是在读写属性的时
候，我们可以顺便做一些相关的动作。例如我们可以在设定很多属性的内容
时，顺便把窗体的画面直接更新一下，或者呼叫其他方法，甚至可以一次把
多个组件的状态更新，或者在需要的时候触发事件。  
 
另一个相关的范例是使用属性的取得函式 (getter)来实作延迟建立。 在类别的
建构函式里面不建立子对象， 我们可以在该对象第一次被要求存取的时候才
建立，可以写成像这样 : 
privat e 
   FBitmap: TBitmap;  
public  
   property Bitmap: TBitmap read GetBitmap;   
 
function TBitmap.GetBitmap: TBitmap;   
begin   
   if not Assigned (FBitmap) then   
     FBitmap := ... // create it and initialize it   
   Result := FBitmap;  
end;  
 
  提示十四 :隐藏组件  
我很常听到 OOP的狂热份子这么抱怨 : 在窗体里面的发布区里面放了一堆
组件。岂不是就不符合封装的精神了吗 ?他们的确只出了一个重要的问题，
但大多数人似乎并没有意识到不用重写函式库或变更程序语言的解决方法
就在眼前。窗体上面各个组件的参考可以搬到私有区，这样就不能直接被其
他窗体存取，接着我们可以把组件宣告成属性 (请见前面的几个小节 )，这样
就刀切豆腐两面光，既符合了封装的精神，又可以让组件存取很有弹性了。  
 
如果 IDE把所有的组件都放在发布区。这是因为要能够把窗体透过串流化
储存到文件里面 (DFM檔或者 FMX檔)。当我们为组件命名之 后，VCL会自
动把该组件的对象与参考都加到窗体里面去。 这也只有当该组件的参考是位
于发布区才办的到，因为串流系统使用了传统的 RTTI跟一些 TObject的方
法来完成这个功能。  
 
所以如果我们直接把组件的参考从发布区搬到私有区， 我们就会遗失这个自 
 317 动建立的规则。要解决这个问题的话，只要把这个动作改成人工处理，把以
下的程序代码加入到窗体的 OnCreate 事件处理程序即可：  
Edit1 := FindComponent('Edit1') as TEdit;   
 
我们得做的第二个动作则是在系统中注册这个组件类别，这样 RTTI信息才
会能够在编译后的程序中，以及 IDE系统里面使用。这动作对每个组件类
别都只需要做一次， 且只有当我们把属于该型别所有组件的参考都搬到私有
区的时候才需要。我们可以把这个函式加入到程序代码里面，就算用不到也
没关系，呼叫 RegisterClasses 这个方法对系统没有负面影响。这个方法通常
是在储存该类别的单元文件的初始区段 (initialization section) 里面呼叫的：  
RegisterClasses([TEdit]);  
 
  提示十五 :使用OOP窗体精灵  
一直重复前面讲到的，对每个窗体里面每 个组件做两个处理程序真的很无
聊，也很花时间。为了免除这些沉重的负担，我写了一个简单的精灵，在一
个小窗口里面把这些程序代码加到程序里面去。 您只要简单的把这些产生好
的程序代码剪贴到每个窗体里面就行了， 因为这个精灵不会自动把原是码放
到单元文件的初始区段里去。  
 
要怎么拿到这个精灵 ?您可以在以下网址里面找一下 ”Cantools Wizards”:  
http://www.marcocantu.com/tools   
 
  提示结论 (延伸阅读 ) 
以上只是一些提示的简单整理，以及让您在 RAD跟OOP开发模式中取得
更好平衡的 一些建议。当然关于这个主题还有更多的东西要讲，已经超越本
书要介绍的范畴了，本书主要是集中介绍语言本身，而不是如何找到最佳的
应用程序架构。  
 
透过我的部落格，您可以找到更多 Delphi的原始码，但我觉得该特别介绍
的，应该是 Nick Hodges 最近的书，包含 ”Coding in Delphi” ，您可以在这个
网址找到 : 
http://www.codingindelphi.com/   
  
 318 11:界面 
 
相异于 C++跟一些其他的程序语言， Object Pascal 的继承模式并不支持多重
继承。这表示每个类别都只有一个 相同的基础类别。多重继承的功效一直
都是被热烈讨论的议题。 Object Pascal 不使用多重继承这个功能，一直都是
两面评价，说这是缺点的人，就说这样一来功能就没有 C++强，说这是优
点的人，就说这可以简化语言本身，并避免掉不少麻烦。  
_________________________________________________________________________  
今天大多数的面向对象程序语言并不支持多重继承，而改为使用接口
(interface) ，包含 Java跟C#。多重继承的支持目前大多受限 于C++语言。
一些动态的面向对象程序语言则支持 mixins，这是另一个达到类似多重继
承功能的方法。  
 
接口提供了弹性、让类别能够宣告支持多个接口，并加以实现的能力，同
时避免因多重继承而可能产生的问题。为了避免陷入这个讨论的泥淖，我
很简单的假设能够从多种面相来处理一个对象是有用的，把它想成是一个
对象拥有多个不同的基础类别。但在我们用这个理论建立范例之前，我们
得先介绍在 Object Pascal 里面，接口所扮演的角色，以及它的工作原理。  
 
从一个宏观的角度来看，接口比类别支持了更多不同的面向对象程序设计
的模式。 实作接口的对象，可以视作它所实作的每个接口的多重型态，实
际上以接口为基础的模式是很强的。但在提到这一点之前，我并不想试着
到底哪种要求比较好。当然接口比较偏重在封装，并提供给类别之间一种
比继承更宽松一点的连结。  
_________________________________________________________________________  
在本章所介绍的技术，是在 Object Pascal 发展之初就已经被支持，并用来
实作 Windows COM 架构了。后来这个功能又被延伸在该情境之外，成为
可以广泛使用的技术，但 COM里面的一些元素，例如接口代号、参考计数
这些功能， 仍然留在了 Object Pascal 对接口的实作当中， 也使得 Object Pascal
跟其他语言有明显的不同。  
 
使用接口  
除了宣告抽象类 (拥有抽象方法的类别 )，在 Object Pascal 里面我们也可以撰
写纯粹的抽象类 ;也就是只包含虚拟抽象方法的类别。透过一个特别的关键筆記  
筆記   
 319 词来达成，就是 interface。为了这个原因我们把这些数据型别定位为 接口
(interfaces) 。事实上，从技术面来看，接口不算是类别，虽然接口可以重组
类别。因为类 别可以建立实体，但接口不行。接口可以被一个或多个类别
加以实作，所以这些实体就可以算是 支持了或者实作了该接口。  
 
接口有一些独特的功能 : 
 接口型别的变量会使用参考计数，跟类别型别的变量不同  
 类别是从单一前代类别继承而来，但可以实作多个接口  
 就像所有类别都是自 TObject衍生而来，所有的接口都是从 IInterface
衍生出来的，两者各归属于独立、正交的架构  
 
透过不成文的约定，接口的名称以 I大写字母开头，跟类别的 T大写字母
是不同的。  
______________________________________ ___________________________________  
起初在 Object Pascal 里面基础的接口型别被称为 IUnknown ，这是 COM所
需求的。而最近几年， IUnknown 界面被更名为 IInterface ，为了强调这个事
实，您仍然可以在没有使用 COM的情形下使用接口，即使在没有 COM存
在的操作系统里面也一样。反正， IInterface 的实务规则仍然跟 IUnknown
完相同。我们可以用接口来实作应用程序的抽象层面，不一定要建立 COM
服务器对象也可以。  
 
  宣告界面  
这些是核心理论，让 我们来看看实际的例子吧，实例会帮助我们了解
Interface 在Object Pascal 是如何作业的。在实务层面，接口的定义就像类别
的定义写法。这个定义包含有一些方法，但这些方法不用实作，就像在一
般类别里面的抽象方法一样。  
 
以下就是一个接口的定义 : 
type  
   ICanFly = interface  
     function Fly: string;  
   end;  
 
假设每个接口都直接或间接的从基础接口型别继承而来，相对的写法就变
成了 : 
type  
   ICanFly = interface ( IInterface)   筆記   
 320       function Fly: string;  
   end;  
 
稍后我们会说明从 IInterface 继承的含义为何，并作一个比较表。现在我们
就先把 IInterface 也有一些基础类别的方法吧 (再提一下， 跟 TObject不一样 )。 
 
还有跟接口宣告相关最后一个重点。对接口来说，部分的型别检查是动态进
行的，系统要求每个接口都要具备一个唯一的标识符，或者称为 GUID，我
们可以在 IDE里面按下 Ctrl+Shift+G ， 编辑环境就会自动帮我们产生一组了。
以下是接口宣告的完整程序代码 ： 
type  
   ICanFly = interface  
      ['{D7233EF2 -B2DA -444A -9B49 -09657417ADB7}']   
      function Fly: string;  
   end;  
 
这个接口跟相关的实作都可以在 Intf101范例项目里面找到。  
_________________________________________________________________________  
虽然我们就算没指定 GUID给接口，编译程序也仍然可以编译成功，我们
也会想要建立出 GUID给它，因为在进行接口查询，或者透过 as进行动态
型别转换的时候都会用到 GUID。接口的重点，是因为它在运行时间具备了
强大的扩充性，这些都是因为接口拥有 GUID。编译程序把接口 ID用来替
代我们的程序代码的唯一情形，会是因为它从通用接口来建构实际的接口，
这个主题我们在第十四章以前都不会提到。  
 
  实作界面  
任何类别都可以实作接口 (个数不限 )，只要把它们列在基础类别后面，并且
提供这些接口方法的执行程序代码即可：  
type  
   TAirplane = class (..., ICanFly)  
      function Fly: string;  
   end;  
function TAirplane.Fly: string;   
begin   
    // actual code  
end;  
当类别实作接口的时候，它必须 提供该接口所有方法 (参数也必须要跟接口筆記   
 321 中该方法的宣告完全相同 )的实作， 所以在本例中的 TAirplane 类别就必须实
作Fly方法，该方法必须回传一个字符串。假设这个接口也是从一个基础接
口衍生而来，这个类别就必须实作出该接口，以及其基础接口的所有方法。  
 
这就是为什么从已经实作了 IInterface基础接口的基础类别衍生新的类别
时，在新类别中实作该接口也相当常见的原因。 Object Pascal 运行时间函式
库已经提供了一些基础类别是已经实作好基本的方法的。 最简单的一个就是
TInterfacedObject 类别，这个程序代码就会变成：  
type  
   TAirplane = class (TInterfacedObject, ICanFly)   
      function Fly: string;  
   end;  
____________________________________ _____________________________________  
当我们实作接口时，我们可以选择以静态或虚拟方法来实作。如果我们准
备在衍生类别里面重载方法，使用虚拟方法就有意义。然而同一个功能也
有替代作法，我们可以指定基础类别也继承同一个接口，然后把重载该方
法。我建议需要的时候，把接口的方法宣告为虚拟方法，这样可以保留未
来的扩充弹性。  
 
现在我们已经定义了一个接口，以及用来实作它的类别。我们可以为这个类
别建立物件，就把它当成一般类别来对待，可以这么写 : 
var 
  Airplane1: TAir plane;  
begin  
    Airplane1 := TAirplane.Create;  
    try 
       Airplane1.Fly;  
    finally  
        Airplane1.Free;  
    end;   
end;   
 
然而我们也可以用接口作为型别来宣告变量，这会自动启动参考内存模式：  
var 
  Flyer1: ICanFly;  
begin  
    Flyer1 := TAirplane.Create;  
    Flyer1.Fly;  筆記   
 322 end;   
 
这个简单的程序 片段是从 Intf101范例项目节录出来的，其中的第一行一定
会引发许多联想。  
 
首先，当我们把一个对象指派给接口变量之后，透过 as这个特殊指令，运
行时间会自动检查该对象是否有实作这个接口。我们可以把整个指令这样
写: 
Flyer1 := TAirplane.Create as ICanFly;   
 
其次，看我们是使用了直接指派的方式，或是透过 as指令，运行时间会多
做一件事 : 它会呼叫对象的 _AddRef 方法，增加它的参考计数。这是透过呼
叫了从 TInterfacedObject 衍生而来的对象方法而完成的。  
 
同时，当 Flyer1变量离开了其使用范围 (例如执行到 end区块 )，运行时间就
会呼叫 _Release 方法，接着该变量的参考计数就会自动减一，等到参考计数
变成 0，如果需要，该对象就会自动被释放掉。因为有了这个功能，就没有
必要在程序里面手动控制对象的释放了。  
_________________________________________________________________________  
除了失去手动呼叫释放对象的方法之外，程序也不用再加入 try-finally区块
了。然而，当编译程序会自动在编译的 时候加入呼叫 _Release( 有时可能是
Free)的程序代码，编译程序也会自动的套用 try-finally的机制。这在 Object 
Pascal当中有很多情形都会发生 : 基本上每当一个方法使用了一个或多个
受管理的型别时 (例如字符串、接口或者动态数组 )，编译程序就会在该方法
的程序代码编译的时候自动在背景套用 try-finally区块。  
 
  界面与参考计数  
我们回头看一下上面的程序代码， Object Pascal 的对象被以接口变量进行参
考的时候，会自动进行参考计数。我们也看过它们会自动的在没有接口变量
参考到时 ，会自动把对象释放掉。现在我们注意一下，当一些编译程序的背
景动作涉入时 (在背景呼叫的 _AddRef 跟_Release) ，实际的参考计算器制就
会直接介入程序代码。在前一个例子，参考计数就真的运作了，因为在
TInterfacedObject 类别的方法中， 程序代码是这么写的 (这里仅列出简化过的
版本 ): 
 
function TInterfacedObject._AddRef: Integer;   
begin   筆記   
 323    Result := AtomicIncrement(FRefCount);   
end;   
 
func tion TInterfacedObject._Release: Integer;   
begin   
   Result := AtomicDecrement(FRefCount);   
   if Result = 0 then   
   begin   
     Destroy;  
   end;  
end;   
_________________________________________________________________________  
在支持自动参考计数 (ARC)的行动装置环境里，情况就相当 不同了，因为在
行动装置环境当中，参考计数的机制是同时可以对一般对象跟接口化对象
作用的。因此整个系统都支持这样的机制，该机制执行起来就相当顺畅。
更多关于 ARC,以及接口与 ARC的议题，我们将在第十三章里面来介绍。  
 
现在，我们来思考一下，实作 IInterface 的另一个基础类别：
TSingletonImplementation ，我们也可以在 RTL里面 (在Generics.Default 单元
文件面 )找到它。这个有着一个奇怪名字的类别会把实际的参考计算器制关
闭: 
function TSingletonImplem entation._AddRef: Integer;   
begin   
   Result := -1; 
end;  
function TSingletonImplementation._Release: Integer;   
begin   
   Result := -1; 
end;  
_________________________________________________________________________  
这个类别真的是名不符实， 因为它根本没做任何跟 singleton( 单一组件 )模式
相关的功能。我们会在下一章里面来看一些这个模式的范例。  
 
TSingletonImplementation 不常用到，还有另一个类别实作了接口，并关闭了
参考计算器制，因为它有自己的内存管理模式，而且这也在 TComponent 类
别里面被广为使用。如果我们想要建立一个自定组件，在里面实作界面，我
们就不用担心参考计数跟内存管理了。我们会在本章的最后， ”用接口来实
作设计模式 (Patterns)” 那一小节里面来看一个自定组件的例子，用它来实作筆記  
筆記   
 324 一个界面。  
 
  混和参考的错误  
使用对象的时候，我们应该只透过对象变量或只透过接 口变量来存取对象。
把两种作法混着用会打乱 Object Pascal 提供的参考计算器制， 就可能导致非
常难以发现的内存错误。实务上，如果我们决定要用接口，我们就应该只使
用接口型别的变量。  
 
以下是一个可能发生比较不一样错误的案例。假设我们建立了一个接口，用
一个类别来实作它，并且用一个全局程序用这个接口作为参数：  
type  
    IMyInterface = interface  
       ['{F7BEADFD -ED10 -4048 -BB0C -5B232CF3F272}']   
       procedure  Show;  
    end;  
 
    TMyIntfObject = class (TInterfacedObject, IMyInterface)   
    public   
       procedure Show;  
    end;  
 
procedure ShowThat (anIntf: IMyInterface);   
begin   
   anIntf.Show;  
end;  
 
这段程序看起来很直观，而且百分之百正确。可能发生的错误，只会来自于
我们呼叫它的方法 (这段程序是 IntfError 范例项目 的一部分 ): 
procedure TForm1.btnMixClick(Sender: TObject);   
var  
   anObj: TMyIntfObject;  
begin  
    anObj := TMyIntfObject.Create;  
    try 
       ShowThat (anObj);  
   finally  
      anObj.Free;   
 325    end;  
end;   
 
上面这段程序则是把一个一般的对象传给原本要求接口当做参数的函式。 假
设这个对象没有支持该接口， 编译程序也不会 对这个函式的使用提出可能发
生错误的警告讯息。在这里的问题，是内存管理的方式。一开始，对象的参
考计数会被设成 0，表示没有参数使用到它。在进入 ShowThat 程序的时候，
参考计数会被加成 1。这没问题，程序的呼叫也会正常发生。等程序执行结
束的时候，参考计数会被递减为 0，所以该对象就会被正常释放。换句话说，
当程序结束，回到呼叫该程序的程序区段时， anObj对象就会被释放，这实
在相当尴尬。当我们执行这段程序时，则会发生内存错误 (除非我们在支持
ARC的行动装置装置上执行，那么这段程序就会执行的很顺畅 )。 
 
有几个方法可 以解决。我们可以手动增加参考计数的数字，并使用一些低阶
的技巧。但实际的解法，就是不要把接口跟对象的参考混着用，并只使用接
口来指向对象 (以下这个程序代码也是 IntfError 范例项目的一部分 ): 
procedure TForm1.btnIntfOnlyClick(Sender: TObject);   
var  
   anObj: IMyInterface;  
begin  
     anObj := TMyIntfObject.Create;  
     ShowThat (anObj);  
end;  
 
在这个特例里 ，就使用了这个解决方案，但在许多其他的状况下，很难发现
到正确的写法。再次强调，最终解决方案就是不要把不同型别的参考混在一
起使用。  
 
进阶接口科技  
要深入了解接口的能力，在我们探讨在实务上使用的可能情境之前，了解更
进阶的功能是很重要的，像是如何实作多个接口，或是如何用不同的名称来
帮接口的特定方法提供实作 (万一有类别的方法名称重复时 )。另一个重要的
功能，是接口也有属性。为了把这些进阶的接口功能做个示范，我们以
IntfDemo 范例项目来做实例。  
 
  
 326   接口的属性  
本节的范例程序代码是以两个不同的接口为基础的 : IWalker跟IJumper，两
者都定义了一个新的方法跟一个属性。 接口的属性也只是对应了读取跟写入
方法而已。跟类别不同的是，我们不能把接口的属性直接对应到数据字段，
这就只是因为接口不能包含数据字段而已。  
 
以下是实际的接口定义：  
IWalker = interface  
   ['{0876F200 -AAD3 -11D2 -8551 -CCA30C584521}']   
   function Walk: string;   
   function Run: string;   
   procedure SetPos (V alue: Integer);   
   function GetPos: Integer;   
   property Position: Integer  
     read GetPos write SetPos;  
end;   
 
IJumper = interface   
   ['{0876F201 -AAD3 -11D2 -8551 -CCA30C584521}']   
   function Jump: string;   
   function Walk: string;   
   procedure SetP os (V alue: Integer);   
   function GetPos: Integer;   
   property Position: Integer  
     read GetPos write SetPos;  
end;   
 
当我们实作一个具有属性的接口，我们只需要实作其中的访问方法，因为接
口的属性对类别来说是透明的，而且无法直接使用：  
TRunner = class (TInterfacedObject, IWalker)   
private   
   FPos: Integer;  
public  
   function Walk: string;   
   function Run: string;   
   procedure SetPos (V alue: Integer);   
   function GetPos: Integer;    
 327 end;   
 
这段实作程序代码看起来很简单、直觉 (它是 IntfDemo 范例项目的一部分 )，
透过方法来计算新的位置，并显示要显示的的数据：  
function TRunner.Run: string;  
begin  
   Inc (FPos, 2);  
   Result := FPos.ToString + ': Run';   
end;   
 
范例程序代码中使用了 IWalker接口，以及以下的 TRunner 实作程序代码：  
procedure TForm1.Button1Click(Sender: TObject);   
var  
   Intf: IWalker;  
begin  
   Intf := TRunner.Create;  
   Intf.Position := 0;  
   Show (Intf.Walk);  
   Show (Intf.Run);  
   Show (In tf.Run);  
end;   
 
输出的信息应该不让人惊讶 : 
1: Walk  
3: Run  
5: Run  
 
  界面委任  
用类似的方法，我们可以定义一个简单的类别来实作 IJumper接口 : 
TJumperImpl = class (TAggregatedObject, IJumper)   
private   
   FPos: Integer;  
public  
   function Jump: string;   
   function Walk: string;   
   procedure SetPos (V al ue: Integer);   
   function GetPos: Integer;    
 328 end;   
 
这次的实作跟前一版不同的地方，是使用了不同的基础类别 : 
TAggregatedObject 。它是一个用来定义内部支持接口的类别，其语法我们稍
后介绍。  
_________________________________________________________________________  
TAggregatedObject 类别是在 System单元里面定义的另一个有实作 IInterface
的类别。 跟TInterfacedObject 比较一下， TAggregatedObject 对参考计数的
实作方法是不同的 (基本上是把所有的参考计数委任给控制组件或容器组
件)，在控制组件或容器组件中，则实作接口查询的功能。  
 
我们会用不同的方式来使用它。在以下的类别 : TMyJumper ，我不想用类似
的方法来重复实作出 IJumper接口。反之，我想把这个接口的实作委任给已
经实作出该方法的类别来处理。这个作法无法透过继承来达成 (我们无法从
两个类别作为基础类别来衍生一个新类别 )， 幸好我们可以透过 Object Pascal
语言的另一个功能：界面委任来达成这个需求。以下的类别透过把方法参考
指向一个实作了该接口方法的对象，来达成实作该接口方法的需求。这样就
不用实际实作该接口了 : 
TMyJumper = class (TInterfacedObject, IJumper)   
private   
   FJumpImpl: TJumperImpl;  
public  
   constructor Create;   
   destructor Destroy; override;   
   property Jumper: TJumperImpl   
      read FJumpImpl implements IJumper;   
end;   
 
这个需告指出 IJumper接口是由 TMyJumper 类别以 FJumpImpl 数据字段加
以实作的。当然，这个字段必须实际上实作出该接口的所有方法。为了让这
个作法行得通，我们需要在 TMyJumper 对象被建立的时候 (建构函式的参数
是由身为基础类别的 TAggregatedObject 类别所要求的 )，为这个数据字段建
立一个适当的对象 : 
constructor TMyJumper.Create;   
begin   
   fJumpImpl := TJumperImpl.Create (self);   
end;   
 筆記   
 329 这个类别也有一个解构函式用来释放内部对象， 它会参考到一个一般数据字
段，而不会参考到接口 (因为参考计数在这个情境下不会发生作用 )。 
 
这个范例虽简单，但并不常见，当我们开始修改一些方法，或者加入新的方
法时，仍然需要对内部的 fJumpImpl 对象进行处理。此处的通则则是我们可
以在许多类别中重复使用这个接口的实作。  
 
这个接口中所使用的程序代码是以间接的方式实作界面， 跟标准的程序代码
完全相同，可以写成 : 
proced ure TForm1.Button2Click(Sender: TObject);   
var  
   Intf: IJumper;  
begin  
       Intf := TMyJumper.Create;  
       Intf.Position := 0;  
       Show (Intf.Walk);  
       Show (Intf.Jump);  
       Show (Intf.Walk);  
end;  
 
  多个接口以及方法别名  
接口的另一个很重要的功能，是为类别提供能够实作多于一个接口的 能力。
我们透过以下的 TAthlete来做介绍，它同时实作了 IWalker跟IJumper接口 : 
TAthlete = class (TInterfacedObject, IWalker, IJumper)   
private   
    FJumpImpl: TJumperImpl;  
public  
    constructor Create;   
    destructor Destroy; override;   
    function Run: string; virtual;   
    function  Walk1: string; virtual;   
    function IWalker.Walk = Walk1;   
    procedure SetPos (V alue: Integer);   
    function GetPos: Integer;   
    property Jumper: TJumperImpl   
      read FJumpImpl implements IJumper;   
end;    
 330 其中一个接口是直接被实作出来的，而其他的接口则是透过内部对象
FJumpImpl 进行委任，就像我们在前一个范例中所做的一样。  
 
现在我们面临了一个问题。这两个我们想实作的界面，都有一个名为 Walk
的方法，它们除了名称相同，参数也完全一样，所以我们要怎么在一个类别
里面同时实作它们呢 ?Object Pascal 语言里面是怎么处理多个接口中的方法
名称重复的呢 ?解决方法就是把其中一个方法改名，可以透过以下这种写法 : 
function IWalker.Walk = Walk1;  
 
这个宣告是指该类别会用 Walk1这个方法来实作 IWalker接口的 Walk方法
(代替用具有相同名称的方法 )。 最后， 在这个 类别当中对所有方法的实作里，
我们需要参照到内部对象 FJimpImpl 的Position属性。透过为 Position属性
宣告一个新的实作方法，我们最后可以得到两个独立的 athlete对象，这是
一个奇怪的状况，以下就是这个范例的两个方法 : 
function TAthlete.GetPos: Integer;   
begin   
   Result := FJumpImpl.Position;  
end;  
 
function TAthlete.Run:string;   
begin   
   fJumpImpl.Posit ion := FJumpImpl.Position + 2;   
   Result := IntToStr (FJumpImpl.Position) + ': Run';   
end;   
 
我们要怎么为 TAthlete对象建立一个接口， 同时把它指向 IWalker跟IJumper
接口 ?好吧，我们的确不能那样作，因为并没有我们可以使用的基础接口。  
然而，接口允许更动态的型别检查与型别转换，所以我们可以把一个接口转
换成另一个，只要我们所使用的对象的确同时支持两种接口，编译程序就能
在运行时间中找到让这转换兼容的蛛丝马 迹。以下就是这种情形的程序代
码: 
procedure TForm1.Button3Click(Sender: TObject);   
var  
   Intf: IWalker;  
begin  
   Intf := TAthlete.Create;  
   Intf.Position := 0;  
   Show (Intf.Walk);   
 331    Show (Intf.Run);  
   Show ((Intf as IJumper).Jump);  
end;  
 
当然，我们可以挑选这两个接口的其中之一，然后把它转换成另外 一个。透
过as指令作转换是我们可以进行运行时间型别转换的方法之一，但我们还
有更多方法可以用来处理接口，就像我们在下一节要介绍的那样 : 
 
  界面的多型  
在前一节，我们已经介绍过，我们可以定义多个接口，然后用一个类别来实
作其中的两个接口。当然，这也可以延伸成多个，数量不拘。我们也可以建
立一个接口架构，因为接口也可以从一个既存的接口衍生而来：  
ITripleJumper = interface (IJumper)   
    [‘{0876F202 -AAD3 -11D2 -8551 -CCA30C584521}’]   
    function TripleJump: string;   
end;   
 
这个新的接口型别包含了其基础接口的所有方法，并新增了一个新的方法。
当然，接口兼容性的规则也跟类别一样。  
 
我们在这一节里面想要强调的是一个相当不同的主题， 也就是以型别为基础
的多型 (polymorphism) 。假设有一个一般的基础类别对象，我们可以建立一
个虚拟方法，并确定正确的版本可以被呼叫。同样的作法也适用于接口。  
 
然而，透过接口，我们可以向前迈进一步并常可以透过接口的查询提供动态
程序。假设对象跟接口的关系可以很复杂 (一个对象可以实作多个接口，并
间接的也实作这些接口的基础接口 )，那么描绘出这种情境可以做到的未来
就显得更为重要。  
 
首先，假设我们有一个通用的 IInterface 参考，我们怎么知道这个接口的参
考有没有支持哪一个特定的接口呢 ? 这里面包含多种技术， 明显的跟类别的
对应不太一样 : 
 
透过 is指令进行测试 (然后或许可以使用 as进行接下来的型别转换 )。这可
以用来检查一个对象是否支持该接口， 但如果一个对象所参考的接口也支持
另一个接口就不行了 (也就是说，我们不能用 is来判断接口的从属关系 )。请
注意到，任何情况下，使用 as来进行转 换都是必要的 :直接把接口型别进行 
 332 转换，几乎不会有任何侥幸，都会发生错误。  
呼叫全局函式 Support，使用它众多的多载版本之一，我们可以把要检查的
对象 (或者接口 )以及要检查是否兼容的接口 (透过 GUID或者接口的型别名
称)，当成参数传递给这个函式。如果这个检查过关了，我们就可以把这个
接口变量传给实际上要用来储存该接口的变量了。  
 
直接呼叫 IInterface 基础接口的 QueryInterface( 这个作法则是比较低阶的作
法)，永远要求一个接口变量作为额外的结果，并且会使用 HRESULT 数值
作为回传值，不是布尔 值喔。  
 
以下是从 IntfDemo 范例项目节录的简单程序代码范例，用来介绍刚刚介绍
的两种使用通用的 IInterface 变量的技术 : 
procedure TForm1.Button4Click(Sender: TObject);   
var  
   Intf: IInterface;  
   WalkIntf: IWalker;  
begin  
   Intf := TAthlete.Create;   
   if Supports (Intf, IWalker, WalkIntf) then   
      Show (WalkIntf.Walk);  
   if Intf.QueryInterface (IWalker, WalkIntf) = S_OK   
      then Show (WalkIntf.Walk);   
end;   
 
把Support跟QueryInterface 作比较的话， 我建议一定要使用 Support函式来
做检查。因为 Support提供了比较简单、高阶的选项。  
 
另一个情况下，我们可能会想透过接口来使用多型，这个情形是当我们拥有
一个用来储存高阶的接口型别的数组时 (但也可能是一个用来储存对象的数
组，其中可能有部分对象支持一些接口 )。 
 
  从接口参考解析出对象  
这情形可能发生在 Object Pascal 的很多个版本， 当我们已经把一个对象指派
给了一个接口变量，原来的对象就再也没办法被存取了。有时候，开发人员
会在接口中加入一个 GetObject 方法来处理这种情形，但这是个很奇怪的设
计。  
  
 333 在现代程序语言中，我们可以把接口参考转型回原来的对象，我们有三种不
同的方法可以做到这件事 : 
 
我们可以写一个 is测试，来验证一个原本为特定型别的对象是否可以被从
接口参考解析出来 : 
intfV ar is TMyObject  
 
也可以写一个 as指令来进行型别转换，万一出现错误时可以触发一个例外 : 
intfV ar as TMyObject.  
 
最后，还可以直接强制转型，万一出现错误的时候，就回传一个 nil指标 : 
TMyObject(intfV ar)  
_________________________________________________________________________  
在任何情形下，型别转换都只能用在该接口的确是从一个对象转换而来的
时候，从 COM服务器取得该接口的话就不行了。也要记得我们不只可以把
它转换为原始对象的型别，也可以转换为原始对象的任一基础型别 (这当然
是完全遵循着类别兼容性的基本规则喔 ) 
 
我们把以下的简单接口跟实作类别当做个范例 (它是从 ObjFormIntf 范例项
目节录而来的 ): 
type  
   ITestIntf = interface (IInterface)   
     ['{2A77A244 -DC85 -46BE -B98E -A9392EF2A7A7}']   
     procedure DoSomething;  
   end;  
 
   TTestImpl = class (TInte rfacedObject, ITestIntf)   
   public   
      procedure DoSomething;   
      procedure DoSomethingElse; // not in the interface   
      destructor Destroy; override;   
   end;   
 
有了这些定义，我们就可以定义一个接口变量，把这个对象指派到接口变量
去，并且可以使用不存在该接口的方法，透过新的转型指令 : 
var 
   intf: ITestIntf;  
begin  筆記   
 334    intf := TTestImpl.Create;   
   intf.DoSomething;   
   (intf as TTestImpl).DoSomethingElse;   
 
我们也可以用以下的方式来写，使用 is作检测，然后来个直接转型，我们
当然可以把该对象转型成其原来的类别，或该类别的任一基础类别 : 
var 
   intf: ITestIntf;  
   original: TObject;  
begin  
    intf := TTestImpl.Create;  
    intf.DoSomething;  
    if intf is TObject then  
      original := TObject (intf);   
    (original as TTestImpl).DoSomethingElse;   
 
考虑到直接转性在失败时会回传 nil，所以我们也要多加上以下的程序代码
以防万一 (就不用刚刚使用过的 is测试了 ): 
original := TObject (intf);   
if Assigned (original) then   
  (original as TTe stImpl).DoSomethingElse;   
 
要注意，把对象从接口解析出来，然后储存到一个变量里，可能会导致参考
计数的问题 : 当接口变量被指派 nil进去，或者离开执行范围时，该对象就
会被删除，而该对象的参考指针就会变成非法的指标。我们可以从
btnRefCountIssueClick 这个事件处理程序的程序代码里面找到这个问题。  
 
透过接口来实作转换器模式 (Adapter Pattern)  
我在这一章当中加入了一个小节来介绍转换器模式 (Adapter Pattern) 作为程
序设计世界实战中使用接口的例子 。您可以阅读附录 D作为透过 Delphi使
用设计模式 (Design Pattern) 的基本介绍。  
 
简单的说， 转换器模式是用来把一个类别的接口转换成用户的类别中所预期
的另一个。 这方法让我们可以把一个既存的类别当成架构中要求的一个被定
义的接口来使用。我们可以透过建立一个新的类别架构，让这个新的类别有
对应或者从现存的类别衍生、实作需求的接口来完成这个模式的实作。我们
可以用多重继承 (在那些有支持这个功能的程序语言中就可以用这个方法 )， 
 335 或者透过接口来达到这个功能。在使用接口实作时 (我们即将用这个方法作
为范例 )，一组新 架构的类别就会实作这个特定的接口，并且把它的方法对
应到现存的规则去。  
 
在特定的情境中，转换器提供了通用的接口让多种组件可以进行查询，这会
发生在有些接口没有延续性的时候 (这就常发生在 UI函式库里面 )。这个接
口称为 ITextAndValue ，因为它允许存取组件的属性，可以透过文字化的描
述或者数字化的内容 : 
type  
   ITextAndV alue = interface  
     '[51018CF1 -OD3C -488E -81B0 -0470B09013EB]'   
     procedure SetText (const V alue: string);   
     procedure SetV alue(const V alue: Integer);   
     function GetText: string;   
     function GetV alue: Integer;  
 
     property Text: string read GetText write SetText;   
     property V alue: Integer read GetV alue write SetV alue;   
   end;   
 
下一步是为每个我们想要使用这个接口的类别都建立一个新的子类别， 例如
我们可以这么写 : 
type  
   TApadterLabel = class(TLabel, ITextAndV alue)   
   protected   
       procedure SetText(const V alue: string);  
       procedure SetV alue(const V alue: Integer);  
       function GetText: string;  
       function GetV alue: Integer;  
   end;   
 
这些方法的实作都很简单，因为他们可以被对应到 Text属性，并透过一个
几单的型别转换，看要提供的是文字还是数字，都能很简单的达成。然而现
在我们有了一个新的组件，我们得要先安装它 (如我们在前一章的最后所介
绍过的 )。把我们建立的每个组件都安装上去，这会花上一些时间。  
 
另一个比较简单的作法，会是使用穿插类别的作法 (interposer class idiom) ，
这个作法是定义一个跟基础类别相同名字的类别， 但放在不同的单元文件里 
 336 面。这会让编译 程序跟运行时间的串流系统可以适当的进行辨识，所以我们
在运行时间就可以得到这个新的特定类别所建立的对象了。唯一的不同，是
在设计时间中，我们只能跟基础组件类别的实体互动了。  
_________________________________________________________________________  
穿插类别 (Interposer class) ， 这个名词第一次被提到， 是在许多年前的 Delphi 
Magazine 上面。这个技术多少是有些要骇入类别之中的意味，但有时也的
确很有用。在我看来，穿插 类别是在不同单元文件之中去定义跟某些类别
的基础类别同名的类别，这也是众多 Delphi常用名词之一。使用上要注意
到，穿插类别所在的单元文件，在 uses引入的时候，必须要列在我们要取
代掉的类别所在的单元文件 之后。换句话说，比较后来被引入的单元文件
会取代掉顺序上先被引入的单元文件里面的同名标识符。当然我们可以透
过把单元文件的名称明白的写出来作为识别，但大家一般都不会写的这么
明白，于是透过这个方法，我们就可以在全局的名称解析规则里面投机取
巧了。  
 
要定义一个穿插类别，我们通常要写一个新的单元文件，在新的单元文件里
面会建立一个跟我们要取代的基础类别同名的类别。要参考基础类别，我们
必须把它所在的单元文件的名称完整写上来 (不然编译程序会以为这是一个
递归参考，然后就报出错误讯息了 ): 
type  
  TLabel = class(StdCtrls.TLabel, ITextAndV alue)   
  protected   
     procedure SetText(const V alue: string);  
     procedure SetV alue(const V alue: Integer);  
     functio n GetText: string;  
     function GetV alue: Integer;  
  end;   
 
在这个例子里，我们不用安装组件，也不用触及现存的程序，但要在 uses
引入单元文件的最后加上这个单元文件的名字。  
 
在两种案例中 (但我用穿插类别写的范例项目不行 )，我们可以查询窗体中的
组件是否支持这个转换器接口，然后当成练习，写个程序把所有值都设成
50，它会依次影响到不同组件的不同属性 : 
procedure TForm1.Button1Click(Sender: TObject);   
var  
   Intf: ITextAndV alue;  
   I: integer;  筆記   
 337 begin  
   for I := 0 to ComponentCount - 1 do  
     if Supports (Components [i], ITextAndV alue, intf) then   
        Intf.V alue := 50;  
end;  
 
在这个特例中，这个程序代码会影响进度列组件或者数字显示盒，以及卷标
或文字编辑框的 Text属性。但也有不少的组件会直接忽略它，例如我们没
有定义转换器接口 的组件就是如此。  
 
这是非常特别的例子，如果我们多看一些其他的设计模式，就会更容易发现
到，透过 Object Pascal 的类别以及充满弹性的接口，要实作这些设计模式相
对简单多了 (Java, C# 以及其他透过接口来提供扩充性的热门的程序语言也
跟Object Pascal 一样 )。 
  
 338 12:操作类别  
 
在前几章里面，我们介绍了 Object Pascal 语言在对象方面的基础 :类别、对
象、方法、建构函式、继承、延迟绑定、接口，以及更多其他技术。现在
我们要更进一步了，深入观察一些更进阶的主题，以及 Object Pas cal里面
跟管理类别相关的特定功能。从类别参考到类别助手，这一章会介绍更多
在其他 OOP语言里面没有的功能，或明显不同的实作方式。  
 
焦点会是类别，以及在运行时间操作类别的方法，这个主题我们也会在第
16章介绍到 reflection 跟属性的时候更进一步的探讨。  
 
类别方法跟类别数据  
当我们在 Object Pascal 跟大多数其他 OOP里面定义一个类别，我们是在为
这个类别的对象 (或叫实体 ) 定义它的数据结构，以及我们可以透过这个对
象进行的动作。然而也有另一种可能，是要定义在这个类别里面所有对象
之间分享的数据，以及 任何一个从该类别中建立出的对象可以被呼叫的方
法。  
 
在Object Pascal 里面需要一个类别方法，我们只要在该方法前面加上 class
关键词即可，不管该方法是程序或是函式 : 
type  
   TMyClass = class  
      class function ClassMeanV alue: Integer;   
 
假设我们建立了类别 TMyClass 的对象，名为  MyObject ，我们可以透过对
象，也可以透过类别直接呼叫这个类别方法 : 
I := TMyClass.ClassMeanV alue;  
J := MyObject.ClassMeanV alue  
 
从上面的程序代码，我们可以看出，类别方法可以随时使用，即使该类别
的对象还没有被建立出来，也可以直接透过该类别去呼叫。有些情境下，
类别会由类别方法建立，透过不特别写出的方法，我们就不用建立出该类
的对象了。  
  
 339 _________________________________________________________________________  
通常类别方法的使用，以及只使用类别方法来建立对象是大多数不允许使
用全局函式的 OOP程序语言的常态。 Object Pascal 还让我们宣告旧型的全
局函式，但经过这几年，系统函式库和开发人员所写的程序代码已经迈向
一致使用类别方法的途径。使用类别方法的优点是类别方法可以逻辑的链
接一个类别，该类别为一整组相关的函式扮演了类似命名空间的角色。  
 
  虚拟类别方法跟隐藏的 Self参数 
当类别方法的概念已经在许多程序语言里面变得普及， Object Pascal 的实作
就变得有些独特的地方。首先，类别方法拥有一个隐晦 (或者隐藏 )的self
参数，就像一般的实体方法。然而，这个隐藏的 self参数就是指向类别本
身的一个参考，而不是类 别的实体。  
 
猛一看，类别方法拥有这个隐藏的指向类别自己的 self参数似乎没有什么
用。编译程序最终会认得类别方法。然而有一个奇怪的语言功能可以解释
这一点 : 跟大多数程序语言不同，在 Object Pascal 里，类别方法可以是虚拟
的，在衍生类别中，我们可以重载基础类别的类别方法，就像重载一般的
方法一样。  
_________________________________________________________________________  
对虚拟类别方法的支持是和虚拟建构函式的支持 (我们可以将之视 为是特
殊要求的类别方法 )连结的。这两个功能在许多需要编译，支持强型别的
OOP程序语言中都是不支持的。  
 
  类别静态方法  
类别静态方法已经在 Object Pascal 对平台兼容性的章节中介绍过了，原始
的类别方法跟类别静态方法之间的差异，在于类别静态方法并不需要参考
到它的类别 (也就是没有 self参数指向类别本身 )，而且不能是虚拟方法。  
 
以下的范例程序代码里面包含了一些可能导致错误的程序代码，我们已经
先把会导致错误的程序代码批注掉了，这些程序代码都是 ClassStatic 范例
项目中所节录出来的：  
type  
   TBase = class  
   private  
      tmp: Integer;  
   public  筆記  
筆記   
 340       class procedure One;  
      class procedure Two; static;  
      ... 
 
class procedure TBase.One;  
begin  
   // Error: Instance member 'tmp' inaccessible here   
   // Show (tmp);   
   Show ('one');   
   Show (self.ClassName);   
end;   
      
class procedure TBase.Two;  
begin  
   Show ('two');   
   // error: Undeclared identifier: 'self'   
   // Show (self.ClassName);   
   Show (ClassName);   
   Two;   
end;   
 
在以上两个情形下，我们都可以直接呼叫这些类别方法，或者透过对象来
呼叫也行 : 
  TBase.One;  
  TBase.Two;  
 
  base := TBase.Create;  
  base.One;  
  base.Two;  
 
有两个有趣的功能，使得 Object Pascal 的类别静态方法变得很有用。第一
个是它可以用来定义类别的属性，就像我们在下一节里面会提到的，第二
个则是类别静态方法是完全跟 C语言兼容的。  
 
  静态类别方法跟 Windows API callback  
因为没有 self这个隐藏参数，所以静态类别方法可以被传给操作系统 (例如
Windows) 当做 callback函式。在实务上，我们可以宣告一个静态类别方法 ， 
 341 并加上 stdcall这个呼叫转换关键词，就可以把它直接当成 Windows API 的
callback， 我们把 StaticCallBack 范例项目中的 TimerCallBack 方法做为范例 : 
type  
   TFormCallBack = class(TForm)  
      ListBox1: TListBox;  
      procedure FormCreate(Sender: TObject);   
   private   
      class var  
         nTimerCount: In teger;  
   public  
      class procedure TimerCallBack (hwnd: THandle;   
          uMsg, idEvent, dwTime: Cardinal); static; stdcall;   
end;   
 
类别的数据会 callback 函式用来当做计数器。 OnCreate 处理程序会呼叫
SetTimer API ，把这个类别静态程序的地址传递过去。  
procedure TFormCallBack.FormCreate(Sender: TOb ject);   
var  
   callback: TFNTimerProc;  
begin  
   nTimerCount := 0;   
   callback := TFNTimerProc(@TFormCallBack.TimerCallBack);   
   SetTimer(Handle, TIMERID, 1000, callback);   
end;   
_________________________________________________________________________  
TFNTimeProc 的参数是一个方法指标，因此我们需要在类别静态方法的名
称之前加上一个 @符号。我们需要取得该方法的地址，不用执行它。  
 
现在，实际的 callback 函式会增加计数器的数值，并且更新窗体，把它当
成全局变量作为对应，把它视为一个类别方法，而不是视为窗体本身 : 
class procedure TFormCallBack.TimerCallBack(   
    hwnd: THandle; uMsg, idEvent, dwTime: Cardinal);   
begin   
   try  
     Inc (nTimerCount);   
     FormCallBack.ListBox1.Items.Add (   
       IntToStr (nTimerCount) + ' at ' + TimeToStr(Now));   
   except on E: Exception do   筆記   
 342       Application.HandleException(nil);   
   end;   
end;   
 
这里使用的 try-except区块，是用来避免由 Windows 所送回的任何例外事
件。我们必须为 callback或者 DLL函式提供后续的程序控管。  
 
  类别数据  
类别数据是在该类别的所有对象中都可以共享的，提供以全局的属性来储
存，但只有类别可以透过特殊方式存取 (包含存取限制 )。我们该怎么宣告类
别数据 ?直接在类别当中的任何一个区域用 class var关键词就可以宣告了 : 
type  
   TMyData = class  
   private  
      class var  
         CommonCount: Integer;  
   public  
      class function GetCo mmon: Integer;   
 
class var 这个区域就包含了一或多个宣告。我们可以使用 var区域 (这是第
一次这样用到 var关键词 )来宣告相同区域的实体数据字段 (以下的范例是宣
告在私有区 ): 
type  
   TMyData = class  
   private  
      class var  
         CommonCount: Integer;  
      var 
         MoreObjectData: string;  
   public  
      class function GetCommon: Integer;   
 
除了需告类别资料，我们还可以定义一些类别属性，这个我们在下一节里
面来介绍。  
 
  
 343   类别属性  
一如我们介绍过的，使用类别静态方法的原因之一，是要实作类别属性。
什么是类别属性呢 ?就跟基本属性一样，它是包含有读写机制的符号。而跟
基本属性不同的是，它是属于类别的而且必须透过类别数据或者类别静态
方法来实作。这个 TBase类别 (再提一次，是从 ClassStatic 范例项目节录的 )
有两个类别方法，我们用两种定义的写法来做示范 : 
type  
   TBase = class  
   private  
      class var  
           fMyName: string;  
   public  
      class function GetMyName: string;  static;   
      class procedure SetMyName (V alue: string); static;   
      class property MyName: string read GetMyName write SetMyName;   
      class pro perty DirectName: string   
          read fMyName write fMyName;   
end;   
 
  具有实体个数计数器的类别  
如我们所介绍过的，类别数据跟类别方法可以用来储存类别中整体的信息。
这一类的信息中，最好的范例就是这个类别的实体目前一共被建立了几个，
并减去已经被释放的，就可以知道还存在的实体的数目。  
 
CountObj 范例项目就建立了这个情境。这个程序并没有好用到吓人，假设
我们只先看几个特定的问题跟它的解法。换句话说，我们先透过很简单的
类别作范例，让这 个类别里面先只储存一个数字 : 
type  
   TCountedObj = class (TObject)  
   private  
     FV alue: Integer;  
   private class var  
      FTotal: Integer;  
      FCurrent: Integer;  
   public  
      constructor Create;    
 344       destructor Destroy; override;   
      property V alue: Integ er read FV alue write FV alue;   
   public  
      class function GetTotal: Integer;   
      class function GetCurrent: Integer;   
end;   
 
每当一个对象被建立，这个程序就会在呼叫基础类别的建构函式之后把上
面程序代码的两个计数器。每次对象被释放，现有的对象数目也就会被减
少：  
constructor TCountedObj.Create (AOwner: TComponent);   
begin  
    inherited Create;  
    Inc (FTotal);  
    Inc (FCurrent);  
end;   
 
destructor TCountedObj.Destroy;   
begin   
    Dec (FCurrent);  
    inherited Destroy;  
end;  
 
类别信息可以无需透过任何一个特定对象，直接就能存取。事实上，也可
能是因为在该时间内，内存里面并没有对象存在 : 
class function TCountedObj.GetTotal: Inte ger;  
begin   
   Result := FTotal;  
end;  
 
// display status   
Label1.Text := TCountedObj.GetCurrent.ToString + '/' +   
    TCountedObj.GetTotal.ToString;   
 
这段程序会由一个定时器来执行，执行后会更新一个文字卷标，所以不用
透过特定对象实体，也不用透过任何手动程序来触发。而是会由范例项目
里面的按钮建立并释放这些对象，或者把它们留在内存里面 (因为事实上这
个范例项目也可 能造成一些内存泄漏的状况 )。  
 345  
类别建构函式 (以及解构函式 ) 
类别建构函式提供了让我们为跟类别相关的数据进行初始化的方法，同时
它也扮演了类别初始者的角色，但它实际上并没有建构任何东西。类别的
建构函式在建构实体的时候，其实不需要作什么事情 :它只用来在类别要被
使用之前，先为类别本身进行初始化而已。举例来说，一个类别建构函式
可以为该类别的资料设定初始值、加载设定或者为该类别加载支持的 文件
等等。  
 
在Object Pascal 里面，类别的建构函式算是单元文件初始区 (initialization)
程序代码的替代方案。 如果在一个单元文件里面，初始区跟类别的建构函
式都存在，类别的建构函式会先执行，然后单元文件的初始区才会被执行
到。相对的，我们也可以定义一个类别结构函式，它会在单元文件的终止
区(finalization) 程序代码之后被执行。  
 
然而，有个很明显的不同是，当单元文件被编译进某个程序，该单元文件
的初始区跟终止区程序代码一定会被执行到，但类别的建构跟解构函式则
要看该类别有没有被使用到，才有被执行到的机会。这表示类别的建构函
式是比初始区、终止区程序跟链接程序 (linker)更为亲近的。  
_______________ __________________________________________________________  
换句话说，透过类别的建构跟解构程序，如果一个型别没有跟初始区程序
代码连结，该型别就不会成为程序的一部分，也不会被执行。在传统的情
形下，相反的逻辑也是成立的。初始区的程序也可能让链接程序带入部分
类别的程序代码，即使这类别可能完全没有在任何地方被执行到。在实务
上，这会跟手势架构一起介绍，该架构的程序代码很庞大，但在没有被用
到的时候则不会被编译到执行档里面去。  
 
用程序代码来做范例，我们可以这么 写(节录自 ClassCtol 范例项目 ): 
type  
   TTestClass = class  
      public  
      class var  
         StartTime: TDateTime;  
         EndTime: TDateTime;  
      public  
         class constructor Create;  
         class destructor Destroy;  筆記   
 346    end;  
这个类别有两个类别数据字段，当我们在初始区跟终结区里面加 入以下程
序代码以后，这两个数据字段就会在类别建构函式中被初始化并在类别解
构函式中被修改 : 
class constructor TTestClass.Create;   
begin   
   StartTime := Now;  
end;  
class destructor TTestClass.Destroy;   
begin   
   EndTime := Now;  
end;  
initialization   
    ShowMessage (TimeToStr (TTestClass.StartTime));   
finalization   
    ShowMessage (TimeToStr (TTestClass.EndTime));   
 
单元文件被初始化时，程序就如我们预期的被执行，当我们显示出文字对
话框时，类别的资料就已经准备好了。当结束程序时，另一个文字框则会
在类别结构函式指派数据之前被显示出来。  
 
注意到， 我们可以定义多个一般的建构函式跟解构函式， 像是预设的 Create
跟Destroy。但我们不能定义多个类别建构函式或类别解构函式。如果我们
这么做，编译程序会指出以下的错误讯息：  
[DCC Error] Cla ssCtorMainForm.pas(34): E2359 Multiple class constructors in class TTestClass: 
Create and Foo   
 
  在RTL里的类别建构函式  
在RTL里面有些类别已经透过使用类别建构函式得到了一些优势，像是
Exception 类别，就定义了类别建构函式 (如下面这个范例程序片段所示 )，
以及类别解构函式：  
class constructor Exception.Create;   
begin   
   InitExceptions;  
end; 
 
InitExceptions 这个程序会在 SysUtils单元文件的初始区程序里面先被呼叫。   
 347  
通常，我认为使用类别建构函式跟类别解构函式会比使用单元文件的初始
区跟终结区来的好。在大多数情形下，这只是语法上方便，所以我们可能
不会想要回头修改现有的程序代码。然而如果我们面对从未使用过的数据
结构初始化所可能遭遇的风险 (因为这个型别的类别从未被建立过 )， 把初始
化的工作搬到类别建构函式去，可以提供很显著的好处。这在一般的函式
库当中显然比较常被使用到，当然我们并不可能在程序中用到函式库面的
所有功能。  
_____ ____________________________________________________________________  
使用类别建构函式的一个特殊情况， 会是在使用泛型类别 (generic class) 的时
候。我们会在这一章里面提到泛型。  
 
  实作单一实体模式 (Singleton Pattern)  
有不少类别， 是需要从头到尾只能建立一个实体的。 单一实体模式 (Singleton 
Pattern，另一个很常见的设计模式 )，就有这样的要求，并建议提供一个可
以对于该对象进行存取的全局指标。  
_________________________________________________________________________  
我们在前一章里面已经提过，我们在附录 D里面提供了一些透过 Object 
Pascal的特点介绍设计模式 (Design Pattern) 的文章。  
 
单一实体模式可以用很多种方式来实现，但一个类别的要求则是呼叫用来
存取唯一实体的函式，来取得该类别的唯一实体。在很多情形下，这样的
实作也使用了延迟初始化的规则，所以这个全局的实体会直到整个程序有
用到它的时候，才会被建立出来。  
 
在这个实作方法中，我使用了类别数据、类别方法，但也在最后要进行结
束的时候使用了类别解构方法。以下是相关的范例程序代码 : 
type  
   TSingleton = class(TObject)  
      public  
        class function Instance: TSingleton;   
      private  
        class var theInstance: TSingleton;   
        class destructor Destroy;   
   end;  
 
class function TSingleton.Instance: TSingleton;   筆記  
筆記   
 348 begin   
   if theInstance = nil then   
     theInstance := TSingleton.Create;   
   Result := theInstance;  
end;  
 
class destructor TSingleton.Destroy;   
begin   
   FreeAndNil (theInstance);  
end;  
 
我们可以在程序代码里面以下 面的写法取得该类别的实体 (不管当时该类
别的实体是否已经被建立出来 ): 
var 
  aSingle: TSingleton;  
begin  
   aSingle := TSingleton.Instance;   
 
更进一步的说，我们可以把一般的建构函式给隐藏起来，把一般的建构函
数声明在私有区，让任何人都无法违反单一实体模式的规则，不然就用不
到这个类别。  
 
类别参考  
我们介绍过了好几个跟方法相关的主题，现在我们来看一下跟类别参考以
及把我们的范例透过动态建立组件的方法延伸的结果吧。首先要一直提醒
自己，类别参考并不 是类别，不是对象，它只是一个指向对象的参考而已，
它只是简单的一个类别型别的参考而已。  
 
类别参考型别决定了类别参考变量的型别。听起来很绕口吧 ?我们用几行程
序代码来说明这一点。假设我们定义了一个名为 TMyClass 的类别，我们就
可以定义一个新的类别参考型别来跟这个类别产生关连 : 
type  
   TMyClassRef = class of TMyClass;  
 
现在我们就可以定义这两种型别的变量了，第一个变量是指向一个对象，
第二个则是指向一个类别 : 
var  
 349    AClassRef: TMyClassRef;  
   AnObject: TMyClass;  
begin  
   AClassRef := TMyClass;  
   AnObject := TMyClass.Create;  
 
您可能会觉得奇怪，类别参考到底有什么用 ?通常，类别参考让我们可以在
运行时间操作一个类别资料型别。我们可以在表达式里面用类别参考来判
断一个数据型别是否合法。事实上，这样的表达式并不多，但部分案例是
挺有趣的。最简单的例子，是建立对象的时候。我们可以把上面两行重写
一下 : 
AClassRef := TMyClass;  
AnObject :=  AClassRef.Create;  
 
此时，我已经用了类别参考的建构函式，而没有使用特定实际类别的建构
函式。所以是使用了类别参考来建立该类别的对象。  
_________________________________________________________________________  
类别参考是跟 metaclass 的概念相关的，这个概念在许多其他的 OOP语言
里面也存在。然而在 Object Pascal 里面，类别参考并不是一个类别，只是
用来定义类别数据的一个特殊的类别型别而已。因此，跟 meta class(用来描
述其他类别的类别 )相比就很容易误导了想法。实际上 TMetaClass 也是在
C++ Builder 里面用到的一个名词。  
 
当我们建立了类别参考，我们可以用它来呼叫其对应类别的类别方法。所
以如果  TMyClass 有一个类别方法叫做 Foo， 我们就可以用以下的任一写法 : 
TMyClass.Foo  
AClassRef.Foo  
 
如果类别参考不支持跟类别型别相同的型别兼容性规则的话，这看起来也
不特别有用。当我们宣告了类别参考变量，例如上例中的 MyClassRef ，我
们可以把特定的类别或该类别的衍生类别 指派给它。 所以如果 MyNewClass
是TMyClass 的子类别，我们就可以这么写 : 
AClassRef := MyNewClass;  
 
现在我们来了解一下，这为什么这么有趣，我们必须记得我们可以从类别
参考呼叫的类别方法可以是虚拟方法，所以特定的子类别可以重载这些方
法。使用类别参考跟虚拟类别方法，我们就可以在类别方法的层次实作出
多型了，这可是只有少数静态 OOP程序语言才支持的。  筆記   
 350  
同时考虑到每个类别都是从 TObject衍生而来的， 所以我们可以让每个类别
参考上都带有 TObject的方法， 像是 InstanceS ize, ClassName, ParentClass 跟
InheritsFrom 。我们会在第 17章里面介绍这些类别方法跟其他 TObject类别
的方法。  
 
  在RTL里面的类别参考  
System单元文件跟其他核心的 RTL单元文件里面宣告了许多的类别参考，
包含 : 
TClass = class of TObject;   
ExceptClass = class of Exception;   
TComponentClass = class of TComponent;   
TControlClass = class of TControl;   
TFormClass = class of TForm;   
 
特别是 TClass类别参考型别，可以用来储存任何我们在 Object Pascal 所写
的类别的参考， 因为任何类别都是从 TObject所衍生出来的。 而 TFormClass
参考则是在 FireMonkey 或VCL为架构的 Object Pascal 项目里面都有用到
的。在两个架构的函式库中， Application 对象的 CreateForm 方法都会要求  
窗体的类别当成参数，这样才能用来建立窗体 : 
Application.Create Form(TForm1, Form1);   
 
第一个参数是一个类别参考，第二个参数则是一个用来储存 Application 对
象建立出来的窗体实体的变量。  
 
  用类别参考来建立组件  
在Object Pascal 里面，实务上到底是怎么使用类别参考的 ?要能在运行时间
操作一个数据结构，是开发环境的基本功能。当我们从组件盘上面选了一
个组件，把它加到窗体上，我们就是选择了一个数据型别，并且建立了该
数据型别的一个组件。 (实际上，这是开发环境帮我们在背景偷偷做好的 ) 
 
为了帮助我们更了解类别参考的运作，我建立了一个名为 ClassRef的范例
项目。在这个范例中的窗体相当简单。上面只有三个 Radio按钮，放在窗
体上方的一个 Panel里面。当我们点选了其中一个按钮，我们就可以建立
Radio按钮文字卷标所描述的组件 :Radio按钮，一般按钮，跟文字编辑框。  
  
 351 为了让这个程序能正常运作，需要适当为这三个组件命名，窗体必须也要
有一个类别参考的字段 : 
private  
   FControlType: TControlClass;  
   FControlNo: Integer;  
 
第一个字段储存每次用户点击按钮时的新数据型别，并修改它的状态 。以
下是其中一个按钮的方法 : 
procedure TForm1.RadioButtonRadioChange(Sender: TObject); begin   
   FControlType := TRadioButton;  
 end;  
 
另外两个 Radio按钮都有跟这个方法类似的处理程序，会指派 TEdit或者  
TButton到FControlType 这个数据字段。类似的指派也在窗体的 OnCreate
事件处理程序中出现，当做初始化方法来使用。  
 
这个程序代码有趣的部份，是当使用者点击了画面上大多数的组件时都 会
执行。我选择了窗体的 OnMouseDown 这个事件来取得鼠标的位置 : 
procedure TForm1.Layout1MouseDown(Sender: TObject;   
    Button: TMouseButton; Shift: TShiftState; X, Y: Single);   
var 
   NewCtrl: TControl;  
   NewName: String;  
begin  
   // create the control   
   NewCtrl := FControlType. Create (Self);   
 
   // hide it temporarily, to avoid flickering   
   NewCtrl.Visible := False;   
 
   // set parent and position  
   NewCtrl.Parent := Layout1;  
   NewCtrl.Position.X := X;  
   NewCtrl.Position.Y := Y;  
 
   // compute the unique name (and text)   
   Inc (FControlNo);   
   NewName := FControlType.ClassName + FControlNo.ToString;    
 352    Delete (NewName, 1, 1);   
   NewCtrl.Name := NewName;   
   // now show it   
   NewCtrl.Visible := True;  
end;  
 
这段程序的第一行就是关键了。它会建立用储存在 FControlType 的类别参
考来建立一个新的对象。我们简单的透过使用该类别参考的 Create建构函
式来完成。所以我们现在就可以设定 Parent属性的值、设定它的位置、给
他一个名字 (名字当然是个字符串 )，然后把它设定成可见。  
 
特别介绍程序代码中用来建立名称这部份，我们模仿了 Object Pascal 的默
认命名规则，我用了 FControlType.ClassName ，也就是储存在类别参考中的
类别名称来当开头，这也是 TObject类别的类别方法之一。然后加入该组件
目前的序号作为结尾，并把最开头的字符串移除。  
 
所以用第一个 Radio按钮来做说明，基础的字符串是 TRadioButton 在后面
加个 1，然后把开头的 T拿掉，就变成了 RadioButton1 ，很眼熟吧 ? 
 
我们可以看一下图 12.1， 这是程序执行的画面， 要注意这个命名规则跟 IDE
的规则并不是完全一致的。 IDE里面对每个型别的组件有独立的计数。而
我们范例程序里面所有组件都用同一个计数。所以如果我们在画面上依序
放了 Radio按钮，一般按钮，以及文字编辑框，它们的名字会分别是：
RadioButton1 ，Button2，以及 Edit3，就如图 12.1所示 (当然文字编辑框是
不会显示名字的 ): 
__________________________ _______________________________________________  
 
 
  
 
 
 
 
 
 
 
 
 圖12.1: 在Windows 環境下
執行 ClassRef 的畫面  
 
 353  
 
顺带一提，考虑到一旦我们建立了一般的组件，我们就可以用非常动态的
方式来存取它的属性。 例如 Refection ， 这个主题我们会在第 16章里面介绍。
在那一章里面，我们也会介绍更多其他参考到型别的方法、以及透过类别
方法引用类别信息等等。  
 
类别与记录助手  
我们在第八章里面介绍过，在类别当中继承的概念是用来帮类别提供新功
能的一个方法，而且这个方法不会影响到原来的任何实作。这个实作方式
也被称为 开放的封闭原理 :数据型别本身是完整定义了的 (封闭 )，但仍可以
被修改 (开放 )。 
 
虽然型别继承是一个很强大的机制，在某些情境底下它仍然还不完美。当
我们的程序中使用了已经存在的复杂函式库，我们会想要能够对一个数据
型别进行扩充，而不想继承类别。当对象是以某些自动化的方式建立时就
可以这样做，而且替换掉建立的过程则会很复杂。  
 
另一个对 Object Pascal 开发人员来说相对直觉的情境则是使用组件。如果
我们想为一个组件类别加入新的方法，为它提供新的功能，我们就一定得
要透过继承来做，但同时我们也就需要 :建立新的衍生类 别、建立新的套件
并且安装它，把所有已经放在窗体上面的这个组件都替换掉、在项目里面
所有将要使用到该组件的窗体画面上，也都要用新版本的组件 (同时会影响
到窗体跟原始文件的两个 文件 )。 
 
的确很麻烦，另一个替代作法，则是使用类别或者记录助手。这些特殊用
途的数据型别能够延伸现有的型别，为这些型别加上新的方法。即使使用
类别助手这个作法有些限制，类别助手让我们可以处理像刚刚提到的，只
是要简单的为现有组件加入新方法的这种需求，而且不用修改现有的组件
型别喔。  
_________________________________ ________________________________________  
我们其实已经看过一个用来延伸函式库类别，而不用更换掉相关参考的方
法了，透过使用继承和相同名称的类别，也就是前一章里面提到的穿插类
别(interposer class idiom) 。类别助手提供了一个更简洁的模式，然而被耶助
手无法用来替换掉虚拟方法，也无法实作一些延伸的接口，这些我们在前
一章都已经提到过了。  
 筆記   
 354  
  类别助手  
类别助手是让我们为无法修改的类别 (例如函式库类别 )加入方法或属性的
途径。使用类别助手来为我们自己写的类 别做延伸并不常见，因为我们可
以直接修改自己能掌握的类别的所有程序代码。  
 
类别助手无法加入实体数据，假设这个数据必须依赖实际的对象，而这些
对象是以它们的原始类别定义的，或者碰触到原本定义在原始类别的实际
架构中的虚拟方法，类别助手就帮不上忙了。  
 
换句话说，助手类别只能加入或者换掉已存在的非虚拟方法。我们可以用
这个方法在原始类别的对象上加入新的方法，即使该类别当中没有现存方
法的线索也一样。  
 
这么说或许不够清楚，我们来看个例子 (这是 ClassHelperDemo 范例项目的
一部分，这是一个我们不该做的范例 -用类别助手来处理我们自己制作的类
别): 
type  
   TMyObject = class  
   private  
     V alue: Integer;  
     Text: string;  
   public  
     procedure Increase;  
   end;  
 
   TMyObjectHelper = class helper for TMyObject   
   public   
     procedure Show;  
   end;  
 
以上的程序代码宣告了一个类别跟这个类别的助手。这表示当 我们生成了
一个 TMyObject 的对象时，我们也可以呼叫类别助手的方法 : 
Obj := TMyObject.Create;  
Obj.Text := 'foo';  
Obj.Show;  
  
 355  
这个助手的类别方法会变成该类别的一部分，我们可以用 self来呼叫助手
类别的方法，就像我们呼叫该对象的任何一个方法一样 (类别助手只是扮演
助手的角色，因为它并没有实际被建立成一个实体 )，如下面的范例所示 : 
procedure TMyObjectHelper.Show;   
begin   
   Show (Text + ' ' + IntToStr (V alue) + ' -- ' + 
       ClassName + ' -- ' + ToString);   
end;   
 
最后，请记得助手类别可以重载原始的方法。在我们提供的范例程序代码
里面，在类别跟着手类别当中都有名为 Show的方法，但只有助手类别的方
法会被呼叫到。  
 
当然，宣告一个类别以及透过助手类别的语法来宣告同名类别的延伸也是
有点用处的，这个作法适用于同一个单元文件，甚至同一个程序中。在范
例程序中就是这么做的，但只是为了让大家更容易理解这个技术跟它的语
法。类别助手在开发应 用程序的时候，不应该用来当做一般语言的的建构
函式，但可以用来为我们没有原始码的函式库里面的类别，或者我们不想
动到原始码的类别进行功能的延伸，因为该函式库的开发维护人员可能在
未来对这些类别做出修改。  
 
使用类别助手的时候还是有些规则的。类别助手的方法：  
 可以跟原始的类别方法位于不同的访问权限区。  
 可以是类别方法或者实体方法，类别变量与属性  
 可以是虚拟方法，未来可以在衍生类别中被重载 (即使我发现这个
功能在实作时有些怪怪的 ) 
 可以提供额外的建构函式  
 可以在型别定义中加入巢状常数  
 
类别助手中唯一缺少的功能就是常数 数据字段。也要注意，类别助手在进
入该类别的执行范围起就开始可以被使用了。我们必须在 uses区段加入对
定义了类别助手的单元文件的引入宣告，才能看见该类别助手的方法，而
不是只要在编译的过程中引入就行了。  
 
  ListBox的类别助手  
类别助手的实际应用，是提供函式库中的类别一些额外的方法。原因可能 
 356 是我们不希望直接动到这些类别的原始码 (即使我们可能拥有这些原始码，
但我们不一定会想要动到这些核心函式库的原始码 )或者从这些类别制作
出衍生类别 (使用这个作法，我们就得把窗体里面的组件一一替换了 )。 
 
当成做个练习，思考 一下这个简单的案例 :我们想要有一个简单的方法，能
够拿到一个 list box目前被选取的项目的文字。但不想要用传统写法 : 
ListBox1.Items [ListBox1.ItemIndex]   
 
我们可以定义一个像这样的类别助手 (节录自 ControlHelper 范例 ): 
type  
   TListboxHelper = class helper for TListBox   
      function ItemIndexV alue: string;   
   end;   
 
function TListbox Helper.ItemIndexV alue: string;   
begin   
   Result := '';  
   if ItemIndex >= 0 then  
     Result := Items [ItemIndex];  
 end;  
 
定义完成之后，我们就可以直接改写成这样了 : 
Show (ListBox1.ItemIndexV alue);   
 
这只是个很简单的例子，但也用很实用的文字把内涵给表达出来了。  
 
  类别方法跟继承  
类别助手最明显的限制，就是我们每次对一个类别只能使用一个助手。如
果编译程序发现了有两个助手类别，第二个助手类别就会把第一个给取代
掉。所以也没有任何方法可以对类别助手进行连锁使用，也就是说我们不
能对类别助手再制作另一个类别助手。  
 
有个方法可以解决一部分的问题，就是我们可以为一个类别制作一个类别
助手，然后当这个类别出现了衍生类别时，再为衍生类别制作另一个类别
助手。这样做并不是从助手类别衍生另一个助手类别喔。我并不鼓励让类
别助手的结构过于复杂，因为那可能让我们的程序代码变得很难懂。  
  
 357 TGUID记录就是一个例子，它是一个 Windows 的数据结构，我们可以在
Object Pasca l里，在不同的操作系统中使用它，有个型别助手就帮它加了一
些常用的功能 : 
type  
   TGuidHelper = record helper for TGUID   
     class function Create(const B: TBytes): TGUID; overload; static;   
     class function Create(const S: string): TGUID; overload; static;   
     // ... more Create overlo ads omitted   
     class function NewGuid: TGUID; static;   
     function ToByteArray: TBytes;  
     function ToString: string;  
   end;  
 
  现有型别的记录助手  
记录助手概念的延伸之一， 就是为原生 (或者说是编译程序现有的型别 )数据
型别提供了加入方法的能力。即使我们用了 ”记录助手 ”这样的名词，但这
写法并不是为了记录提供的，而是对一般的数据型别提供的。  
_______________ __________________________________________________________  
记录助手目前已经被用来延伸、为原生资料型别提供像方法一样的处理，
但这在未来应该会有所改变。今天的执行时期函式库定义了的一些原生助
手，未来可能就会消失，保持我们目前以这些助手写程序的方法，但在定
义这些助手的程序代码中打破了兼容性。这也是我们为什么不应该过度使
用这个功能的原因，即使它用起来很方便，且功能强大。  
 
现有的型别助手是怎么运作的 ?我们来看看以下对整数型别所定义的助手 : 
type  
   TIntHelper = record helper for Integer   
      function AsString: string;  
   end;   
 
现在假设有个整数变量 n，我们可以这么写 : 
n.AsString;   
 
我们要怎么定义虚构的方法，而这个方法又是怎么让变量值能够参考到的
呢?我们想象一下 self这个关键词在该函式里被使用到：  
function TIntHelper.AsString: string; begin   
   Result := IntToStr (self);  筆記   
 358  end;  
注意到，我们也可以在常数上面使用这个助手，可以这么写 : 
Caption := 400000.AsString;  
 
然而我们不能对很小的数值作一样的动作，因为编译程序会把太小的数值
当成是其他的型别来处理。所以如果我们想要把 4这个数字的常数用上面
的方法来转换，就得用以下的第二个写法了 : 
Caption := 4.AsString; // nope!   
Caption := Integer(4).AsString; // ok   
 
或者我们也可以用第一个写法，但我们就得定义一些不同的型别助手了 : 
type  
   TByteHelper = record helper for Byte...   
 
我们在第二章里面已经介绍过，我们用不着像上面这样写了很多的型别助
手，像是整数跟 Byte，因为执行时期函式库已经定义了许多类别助手跟大
多数核心型别的助手，以下这些都包含在 SysUtils单元文件里面了 : 
TStringHelper = record helper for string   
TSingleHelper = record helper for Single   
TDoubleHelper = record helper for Double   
TExtendedHelper = record helper for Extended   
TByteHelper = record helper for Byte   
TShortIntHelper = record helper for ShortInt   
TSmallIntHelper = record helper for SmallInt   
TWordHelper = record helper for Word   
TCardinalHelper = recor d helper for Cardinal   
TIntegerHelper = record helper for Integer   
TInt64Helper = record helper for Int64   
TUInt64Helper = record helper for UInt64   
TNativeIntHelper = record helper for NativeInt   
TNativeUIntHelper = record helper for NativeUInt   
TBooleanH elper = record helper for Boolean   
TByteBoolHelper = record helper for ByteBool   
TWordBoolHelper = record helper for WordBool   
TLongBoolHelper = record helper for LongBool   
TWordBoolHelper = record helper for WordBool   
 
还有一些现存的型别，它们的助手则被定义在其他单元文件里面 :  
 359 // Sys tem.Character:   
TCharHelper = record helper for Char   
// System.Classes:   
TUInt32Helper = record helper for UInt32   
 
因为我们在本书前面的篇幅里面已经提供了许多范例，所以在这里就不赘
述了。加入这一节，是为了让大家知道我们可以怎么为现存的型别定义一
个型别助手而已。  
 
  型别别名的助手  
如同刚刚介绍过的，我们不可能为一个型别定义两个助手，每个型别只会
有一个助手。所以我们要怎么为一个原生型别，像是 整数，加入一个直接
的动作呢 ?这个需求并没有直接的解决方法， 但有几个可以奏效的作法 (简单
的说，可以复制内部类别助手的原始码，然后用另一个类别助手方法来贴
上这些程序代码 )。 
 
另一个我中意的解决方法，是定义一个型别别名。型别别名会被编译程序
当成一个全新的型别，所以它可以拥有它自己的型别助手，就不用改动原
始型别的助手了。现在两个型别被当成不同型别了，我们仍然不能把两个
型别助手透过同一个变量来使用，但我们可以透过型别转换来达成这个目
的。我们用程序代码直接来说明吧。假设我们建立了这个型别别名 : 
type  
   MyInt = type Integer;  
 
现在我们就可以定义这个型别的助手了 : 
type  
   TMyIntHelper = record helper for MyInt   
      function AsString: string;  
   end;  
 
function MyIntHelper.AsString: string;   
begin   
   Result := IntToStr (self);   
end;   
 
如果我们定义了一个这个新型别的变量，我们就可以呼叫特定助手的方法
了，但是仍然呼叫整 数助手的方法，只要透过转型 :  
 360  
procedure TForm1.Button1Click(Sender: TObject);   
var  
   mi: MyInt;  
begin  
   mi := 10;   
   Show (mi.asString);   
   // Show (mi.toString); // this doesn't work   
   Show (Integer(mi).ToString)   
end;   
 
以上节录自 TypeAliasHelper 范例项目，您可以用它来做些延伸练习。  
  
 361 13:对象与内存  
 
这一章的重点非常特别，但是是相当重要的主题，也就是在 Object Pascal
程序语言中的内存管理。这个程序语言与其执行时期环境提供了一个很独
特的解决方法，它是介于 C++风格的人工内存管理，以及 Java或C#，由系
统完全掌控之间的一个作法。  
 
使用两者之间的作法，是因为它可以帮助我们避免掉内存管理的痛苦 (但显
然并非全是痛苦 )，而避免掉因为垃圾清理所致的问题，从额外的内存配置
到没有正确释放内存。  
_______________________________________________ __________________________  
我并没有特别想要深入到垃圾清理策略的问题，或在不同平台上面，是怎
么实作这个功能的。这已经是需要进入研究的议题了。在这里相关的是在
局限性比较大的装置 (例如行动装置 )，垃圾清理目前还不够理想，但在每个
平台上还是有些共通的问题。  
 
然而，在 Object Pascal 里面有些额外的复杂情形，是因为同时要支持桌面
型应用程序跟行动应用程序的编译程序，这几种不同平台的内存管理模式
多少都有点不同。前一版的 Object Pascal 还没有引入 ARC(Automatic 
Reference Counting) 的内存管理技术，只是单纯的人工管理而已。在参考计
算器制上加入了对接口的支持，以组件为主的拥有权模式，以及一些其他
的选项，我们也可以很简单的了解这并不是一个简单的主题。这一章是要
理清问题，我们会从现代程序语言对内存管理的一些基础开始，接着会介
绍在对象参考模型之后的概念。  
 
全局数据、堆栈以及 Heap   
在任何一个 Object Pascal 的应用程序里面所使用的内存可以分成两个领域 :
程序代码与数据。在一个程序的执行文件里面包含几个部分，包含资源 (例
如图片、窗体描述 文件 )，以及由程序加载到内存使用的函式库。这些内存
区块是只读的 (在几个平台上， 例如 Windows) ， 且可以让多个处理程序共享。  
 
仔细研究资料部分也是很有趣的。 Object Pascal 程序 (像大多其他的程序语
言的写法一样 )的数据是分成三大块来储存的 :全局内存、堆栈、 Heap。 筆記   
 362   全局内存  
在Object Pascal 编译程序建议执行 文件的时候，就已经决定了用来储存生
命周期从应用程序开始到结束为止的变量数据所需的内存空间。全局变量
会在单元文件的 interface区段或是 implementation 区段进行宣告， 全局 变量
就会使用这一类的内存。要留意到，如果全局变量是一个类别型别 (或是字
符串、动态数组 )，会使用到全局内存的空间就只有 4 byte或8 byte的对象
参考而已。  
 
我们可以透过 Project|Information 这个选单项目来确定全局内存的大小，只
需在编译完成之后，就可以看到这个数据所需的空间大小。在图 13.1里面，
显示了全局数据使用量约 205K，这个用量是由我们的程序以及函式库所共
同创造出来的。  
 
全局内存有时也被称为静态内存，因为一旦程序被加载了，这些变量所占
用的空间就不会被从一开始的位置被搬走，也不会 被释放，直到应用程序
结束为止。  
_________________________________________________________________________  
 
 
 
  
 
 
 
 
  堆栈 
堆栈是动态的内存区域，这个区域会依照后进先出的顺序来配置与释放。
这意味着最后被配置的内存对象必须最先被删除掉。  
 
堆栈内存通常是由子程序 (程序、函式以及方法 )来使用的，这些内存空间会
用来储存传递的参数、回传的值，以及我们在函式或方法里面宣告的局部
变量。一旦子程序执行完成，它在堆栈的内存空间就会被释放 掉了。反正
要记得，使用 Object Pascal 的默认缓存器呼叫转换功能，透过 CPU缓存器
来传递参数，是永远不可能的。  
 
也要注意到，堆栈内存一般是不会自动进行初始化也不会自动被清除的，圖13.1: 編譯完
成的程式相關資
訊 
 
 363 这是为了节省时间。这也是为什么如果我们在局部变量当中宣告了一个整
数然后直接去读取这个变量的内容，里面居然是有值的，不是 0耶。所有
局部变量都必须先进行初始化，然后才能被使用。  
 
堆栈的大小通常是固定的，并且在编译作业的过程就已经决定了。我们可
以在项目选项的链接程序的设定选项中来设定这些参数。然而，默认值通
常是 OK的。如果我们看 到了『 stack overflow 』这个错误讯息，这或许是
因为我们的程序当中有不断呼叫自己的递归函式，而不是编译程序指派的
堆栈不够大。初始的堆栈大小是在 Project|Information 对话框里面的另一项
信息。  
 
  Heap (堆) 
Heap是程序代码当中可以不依照顺序进行配置 /释放作业的区域。 这表示如
果我们依序配置了三块内存，这三块内存可以在稍后用任何的顺序进行释
放。 Heap管理程序会照看所有的细节，所以我们只要很简单的用低阶函式
GetMem 来要求新的内存，也可以透过呼叫建构函式来建立一个对象，然后
系统就会回传一个新的内存区块 (也可能是从已经释放掉的内存当中回收
使用的 )。Object Pascal 使用 heap来配置每个对象、字符串内容，动态数组，
以及绝大多数数据结构的内存空间。  
 
因为它是动态的， Heap也是程序当中产生最大多数问题的内存区域 : 
 每次一个对象只要被建立了，它就一定得被释放。没有被释放的内存空
间被称为 ”Memory leak” ( 翻成内存泄漏 )，这情形一般来说不会有太大
的伤害，除非这个情形反复发生，而导致整个 Heap都被用光了。  
 每次一个对象被释放了， 我们必须确定被释放的对象已经没有在任 何程
序代码里面被使用了，当然，程序代码也不能对已经被释放的对象重
复进行释放。  
 
对任何动态建立的数据结构也完全一样，但程序语言的函式库会在大多数
的时间自动在字符串与动态数组之后进行处理，所以我们不用担心其余的
处理动作。  
 
对象参考模型  
一如我们在第七章里面介绍过的， Object Pascal 里面的对象是以参考来实作
的。一个类别型别的变量里，只储存了指向该对象在 Heap里面所使用的内
存空间而已。当然还有一些额外的信息，像是类别参考，我们可以透过它 
 364 来存取该对象的虚拟方法列表，但这不是本章的主题。  
 
我们也已经介 绍过如何把一个对象指派给另一个对象，只复制该对象的参
考，所以我们会有两个参考指向同一个内存内的对象。如果要拥有两个完
整的对象，我们必须要建立一个新的对象，然后把原本对象的内容复制到
新对象去 (这个复制的动作不会自动发生，因为实作的细节会依据不同的数
据结构而需要不同的作法 )。 
 
用程序代码的思维来看，如果我们这么写 : 
var 
   Button2: TButton;  
begin  
    Button2 := Button1;  
 
程序不会建立出新的对象，只会把内存里面的同一个对象的参考复制一份
而已。注意喔，内存里 面只有一个对象，而有两个变量 Button1跟Button2
指向这个对象。  
 
  把对象当成参数来传递  
当我们把对象当成参数传递给一个函式或者方法的时候，发生的事情是很
相似的。用一般的字眼来描述，我们只是把同一个对象的参考复制一份而
已，在方法或函式中，我们可以用这个对象来做任何处理，当然也可以修
改它，除非该参数是以 const关键词来描述的。  
 
举例来说，写一个像以下这段程序代码的程序，并呼叫它，我们可以变更
Button1的文字卷标，如果我们喜欢用 AButton，也可以：  
procedure ChangeCap tion (AButton: TButton; Text: string);  
begin  
   AButton.Text := Text;  
end;  
// call...  
ChangeCaption (Button1, ‘Hello’)  
 
假如我们需要一个新的对象呢，要怎么做 ?我们基本上得建立新对象，然后
把每个属性的内容都复制过去。部分类别，只要是 TPesistent 类别的衍生类
别，而不是从 TComponent 衍生出来的类别，就会定义有 Assign这个方法
可以用来复制一个对象的数据，举例来说，如果我们这么写 :  
 365 ListBox1.Items.Assign (Memo1.Lines);  
 
即使我们直接指派了这些属性， Object Pascal 会为我们执行类似的程序代
码。事实上， SetItems方法会把 items属性跟 listbox进行链接，靠的就是呼
叫TStringList 类别的 Assign方法， TStringList 就是 ListBox的实际项目。  
 
所以，让我们试着回忆一下，当把对象当成参数传递时，不同的参数传递
方法修饰词所做的 : 
 如果没有标示特定的传递方法修饰词， 我们就可以对这个对象以及指向
这个对象的变量作任 何处理。我们可以对原始对象作修改，但如果我
们把一个新的对象指派给参数，这个新的对象就无法作任何处理，当
然指向它的变量也一样不行。  
 如果参数上面有 const修饰词，我们可以修改该对象里面的数据，也可
以呼叫该对象的方法，但我们不能指派一个新的对象给这个参数。在
ARC平台上 (行动装置 )，这是较有效率的参数传递方式，因为不需要
对对象的参考计数进行增加或减少的动作。  
 如果参数上面有 var修饰词，我们就可以修改该对象里面的任何数据，
也可以用一个新的对象来取代原来传递进来的参数对象，就跟其他有
var参数的型别一样。  
 
传统的内存管理小技巧  
在Object Pascal 里，内存管理是一个关于两个规则的议题 :第一，我们必须
把我们自己建立的每个对象跟内存区块都释放掉。第二，每个我们自己建
立起来的对象跟内存区块都只能释放一次。 Object Pascal 对动态元素支持三
种形式的内存管理 (也就是说，这些元素不在堆栈，也不在全局内存里面 )，
我们在本节其余的篇幅里面细细道来 : 
 当我们建立了一个对象，我们就有负责把它释放掉的义务。如果我们没
有做到，这个对象所使用的内存空间就不会被释放，也没有机会回收
给其他对象使用，直到程序结束为止。  
 当我们建立一个组件，我们可以确立拥有这个组件的所有者，在建立组
件的时候，把所有者当成该组件建构函式的参数。这个所有者对象 (通
常是窗体或是数据模块 )就担负了对它所拥有的对象释放的责任。换句
话说，当我们释放该窗体，它所拥有的所有组件也会一起被释放掉。
所以如果我们建立了一个新的组件，并且指派了该组件的所有者，我
们就不用担心这个组件释放的问题了。  
 当我们为字符串、动态数组跟被接口参考到的对象 (请参考第 11章的内
容)配置了内存， Object Pascal 会在参考离开执行的范围时，自动把这 
 366 些内存空间释放掉。我们不用释放字符串 的空间：当字符串没有再被
使用到的时候，内存空间就被释放掉了。类似的动作在 ARC机制底下
也会发生，我们稍后会介绍。  
 
  释放我们建立的对象  
在大多数单纯的情境里，在桌上型编译程序的环境中，我们得为我们要释
放的对象建立临时对象。任何非临时的对象都应该要有所有者，可以是一
个集合的成员，可以被一些数据结构存取，这些所有者在运行时间到达要
结束的时机，要担负释放这些对象的义务。  
 
用来建立、释放临时对象的程序代码通常都会用 try-finally区块来封装，这
样可以保证就算在使用该对象的过程中发生问题，也确保可以把该对 象给
释放掉：  
MyObj := TMyClass.Create;  
try 
   MyObj.DoSomething;  
finally  
    MyObj.Free;  
end;   
 
另一个常见的情境则是某个对象被另一个对象所使用，它就变成了这个对
象的所有者：  
constructor TMyOwner.Create;  
begin  
   SubObj := TSubObject.Create;  
end;  
destructor TMyOnwer.Destroy;  
begin  
   SubObj.Free;  
end;  
 
还有一些常见的情境复杂的多，万一对象在需要被使用的时候还没有被建
立出来 (延迟初始化 )或比所有者更早被释放掉了 (因为后面的程序代码里面
不会再用到它 )。要实作延迟初始化的话，我们就不能在该对象的所有者的
建构函式里面建立它，而得要在需要该对象的时候才来建立，如下面的程
序片段所示 : 
function TMyOwner.GetSubObject: TSubObject   
 367 begin  
   if not Assigned (SubObj) then  
SubObj := TSubObject.Create;  
   Result := SubObj;  
end;  
destructor TMyOnwer.Destroy;  
begin  
   SubObj.Free;  
end;  
 
留意到我们不需要在释放之前检查该对象是否已经被建立了，因为这动作
在Free方法里面就会做了，我们会在下一节看到这一点。  
 
  只能把对象释放一次  
另一个问题就是我们如果呼叫了一个对象的解构函式两次，我们就会导致
错误。解构函式 是用来释放一个对象所使用的内存空间的方法。我们可以
为解构函式写一些程序代码，通常是重载预设的 Destroy解构函式，好让对
象在被释放 掉之前还能执行这些程序代码。当然，在我们的程序代码里面，
不用去处理内存释放的动作，这一点，执行时期函式库会帮我们做了。  
 
Destroy是一个属于 TObject的虚拟解构函式。大多数需要在对象被释放前
进行自定清理动作的类别，都会重载这个虚拟方法。  
 
我们之所以不用定义一个新的解构函式，是因为大硕的对象通常都会呼叫
Free方法来释放对象，而 Free这个方法会帮我们呼叫 Destroy这个虚拟解
构函式 (也可能是重载后的版本 )。 
 
刚刚我们有提到过， Free是TObject类别的一个方法，几乎所有的类别都会
继承它。 Free方法基本上会检查该对象 (self)，确定它不是 nil，然后才会呼
叫Destroy虚拟解构函式。  
_________________________________________________________________________  
您可能会觉得奇怪，为什么当对象参考是 nil的时候，还可以安全的呼叫它
的Free方法， 但我们却不能直接呼叫 Destroy方法 ?理由是 Free方法是位于
已知的内存空间， 而虚拟函式 Destroy是在运行时间依照该对象的型别进行
搜寻以后决定的，搜寻的结果有可能会是对 象不存在，那这个动作就非常
危险了。  
以下是 Free方法的虚构程序代码 (在ARC的环境中，这里面就有相当大的筆記   
 368 部份需要修改了 ): 
procedure TObject.Free;  
 begin  
   if Self <> nil then  
Destroy;  
end;   
 
接下来，我们可以把注意力移到 Assigned 函式了。当我们把一个指标传递
给这个函式的时候，这个函式会单纯的检查指标内容是不是 nil。所以以下
两个叙述句是相同的 (至少在大多数情形下是如此 ): 
 if Assigned (MyObj) then .. . 
 if MyObj <> nil then ...  
 
注意到这些叙述句只会在指标内容不是 nil的时候进行检查，如果指标内容
是不合法的，就不会进行检查的动作了。如果我们这么写 : 
 MyObj.Free;  
 if MyObj <> nil then  
   MyObj.DoSomething;  
 
检查的动作会通过喔，也就是说 MyObj的内容不会是 nil，所以接下来的那
行指令就会出错了，因为我们呼叫了一个已经被释放的对象的方法。要知
道，呼叫了 Free方法之后，该对象的指针并不会被设为 nil的。  
 
要自动把一个对 象设成 nil是不可能的。我们可能会有很多个参考指向同一
个对象。且 Object Pascal 在传统未支持 ARC的编译程序并不会追踪这些对
象。同时，我们可以在方法当中对一个对象进行处理，但我们并不知道该
对象的参考 -该变量的内存地址 (我们会用来呼叫这个方法 )。 
 
换句话说，在 Free方法的内部，或一个类别当中任何其他的方法，我们可
以知道该对象 (self)的内存地址，但我们不会知道参考到这个对象的变量的
内存地址，例如 ToDestroy 。因此， Free方法不会动到 MyObj变量的内存
内容，只会释放 MyObj所指向的对 象。  
 
然而，当我们呼叫一个外部程序，像是 FreeAndNil 的时候，这个程序知道
对象的参考，因为它被当成参数传递进来了，所以我们可以对它进行处理，
以下是 Object Pascal 在FreeAndNil 函式里面的程序代码：  
 
procedure FreeAndNil(var Obj);   
 369 var 
   P: TObject;  
begin  
   P := TObject(Obj);  
   // clear the reference before destroying the object  
   TObject (Obj) := nil;  
   P .Free;  
end;   
 
整理一下，以下是几个准则 : 
 一定要呼叫 Free来释放对象，不要呼叫 Destroy解构函式。  
 使用 FreeAndNil ，或在呼叫 Free之后要把该变量的内容设成 nil，除非
参考在该函式里面是最后一行， Free完以后就没有任何程序代码用到
该对象了。  
 
欢迎到 ARC(Automatic Reference Counting)
的世界  
目前我们介绍的，都是传统的 Object Pascal 内存管理情境 (当然其中也有一
些例外，例如接口变量，以及其他我们在相关 的章节已经介绍过的例子 )。
当我们使用支持 ARC功能的编译程序时，许多规则跟过去我们习惯的已经
很不一样了。  
_________________________________________________________________________  
当本书正在撰写的时候， Object Pascal 支持 ARC功能的编译程序包含了：
iOS 32位与 64位版、 Android版， 以及 iOS仿真器版。 目前在 Win32、Win64
以及 Mac OS X 的编译程序还没有支持这个功能。  
 
但什么是 ARC呢?它又是从何而 来的呢 ?ARC是Automatic Reference 
Counting 的缩写，这个功能是由 Apple在为 iOS发展的 Objective -C编译程
序里面提出的 (译者 :更精确一点来说，是在 Xcode 4.0 的时候发表的 )，后来
Apple也把这个功能带到了其他语言，然后又带到了其他平台。这个功能的
实作，几乎完全是 LLVM架构与 CLANG 的一部分。我们可以从 ARC在
Objective -C的使用来学习到更多关于这个技术的概念 (透过 CLANG项目 )： 
http://clang.llvm.org/docs/Automa ticReferenceCounting.html  
 
在这个页面里，我们可以看到， ARC是用来管理对象生命周期的一个方法，
让我们可以不用再特别写明了要释放哪个对象？当一个对象的参考 (例如筆記   
 370 一个局部变量 )离开了它的执行范围，这个对象就会被自动摧毁。 Object 
Pascal原本对字符串与透过接口型别参考的对象变量， 就有支持了参考计数
(Reference Counting) 。所以，以对象来说，在传统 Object Pascal 的编译程序
里面最接近 ARC的，就是界面的使用了。 ARC跟垃圾收集 (GC，Garbage 
Collection) 不同的地方，是 ARC非常确定，且对象是随着应用程序的流程
建立与释放的，并不是以一个独立的背景线程。这样做，有好有坏，但 GC
跟ARC之间的争论已经超出了本书的范围。  
 
  ARC程序风格  
当我们使用支持 ARC的编译程序 (有支持参考计数 )，我们可以用一个方法
(method)来建立临时的对象，然后不用记得要释放这个临时对象了。所以新
的程序代码里面就不需要呼叫 Free这个方法了，但某些受管理的型别有全
自动的 try-finally区块，我们不需要加入例外处理的区块 : 
var 
   MyObj: T MyClass;  
begin  
    MyObj := TMyClass.Create;  
    MyObj.DoSomething;  
end;   
 
在这里，该对象的解构函式会在程序执行到达 end的时候被自动呼叫，仔
细点说，就是当 MyObj变量离开了执行范围的时候。不管任何理由，如果
我们需要在执行到该方法结束点之前停止使用一些对象，举例来说，因为
这个方法太长，我们不想让该对象活这么久，那可以直接把该对象变量设
成nil就行了 : 
var 
   MyObj: TMyClass;  
begin  
   MyObj :=  TMyClass.Create;  
   MyObj.DoSomething;  
   MyObj := nil;  
   // some other code not using MyObj  
end;   
 
在这个案例中，对象会在这个方法执行完毕之前就被释放掉，就是因为我
们把该变量指派了 nil的原因。  
  
 371 由于这里并没有 try-finally区块， 万一上面程序代码当中的 DoSomething 程
序触发了意外事件，会发生什么事呢 ?nil的指派动作将会被跳过，但程序代
码执行到这个方法结束的时候，对象还是一样会被释放掉。  
 
总而言之，参考计数在我们把一个对象指派给变量的时候就开始运作了，
而当变量离开了执行范围之后，不管这个变量是局部变量 (局部变量是以堆
栈为基础的 )、由编译程序主动加入的临时变量，或者是另一个对象的数据
字段。因此，当我们使用支持 ARC功能的编译程序时，如果一个对象拥有
另一个对象，我们是不用在所有者对象的解构函式当中试图释放被拥有的
对象的。  
 
对于参数，规则也是一样的 :当我们把一个对象当成参数传给函式，对象的
参考计数会被增加，而当函式执行结束并回到呼叫该函式的程序流程当中，
这个参考计数就会被递减 : 
functi on UseObject (AnObj: TMyClass);  
begin  
   ...  
end;   
var 
   MyObj: TMyClass;  
begin  
   MyObj := TMyClass.Create; // refcount to 1  
   UseObject (MyObj); // refcount to 2, then back to 1  
end;  // refcount to 0, object destroyed  
________________________________ _________________________________________  
同样的规则也适用于字符串， 我们可以透过使用 const参数描述词来优化参
数传递。当一个对象被当做常数进行传递，就不用承受参考计数处理的额
外工作了。如果我们也在 Windows 平台上使用 const参数描述词，就没有
实质的帮助了， 对于对象跟字符串参数都使用 const参数描述词是个好的建
议。别期望加了这个描述词，程序就会有很明显的效能改善，因为参考计
数的额外工作是很小的。  
 
要更深入了解对象的生命周期，并随着程序流程来理解 ARC背后的参考计
算器制，我们可以使用名为 RefCount 这个新的属性来查询对象当时的参考
计数。  
 
我们不应该用这个属性来提示对象在程序执行过程当中的生命周期，最好
只用来检测一个对象的状态，并且理解其模式。当然，这个属性只有在支筆記   
 372 持ARC的平台上，所有对象才能使用它。  
_________________________________________________________________________  
有些情境很特殊，我们会想要对 ARC跟非 ARC编译程序写出最好的程序
代码，例如函式库。在这个例子，与其检测 特定的编译程序给所有平台与
系统 (未来可能会在不同平台上有不同的规则 )，我们可能会想要使用
{$IFDEF AUTOREFCOUNT} 这个编译程序开关来区别两种不同的模式。这
是一个很重要的编译程序开关，跟 NEXTGEN 不一样， AUTOREFCOUNT
通常是跟 LLVM类型的编译程序紧密相依的。事实上， ARC这个功能未来
可能会被实作在 Delphi编译程序当中，成为基础规则之一 (就像目前在 iOS
仿真器一样 )。 
 
  在ARC底下的 Free跟DisposeOf 方法 
Object Pascal 开发人员已经很习惯使用 Free方法， 并且通常会用个 try-finally
区块来保护程序代码。由于大多数 Object Pascal 的开发者长期以来已经累
积了许多既有的程序代码，且大多数都是依循前述的作法，也需要这么写，
才能同时提供对 Windows 平台的兼容性， 所以在探讨 ARC模式下使用 Free
就很重要。  
 
简单的说，我们现有的程序代码还是可以运作，但我们需要把这一节好好
读完，好了解它的运作原理，以及当中发生了什么不同，最重要的是我们
能有哪些选择。举例来说，如果我们有以下这段程序代码 : 
var 
   MyObj: TMySimpleCla ss; 
begin  
   MyObj := TMySimpleClass.Create;  
   try 
      MyObj.DoSomething;  
   finally  
       MyObj.Free;  
   end;  
end;   
 
在传统没有支持 ARC的Object Pascal 编译程序当中， Free是TObject的方
法之一，会检查当前的参考是否为 nil，只有在当前的参考不是 nil的时候，
才会呼叫该对象的 Destroy解构函式， 解构函式会在执行了适当的解构程序
代码后，把对象从内存移除。  
 筆記   
 373 在新的支持 ARC的Object Pascal 编译程序中， Free的呼叫就改成了直接把
nil指派给该变量。这是该对象最新的参考值，它也会在呼叫该对象的届够
函式后，把对象从内存里面移除。在此情形下，两种模式的内存处理行为
几乎是一致的。如果还有其他变量参考到这个对象，就什么也不会发生 (只
有该对象的参考计数会被减一而已 )，这一点跟传统的模式就很不一样，在
传统的模式中，该对象就会直接被移除，然后其他参考到这个对象的变量
或指针，就会只剩一个空荡荡的参考 (该参考已经没有对象了，使用它就会
发生内存使用违规错误 Access Vi olation)。 
 
那如果呼叫 FreeAndNil(MyObj) ，不要直接呼叫 Free呢?这种情形也几乎完
全一样，因为在不支持 ARC的编译程序中，我们最后还是把对象参考设成
了nil，在支持 ARC的编译程序当中，当呼叫 Free的时候，最后都会把对
象参考设为 nil。 
 
所以，这样做没问题吗 ?好的，大多数情形下都没问题，但有些时候还是不
行的。当我们在某些情形下真的想立刻执行解构函式 (可能是要关闭一个 文
件，或者关闭对数据库的联机 )，不管是否还有其他变量在使用这个对象。
在Object Pascal 的RTL函式库以及 其他第三方的函式库里面也有一些案例，
会在还有部分变量或参考存在时，需要强制呼叫解构还是来释放这些对象
的(例如在两个对象当中有从属关系时 )。 现在， 这个情形可以透过使用 weak
参考来解决 (译者 : 这也是 Apple在iOS上面提供的语言功能之一，然而从
iOS 6到iOS 8之间的数个版本，对于 weak, strong 在编译程序上面的处理
并不一致，因此常使得开发人员一头雾水 )，我们稍后会介绍，而另一个作
法，则是直接立刻强制执行解构函式的程序代码。  
 
为了让开发人员可以强制执行一个对象的解构函式的程序代码 (但不把对
象的数据真的从内存移除 )，支持 ARC功能的编译程序发表了一个释放的
模式，如果我们呼叫 : 
MyObject.DisposeOf;  
 
这个指令就会强制执行解构函式的程序代码，即使还有任何其他的参考指
向这个对象也一样。此时，该对象会处在一个特殊的状态下，因此解构函
式无法被重复执行，万一其他的参考也进行了释放的要求，或是参考计数
的值来到了 0，内存会真的被释放掉。这个『已被释放』的状态 (或者称为
殭尸状态，这个名词是从 Xcode而来，译者在 Xcode 2.0 开始就有用过当中
的zombie状态来检测 iOS当中对象的状态 )在实际程序代码当中是相当特
别的， 这也是为什么我们需要使用 Disposed 属性来查询一个对象的状态了。  
  
 374 举个例子，如果我们需要强制立即执行解构函式，我们可以像以下的程序
片段这样写 : 
var 
   MyObj: TMySimpleClass;  
begin  
   MyObj := TMySimpleClass.Create;  
   try 
     MyObj.DoSomething;  
   finally  
     MyObj.DisposeOf;  
   end;  
end;   
 
现在，问题变成了『这个写法在不支 持ARC的编译程序里也能运作吗 ?』
在不支持 ARC的编译程序里面， 呼叫 DisposeOf 会直接对应去呼叫 Free法，
所以基本上，规则是一致的。  
 
现在，少数的开发人员问道『如果这些程序代码的效果一样，那可以直接
呼叫 Free，让编译程序自动对应不就行了吗 ?』在我的观点来看，这不是个
好主意，因为使用 DisposeOf 不应该变成不支持 ARC平台程序代码的标准
作法。应该使用 weak参考或者用新的概念对内存管理进行重整，然后试着
用可对应所有平台的单一作法来完成这个概念。由于 Free已经是尚未支持
ARC功能的 Object  Pascal程序代码当中非常普遍的用法，而在支持 ARC
功能的程序代码当中应该只要把要释放的变量指派 nil即可，我们可以把这
两种概念互相对应 (而不是进行处理 )， 来达成确保两种平台之间的转换最为
平顺，并提供最高的兼容性。  
_________________________________________________________________________  
用来储存 Disposed 这个变量的空间，并不是额外的字段，而是支持 ARC
时，在每个对象的参考里面都有一个 FRefCount 的位字段。因为第二个 位
是用来侦测是否已经被是释放之用，参考计数在理论上的限制是 2的30次
方，这个上限实际上很难被超越。  
 
一如 Allen Bauer(RAD Studio 研发首席科学家 )在一个对话当中给我的建
议，有一个可以深入找寻 Free跟DisposeOf 之间的差异，就是从这两个动
作在 ARC环境之下的用意 (跟在古典 Delphi编译程序的行为来比较 )。 
 使用 Free的时候，用意是特定的参考要单纯的被从该实体上『卸除』
掉。这并没有导致任何形式的释放或内存反配置的动作。这只是说该
程序代码区块不再需要该参考了。通常这个情形会发生在 执行动作脱筆記   
 375 离了该范围，但我们也可以用程序代码强制要求呼叫 Free这个方法。  
 相对的， DisposeOf 则是让开发人员直接告诉该实体，要清理自己使用
的空间了。 DisposeOf 永远不会导致内存的反配置，它几乎只是要求该
实体进行『清理』 (执行解构函式的所有程序代码 )。该实体仍旧会依照
一般的参考计数的作法，最后在参考计数达到 0的时候对其使用的内
存空间进行反配置。  
 
换句话说， 在 ARC底下， Free是一个”以实体计数为准 ”的动作， 而 DisposeOf
则是”以实体为准 ”的动作。 Free意味着『我不在乎实体发生了什么， 我就
是不再需要它了』 。而 DisposeOf 则意味着『我还需要这个实体，但我想要
它清除掉目前这个实体已经使用到的非内存资源 (像是文件、数据库、网络
联机等等 )』。 
 
DisposeOf 的另一个用法，是由程序代码写明了要呼叫它，用来清理，并释
放因过于繁复的参考循环导致的内存配置。虽然使用 weak参考 (我们在下
一节即将介绍 )会让程序代码更为清楚、明白，可能有一些明确的触发或是
通知是需要『告诉』其他实体要放弃它们所使用的参考。  
_____________________________________________ ____________________________  
关于混用指针跟对象的小笔记。在传统不支持 ARC的Object Pascal 程序代
码里面，我们可以把对象指派给一个指针，把该对象变量当成一个不同的
对象来重复使用，稍后再把指针指派回来给对象变量。如果我们在 ARC环
境下做一样的事情， 这个对象一下就会消失了 : 因为该对象的参考计数会变
成0(因为该指标不会被列入参考计数，所以把对象指派给指针并不会让参
考计数加 1)，然后对象就会被释放掉了。  
 
  总整理：在 ARC与非ARC编译程序中对象的建立与消灭  
我知道前 几节可能会让读者在阅读的过程中有不少疑惑。 Object Pascal 在不
同的编译程序中支持两种不同的内存模式，的确让事情有些复杂，然而在
真实世界的实战情形中，像组件的所有权以及许多常见的技术，都协助开
发人员在 Object Pascal 应用程序中管理内存更为顺畅。  
 
为了协助了解这两种模式之间的差异，我觉得用个比较表把这些内容列出
来会是有帮助的，所以我们提供了表 13.1，针对每个常用的动作，我解释
了当中的效应以及所有的差异，以 ARC与非 ARC编译程序来做区分 : 
 
 
 筆記   
 376 表13.1 以ARC与非 ARC功能为区分， 许多不同动作之间的差异比较  
 传统形式  ARC形式  
呼叫 Create
建构函式  配置内存， 执行初始化程序
代码， 就算建构函式的名称
不同，动作也不会有所差
异，当然这没什么相关的。  效应相同，留意到初始参考计
数会在新建的对象被指派到变
量(不管是暂时变量或被宣告的
变量 )的时候被递增，但不会在
建构函式本身。  
指派给另一
个变量， 或者
当成传值 (标
准方式 )参数
传递  
 两个变量单纯的参考到内
存中的同一个对象。 我们自
己决定是否要忽略内存泄
漏，跟让参考放着不用。  也是两个变量参考到同一个对
象，但对象也让其参考计数进
行递增。当该 变量还在其执行
范围内， ARC会保持变量可用，
并自动管理内存。  
以const或传
址形式作为
参数传递  
 没有明显的不同， 从内存管
理的角度来看  在参考计数的字段没有增加 /减
少，让程序代码更为简洁，如
果适用 ARC计数的话。  
呼叫解构函
式Destroy  Destroy应该不能直接被呼
叫。 它的效果是执行该对象
的完成化的程序代码， 并释
放掉所使用的内存空间。  
 在ARC的情境下， Destroy会
执行该对象的完成化程序代
码，而内存释放则是另一个完
全分离的动作。  
呼叫 Free方
法 呼叫 Free方法会启动该对
象的 Destr oy解构函式 (除
非该对象的参考已经被设
定成 nil了) 呼叫 Free方法，会把该对象的
参考指派为 nil。这个动作会让
该对象的参考计数减一。这个
对象会在参考计数的数值被减
到0的时候，自动进行释放的
程序。  
 
呼叫 Dis- 
poseOf方法  跟呼叫 Free方法相同  强制执行解构函式的程序代
码，但不删除对象，也不会把
对象的参考计数减一。  
 
把nil指派给
某个参考  不做任何事， 参考原本所指
的对象并没有被摧毁， 这一
来该对象原本使用的空间
就变成了内存泄漏。  把参考计数减一，如果参考计
数的内容变成 0了，就会摧毁
该对象   
 377  传统形式  ARC形式  
呼叫 Free- 
AndNil程序  会先把该对象摧毁， 然后把
原来指向对象的指针指派
为nil(避免未来其他程序
代码再用到这个参考时发
生错误 ) 跟呼叫 Free方法，以及把 nil
指派给参考的效果一样 (这些效
果都是在 ARC环境内才会发生
的喔 ) 
 
  Weak参考 
在ARC(Automatic Reference Counting) 当中另一个很重要的概念是 weak参
考的角色。在参考计数模式当中，有一个问题是如果两个对象互相参考，
这情形称之为循环参考， 此时它们的参考计数基本上永远不会变成 0。Weak
参考提供了一个机制来打破这样的循环，让我们可以定义一个参考，而不
增加这个参考的计数。  
 
假设两个对象互相参考，把对方储存在自己的数据字段中，并用一个外部
变量把第一个对象储存起来。此时第一个对象的参考计数将会是 2(外部变
量，以及另一个对象的数据字段各占 1):而第二个对象的参考计数将会是
1(第一个物件的数据字段 )。图 13.2描绘了这个情境。  
_________________________________________________________________________  
 
 
 
 
 
  
现在，当外部变量离开值刑犯为时，两个对象的参考计数都会只剩下 1，然
后这两个对象就会永远留在内存里面了。为了解决这一类的问题，我们需
要打破其中的循环参考，要达到这一点并不简单，因为我们并不知道何时
可以进行这项作业 (这项作业应该要在最后一个外部连结参考脱离执行范
围时处理，但两个循环参考的对象则无从得知这个条件是否发生了 )。解决
这个情况以及类似情况的方法，就是使用 weak参考。一如我们所描述的，
weak参考是一种当对象参考被指派进来时，不会对该对象的参考计数进行
递增的特殊参考。技术上来说，我们只需要在该参考上面加 上[weak]标注即
可。  
 
 圖13.2 : 物件之
間的參考可能發
生循環， weak參
考可以處理這個
情形  
 
 378 _________________________________________________________________________  
标注是进阶的 Object Pascal 语言功能之一，我们在第 16章会介绍到这个功
能，我只想说，这是对特定符号在运行时间当中加上一些信息的方法，这
样一来，外部的程序代码就可以决定如何处理它。  
 
因为前一个情境，如果第二个对象中指回第一个对象的参考是 weak参考，
当外部变量离开了执行范围，两个对象就都可以被释放掉了。  
_______ __________________________________________________________________  
 
 
 
 
 
 
  
我们来看一下这个情形的实作程序代码 : 
type  
    TMyComplexClass = class;  
    TMySimpleClass = class  
    private  
        [Weak] FOwnedBy: TMyComplexClass;  
    public  
        constructor Create();  
        destructor Destroy (); override;  
        procedure DoSomething(bRaise: Boolean = False);  
    end;   
    TMyComplexClass = class  
    private  
        fSimple: TMySimpleClass;  
    public  
        constructor Create();  
        destructor Destroy (); override;  
        class procedure CreateOnly;  
    end;   
 
以下是 TMyComplexClass 类别的建构函式，用来建立另一个类别的对象 : 
constructor TMyComplexClass.Create;  
begin  筆記  
圖13.3 : 在圖
13.2裡面的循環
參考，因為使用
了weak參考而
被打破了 (虛線表
示) 
 
 379    inherited Create;  
   FSimple := TMySimpleClass.Create;  
   FSimple.FOwnedBy := self;  
end;   
 
记得 FOwnedBy 字段是一个 weak参考， 所以它不会增加所指向 的对象的参
考计数，在这个例子中，就是指当前的对象 self。因为这样的类别结构，我
们可以把程序代码这么写 : 
class procedure TMyComplexClass.CreateOnly;  
var 
    MyComplex: TMyComplexClass;  
begin  
    MyComplex := TMyComplexClass.Create;  
    MyComplex.fSimple.DoSomething;  
end;  
 
这段程序代码不会造成内存泄漏，因为 weak参考已经被适当的使用了。  
 
  Weak参考是受到管理的  
ARC模式里面一个很重要的元素，是 weak参考是受到管理的。换句话说，
系统会在内存里面维护一份 weak参考的列表，当对象被释放的时候，系统
会检查是否有 weak参考指向它，并且适当的进行标示。这表示 weak参考
在运行时间是有额外的代价的，但话说回来，我们自己在程序代码里面做
这样的交叉检测，代价一定更高。  
 
具备这种受管理的 weak参考，跟传统的作法相较之下，好处是我们可以检
测一个参考是否还是可用的 (意指所指向的对象是否已经被释放了 )。 当我们
使用 weak参考，我们就不用检查它是否为 nil。我们可以做的是先把 weak
参考指派给 strong参考 (它会在背景进行一些检查 )，然后检查 string参考的
内容。举例来说，因为 FOwnedBy 是weak参考，所以我们可以这么写 : 
var 
   TheOwner: TMyComplexClass; // strong reference alias  
begin  
   TheOwner := FOwnedBy;  
   if TheOwner <> nil then  
     TheOwner.ClassName; // safe to use  
end;   
 380   检测循环  
如果我们怀疑一组在几个对象之间互相参考链接可能有循环参考的情形，
有一个小函式可以协助我们检查应用程序的行为。这个函式是在
System.Classes 单元当中的，名为 CheckForCycles:  
procedure CheckForCycles(const Obj: TObject;  
   const PostFoundCycle: TPostFoundCycleProc); overload;  
procedure CheckForCycles(const Intf: IInterface;  
   const PostFoundCycle: TPostFoundCycleProc); overload;  
 
这个函式在我们一般的程序代码里面不太会用到，只有在开发过程跟侦错
过程当中才会使用。这个程序的第二个参数是一个要求对象类别作为参数
的匿名函式 (匿名函式我们会在第 14章里面介绍 )，在匿名函式里面，会检
查它的内存地址、以及该对象的堆栈是否出现了循环。这是个相对简单的
例子，以稍早在删除 weak参考之后提到的类别为基础 (当然，使用了 weak
参考的话，就不会有循环的状况发生了 ): 
var 
   MyCo mplex: TMyComplexClass;  
begin  
   MyComplex := TMyComplexClass.Create;  
   MyComplex.fSimple.DoSomething;  
   CheckForCycles (myComplex,  
     procedure (const ClassName: string; Reference: IntPtr;  
       const Stack: TStack<IntPtr>)  
     begin  
       Log('Obj ect ' + IntToHex (Reference, 8) +  
         ' of class ' + ClassName + ' has a cycle');  
     end)  
 
我们会在第 17章里面另外回头来看 weak参考，在讨论对象的所有权关系
的时候。  
 
  unsafe标注 (The unsafe Attribute)  
有些情况是很特殊的 (例如在一个实体建立的过程中 )，在这些特别的情形
中，可能是一个函式要把一个参考计数为 0的对象刚建立出来，回传给另
一段程序代码使用。在这个案例中，为了避 免编译程序马上把该对象删除
掉(在程序代码还没来得及把建立出来的对象指派给变量之前，可能就得先 
 381 把对象参考增加为 1才行 )，我们必须把这个对象标示为 ”unsafe”。 
 
这里的含意是，该对象的参考计数必须先暂时被忽略，才能让程序代码安
全”safe”。这个行为是透过使用新的特殊标注 ”[unsafe]” 来达成的。这个功能
我们应该指会在很特别的情形中才需要用到。以下是范例的语法 : 
var 
   [Unsafe] Obj1:  TObject;  
   [Result: Unsafe] function GetObject : TObject;  
 
这个标注的使用在实作建构模式的时候是很有用的。建构模式跟工厂模式
一样，在一般用途的函式库当中都会用到。它主要限于对象的初始化，且
不应该被用在一般需要忽略参考计数的情形。  
 
  Unsafe编译程序指令  
在System单元文件里面，这个标注会被对应的编译程序指令取代，这个编
译程序指令也叫 unsafe，因为我们不能在标注还没被定义之前就使用它 (在
同一个单元文件的后段 )。 
 
使用这个功能的范例是一个低阶的 TObject类别函式，名为 InitInstance ，用
以为一个对象配置内存，它的宣告 如下 : 
type  
    TObject = class  
    public  
       constructor Create;  
       procedure Free;  
       class function InitInstance(Instance: Pointer):  
              TObject {$IFDEF AUTOREFCOUNT}unsafe{$ENDIF};  
 
在Object Pascal 的运行时间函式库里面， unsafe编译程序指令的使用是限
定在 System单元文件面的。 它永远不会在其他单元文件里面使用到。 反之，
[unsafe]标注则可以在其他的函式库跟应用程序的程序代码里面扮演重要的
角色。  
 
  在参考计数的背后  
虽然在大多数的情境下，我们只要把程序代码改成适用参考计数，可能只
需要适时的加入 weak参考和 unsafe标注， 但还是有些情形我们必须直接用 
 382 自定的方式来配置与管理对象的内存。  
 
在类似的情境中，对象无法用参考计数进行适当管理，而且我们最后可能
得到一个对象，我们需要在这个对象还没有实际参考时，把它保留在内存
里面。在这样不常见的案例中，我们可以呼叫两个 TObject类别的虚拟方法
来强制对参考计数的值做修改：  
function __ObjAddRef: Integer; virtual;  
function __ObjRelease: Integer; virtual;  
 
这两个方法都会在处理完毕之后回传参考计数 (使用一个很像基础接口
IInterface 具名函式的方法 )。 
_________________________________________________________________________  
以上的两个函式实作了 Delphi里面参考计 数的核心功能，会由编译程序在
需要的时候自动触发。当我们把一个对象指派给一个新的变量的时候，多
出来的动作是呼叫虚拟方法列表中的一个函式，会对该对象的一个字段进
行递增。这作法会比其他实作 ARC的作法快上许多，包含目前 Apple在
Objective -C里实作的 ARC方法。  
 
使用这些方法的另一种可能情境，是当我们要把一个内存区块 (可能是由一
个外部 API的函式所回传的 )当成或转型成一个对象型别时。  
 
另一个例子，我们从 RTL当中取出，是当我们使用指标 (这段程序代码有使
用IFDEF，以下是 ARC的版本 )复制一个对象的 数据时：  
class function TInterlocked.CompareExchange(  
    var Target: TObject; V alue, Comparand: TObject): TObject;  
begin  
    if V alue <> nil then  
      V alue.__ObjAddRef;  
    Result := TObject(CompareExchange(  
      Pointer(Target), Pointer(V alue), Pointer(Co mparand)));  
    if (V alue <> nil) and  
       (Pointer(Result) <> Pointer(Comparand)) then  
       V alue.__ObjRelease;  
end;  
 
  在ARC环境中混用接口跟类别  
我们已经在第 11章里面提到过，真的不建议把对象参考跟接口参考在内存筆記   
 383 中的同一个对象当中混合，因为两种模式可能最后互相产生干扰。当接口
参考计数变成 0，事实上，该对象就会被释放掉，即使还有其他对象参考变
量还在使用它。  
 
这只有在非 ARC编译程序时成立。在 ARC环境中，对象跟接口参考会共
享相同的参考计算器制，所以既使已经没有接口参考存在，对象参考仍会
维持该计数为可使用的状态。这也使得在 Object Pascal 里面使用接口更为
容易，即使是在支持 ARC的平台上面。  
 
追踪与检测内存  
在这一章，我们已经看过了 Object Pascal 里面内存管理的基础。在大多数
的案例中，只要遵循在本章所提到的规则，就已经足够让整个程序维持稳
定、避免过度使用内存，并基本上让我们可以不用去管内存管理。在本章
后段还有一些进阶的实例，可以用来撰写强健的应用程序。  
 
在这一节里面，我们要专注在可以用来追踪内存使用的技术，监控异常状
况，并且找出内存泄漏的情形。这对开发人员来说是很重要的，即使这并
非程序语言的一部分，而比较属于运行时间函式库的支持。同时，实作内
存管理也是跟目标平台与操作系统息息相关的， 我们是可以在 Object Pascal
应用程序当中外挂一个自定的内存管理员的 (这个作法目前已经很普遍了 )。 
 
留意到，我们目前所有的讨论都是关于追踪内存状态、内存管理、泄漏状
况侦测则只跟 heap内存有关。堆栈跟全局内存的管理是不同的，且我们没
有办法干预，但这也是内存区域中不常发生问 题的部分。  
 
  内存状态  
要怎么追踪 heap内存的状态 ?在RTL里面提供了一些有用的函式：
GetMemoryManagerState 跟GetMemoryMap 。 内存管理员的状态是指不同大
小的配置区块数目， heap地图则相当友善的在系统阶层描绘出应用程序的
内存状态。我们可以用以下的程序代码来检测每个内存区块的实际状态 : 
for I := low(aMemoryMap) to high(aMemoryMap) do  
begin  
   case AMemoryMap[I] of  
       csUnalloc ated: ...  
       csAllocated: ...  
       csReserved: ...   
 384        csSysAllocated: ...  
       csSysReserved: ...  
   end;   
end;   
 
  FastMM4  
在Windows 平台上，目前的 Object Pascal 内存管理名为 FastMM4 ，是主要
由Pierre La Riche 所领导的开放原始码项目开发出来的， Pierre是来自南非
的Delphi程序人员。 FastMM4 优化了内存的配置，加速、 并节省了许多内
存的使用量。 FastMM4 可以透过许多精简的内存清除程序，来达成许多进
阶的内存检测，包含对已经删除的对象进行不正确的使用，包含透过接口
存取数据、在内存上重载，以及在缓冲区溢出等。它也对遗留在内存中的
对象提供了一些响应，帮助我们追踪内存泄漏的状况。  
 
事实上， FastMM4 的一些进阶的功能，只能在完整版的函式库中执行 (我们
在『在完整版 FastMM4 上的缓冲区溢出』加以介绍 )，标准版的 RTL里面
并没有提供这些功能。这也是为什么我们会需要完整版的原因了，我们可
以从这里下载完整版的原始码 : 
http: //fastmm.sourceforge.net  
 
_________________________________________________________________________  
如果您下载了完整版的 FastMM4( 或者如果我们使用了目前在标准版 RTL
里面的版本 )，我们应该考虑一下捐助给作者，因为他真的花了很多时间来
开发这个很棒的软件。  
 
  追踪泄漏以及其他全局设定  
RTL版本的 FastMM4 可以调整为使用 System单元里面的全局设定。留意
到，相关的全局设定是在 System单元里， 实际上的内存管理模块则是在
getmem.inc 这个 RTL原始码文件里面。  
 
再提一次，这个功能在 Windows 应用程序里面默认就是启用的，但在其他
的操作系统上则不是，在其他操作系统上则是使用该系统原生的内存管理
模块。  
更容易使用的设定是 ReportMemoryLeaksOnShutdown 全局变量，这个变量
让我们更容易追踪内存泄漏的情形。我们需要在程序执行前就启用它，在
程序结束之后，它会告诉我们在执行过的程序代码 (或者我们使用的任何函筆記   
 385 式库 )里面有没有发生任何内存泄漏的情况。  
________________ _________________________________________________________  
更进阶的内存管理模块设定，包含 NeverSleepOnMMThreadContention 全局
变量，可以用来处理多线程的配置 ; GetMinimumBlockAlignment 跟
SetMinimumBlockAlignment 函式则可以加速一些 SSE的处理，并降低使用
更多内存的代价 ;全局程序 RegisterExpectedMemoryLeak 则提供了注册预期
发生内存泄漏情形的能力。  
 
为了展示标准的内存泄漏回报与注册功能，我写了简单的 LeakTest 范例项
目。 在这个项目中有一个按钮， 它的事件处理程序程序代码 (这样写很不好，
这是故意写的 )如下 : 
var 
   p: Pointer;  
begin  
   GetMem (p, 100); // leak!  
end;   
 
这段程序代码会配置 100 bytes ，然后这 100 bytes 的空间没有被释放，所以
算是泄漏了。如果我们透过 IDE来执行 LeakTest 项目程序，假设我们在第
一个按钮上点击一次，结束程序的时候，就会看到 IDE回报了如图 13.4的
错误讯息: 
_________________________________________________________________________  
 
 
 
 
 
  
 
另一个由程序产生的内存泄漏，是由于建立了一个 TButton 并且把它遗留
在内存而导致的，但这个对象包含了很多子元素，所以泄漏回报讯息变得
很复杂。同样的，我们能取得的关于泄漏本身的信息相当有限。  
 
这个程序也为全局指针配置了一些内存空间，这些空间也不会被释放掉，
但会把它注册成可预期的泄漏，所以不会得到系统回报警告讯息：  
procedure TFormLeakTest.FormCreate(Sender: TObject);  
begin  
   GetMem (GlobalPointer, 200);  筆記  
圖13.4 : 在
Windows 平台
上當程式結束
時，由記憶體管
理模組回報的記
憶體洩漏警告  
 
 386    RegisterExpectedMemoryLeak(GlobalPointer);  
end;  
 
再次强调，这个基本的内存泄漏回报机制，预设只有在 Windows 平台可以
使用，因为只有在 Windows 平台上，预设是使用 FastMM4 这个内存管理模
块的。  
 
  在完整版 FastMM4 上的缓冲区溢出  
 
这个主题相对比较进阶，且特别限定只有 Windo ws平台能用，
所以我只建议非常有经验的开发人员阅读这一节。  
 
如果我们想要对内存泄漏有更多的控制 (像是启用以 文件进行记录的功能 )，
调整配置策略以及使用 FastMM4 提供的内存检测功能，我们就需要下载完
整版。包含了 FastMM4.pas 跟其配置文件 FastMM4Options.inc 。 
 
我们稍后会需要编辑后者 (FastMM4Options.inc) 来调整设定，只需简单的把
一些设定批注掉，或者取消批注一些设定即可。依照惯例，我们只需要在
$DEFINE 指令前面加上一个 .就能够把该设定批注掉，以下是我们从 inc文
件里面拿前两行来当成范例 : 
{.$DEFINE Align16Bytes} // comment  
{$DEFINE UseCustomFixedSizeMoveRoutines} // active setting  
 
为了示范，我已经修改了下列相关的设定，在这里进行回报，让我们知道
有哪些可用的定义：  
{$DEFINE FullDebugMode}  
{$DEFINE LogErrorsToFile}  
{$DEFINE EnableMemoryLeakReporting}  
{$DEFINE HideExpect edLeaksRegisteredByPointer}  
{$DEFINE RequireDebuggerPresenceForLeakReporting}  
 
测试程序 (在FastMMCode 文件夹里面，里面也包含了我有用到的完整版的
FastMM4 ，方便读者不用再去另外下载 )启用了项目程序代码里面的客制化
版本内存管理模块，只需把它设定成第一个单元文件即可：  
program FastMMCode;  
uses  
  FastMM4 in 'FastMM4.pas',   
 387   Forms,  
  FastMMForm in  'FastMMForm.pas'; {Form1}  
 
我们也需要把 FastMM_FullDebugMode.dll 复制一份到测试程序的目录，这
样才能正常运作。测试程序会在缓冲区里面填入超过缓冲区大小的数据来
导致一个缓冲区溢出的情况，因为 Length(Caption) 大于提供的五个字符：  
procedure TForm1.Button2Click(Sender: TObject);  
var 
   pch1: PChar;  
begin  
   GetMem (pch1, 5);  
   GetWindowText (Handle, pch1, Length(Caption));  
   ShowMessage (pch1);  
   FreeMem (pch1);  
end;   
 
内存管理模块一开始会配置额外的空间，在每个内存区块的结尾会放特殊
的值，在释放每个内存区块的时候也就会检查这个特殊值。这也是为何我
们在呼叫 FreeMem 函式的时候会产生错误。当我们点击按钮 (在侦错模式
下)，我们会看到很长的一串错误讯息，这串讯息也会记录在以下这个 文件
里面 : 
FastMMCode_MemoryManager_EventLog.txt  
 
以下是缓冲区溢出错误的讯息内容，包含了当时对堆栈的追踪，以及配置
与释放的动作，再加上把当前的堆栈内存直接倒出的内容：  
FastMM has detected an error during a FreeMem operation. The block  
footer has been corrupted.  
The block size is: 5  
Stack trace of when this block was allocated (return addresses):  
40305E [System][ System.@GetMem]  
44091A [Controls][Controls.TControl.Click]  
44431B [Controls][Controls.TWinControl.WndProc]  
42D959 [StdCtrls][StdCtrls.TButtonControl.WndProc]  
44446C [Controls][Controls.DoControlMsg]  
44431B [Controls][Controls.TWinControl.WndProc]  
45498A [F orms][Forms.TCustomForm.WndProc]  
443A43 [Controls][Controls.TWinControl.MainWndProc]  
41F31A [Classes][Classes.StdWndProc]   
 388 76281A10 [GetMessageW]  
The block is currently used for an object of class: Unknown  
The allocation number is: 381  
Stack trace of when t he block was previously freed (return addresses):  
40307A [System][System.@FreeMem]  
42DB8A [StdCtrls][StdCtrls.TButton.CreateWnd]  
443863 [Controls][Controls.TWinControl.UpdateShowing]  
44392B [Controls][Controls.TWinControl.UpdateControlState]  
44431B [Contro ls][Controls.TWinControl.WndProc]  
45498A [Forms][Forms.TCustomForm.WndProc]  
44009F [Controls][Controls.TControl.Perform]  
43ECDF [Controls][Controls.TControl.SetVisible]  
45F770  
76743833 [BaseThreadInitThunk]  
The current stack trace leading to this error (re turn addresses):  
40307A [System][System.@FreeMem]  
44091A [Controls][Controls.TControl.Click]  
44431B [Controls][Controls.TWinControl.WndProc]  
42D959 [StdCtrls][StdCtrls.TButtonControl.WndProc]  
44446C [Controls][Controls.DoControlMsg]  
44431B [Controls][Contr ols.TWinControl.WndProc]  
45498A [Forms][Forms.TCustomForm.WndProc]  
443A43 [Controls][Controls.TWinControl.MainWndProc]  
41F31A [Classes][Classes.StdWndProc]  
76281A10 [GetMessageW]  
Current memory dump of 256 bytes starting at pointer address 133DEF8:  
46 61 7 3 74 4D 4D 43 6F 64 [... omitted...]  
 
这看上去并不算很直觉，但它应该已经提供了足够的信息供我们找出问题。
请注意，如果在内存管理模块里面没有这些设定，我们基本上是不会看到
任何错误的喔，程序也会继续执行下去。虽然我们可能会发现不定时出现
问题，也只会当缓冲区溢出的情形影响到了我们用来储存数据的内存区块，
错误才会发生。此时，我们会看到程序执行的结果很奇怪，而且很难找到
问题发生的原因。  
 
举例来说，我曾经看到过原本用来储存类别参考的内存，当中有一部分是
被初始化数据给覆写掉了。由于 这种内存数据损坏，类别会变成未被定义，
且每一次呼叫它的虚拟方法时，可能都会导致程序崩溃 …这很难去联想到 
 389 是在跟执行中的程序代码完全不同的区域对内存写入的动作有关。  
 
  在Windows 以外的平台的内存管理  
想象一下在 Object Pascal 里面具备 ARC功能的编译程序是怎么进行内存管
理的作业，就值得思考一下我们可以用的一些作法，来确定所有事情都在
控制下。在我们继续之前，很重要的一点，是在 Windows 以外的操作系统
中， Delphi并没有使用 FastMM4 内存管理模块，所以设定 ReportMemo - 
ryLeaksOnShutdown 这个全局选项， 想要在程序关闭的时候侦测是否发生内
存泄漏的情形是没用的，另一个理由是在行动装置上，关闭程序之后，程
序并不是直接就被关闭了，因为 app会在内存里面继续占用着，直到被用
户或操作系统强制移除，内存空间才会被释放掉。  
 
在OS X, iOS 跟Android平台上， Object Pascal RTL 会直接呼叫原生 libc函
式库的 malloc跟free函式。所以要在这些平台上监测内存的使用，就必须
靠额外的平台工具了。例如在 iOS跟OS X上面，我们得要用 Apple提供，
附在 Xcode里面的 Instruments 工具程序，它会全面性的监测我们在实体装
置上执行的应用程序。  
_________________________________________________________________________  
我们可以找到 Daniel Magin 跟Danel Wolf 提供的影片，当中非常仔细的以
Delphi的观点来介绍这个工具，影片网址 : http://www.danielmagin.de/blog  
/index.php/2013/03/apple -instruments -and-delphi -for-ios-movie/.  
 
  追踪每个类别的配置  
最后， Object Pascal 有一个特殊的功能可以用来追踪特定的类别，而不用对
整个内存全部追踪。事实上，对单一对象的内存配置会发生在 NewInstance
这个虚拟类别方法被呼叫的时候， 而会在 FreeInstance 虚拟方法被呼叫的时
候进行清除。这是我们可以对特定类别进行重载的虚拟方法来客制特定的
内存配置策略。  
 
好处是我们透过这个作法可以不用管建构函式 (因为一个类别可能有多个
建构函式 )与解构函式，从标准的对象初始化跟结束化程序 代码明确的把内
存追踪的程序代码分离出来。  
 
虽然这是一个比较极端的案例 (可能只有在一些比较大型的内存结构中才
值得这样做 )，我们可以重载这些方法，用以在建立后与释放后计算对象的
数量或特定类别的数量，计算使用中的实体，并在最后确认对象的数量是筆記   
 390 否如预期的变成 0了。  
 
撰写强健的应用程序  
在这一章里面，我们已经介绍了相当多的计数可以用来撰写强健的应用程
序，以及适当的管理内存配置与释放。  
 
在专心介绍内存管理这个章节的最后一节里，我决定要列出一些稍微进阶
的主题，为之前讨论过的内容进行一些延伸。即使使用 try-finally区块跟呼
叫解构函式之前已经介绍过了，但在本章强调的情境里面显然更为复杂，
并引入了更多程序语言的功能一起运作。  
 
这并不全然是进阶的一节，但所有 Object Pascal 开发人员应该真正掌握它，
才能写出强健的应用程序。只有上一节关于指针跟对象参考的部份算是真
的很进阶的主题，因为它深入到一个对象跟类别参考的内部存储器结构。  
 
  建构函式 , 解构函式 , 以及例外  
建构函式跟结构函式通常是在应用程序里面的问题来源。虚拟建构函式必
须一定要先呼叫基础类别的建构函式。反之，解构函式应该在最后才呼叫
基础类别的解构函 式。  
_________________________________________________________________________  
要遵循好的程序实务，我们应该要在我们写的每一个 Object Pascal 程序代
码的建构函式中记得要呼叫基础类别的建构函式，即使这并不是强迫性的，
而且额外的呼叫可能不一定有用 (像是呼叫 TObject.Create)  
 
在这一节里面，我想要特别强调在类别的建构函式出错时的状况，像是 : 
MyObj := TMyClass.Create;  
try 
   MyOb j.DoSomething;  
finally  
   MyObj.Free;  
end;   
 
 
如果这个对象被建立了，并被指派给 MyObj变量， finally区块就会处理释
放对象的动作，但如果 Create动作触发了例外，程序就不会进入 try-finally
区块了 (这是对的 !)。当一个建构函式触发例外时，此时对象只完成了部分筆記   
 391 初始化动作，对应的解构函式程序代码就会被自动执行。举例来说，如果
在建构函式中建立了两个子对象，它们就需要透过呼叫相对的解构函式加
以清除。然而这可能导致一个潜在的问题，如果在解构函式里面我们先假
设了所有子对象都有被完整初始化的话 ……  
 
从理论上来看，这并不容易理解，所以我们来看一个实际的程序代码当例
子。 SafeCode 这个范例项目包含了一个类别，在这个类别中有建构函式跟
解构函式，通常这两个函式都会正常运作，除非建构函式本身出了错：  
type  
   TUnsafeDesctructor = class  
   private  
      aList: TList;  
   public  
      constructor Create (positiveNumber: Integer);  
      destructor Destroy; override;  
end;  
constructor TUnsafeDesctructor.Create(positiveNumber: Integer);  
begin  
    inherited Create;  
    if positiveNumber <= 0 then  
      raise Exception.Create ('Not a positive number');  
    aList := TList.Create;  
end;  
destructor  TUnsafeDesctructor.Destroy;  
begin  
   aList.Clear;  
   aList.Free;  
   inherited;  
end;   
 
在这案例中的问题是对象已经完整建立时，解构函式就会正常运作，但如
果建构函式出了问题，当 aList还是 nil的时候，呼叫它的 Clear方法，就会
发生一个『违规存取』 (Access Violation) 的例外。  
 
这个解构函式比较安全的写法如下 : 
destructor TUnsafeDesctructor.Destroy;  
begin  
   if assigned (aList) then   
 392      aList.Clear;  
   aList.Free;   
   inherited;  
end;  
 
而这个例子的寓意，是我们永远不能在解构函式中假设对应的建构函式有
把所有子对象完整的建立完成。我们可以在类别中的任何一个方法里面做
这个前提假设，但就是不能在解构函式里面这样假设。  
 
  巢状Finally区块 
Finally区块是让我们的程序代码保持安全状态的技术中最重要，也最常见
的。我也不觉得这是进阶的主题，但我们有把 finally在该用的地方都用上
吗?且我们们是否都在特定的案例中适当的使用了 finally区块呢 ?例如巢状
处理，或者我们是否有把多个完成程序代码组合在一个 finally区块里面呢 ?
这样可不是完美程序代码会做的事 : 
procedure TForm1.btnTryFClick(Sender: TObject);  
var 
    a1, a2: TAClass;  
begin  
    a1 := TAClass.Create;  
    a2 := TAClass.Create;  
    try 
       a1.whatever := 'one '; 
       a2.whatever := 'two';  
    finally  
         a2.Free;  
         a1.Free;  
    end;  
end;   
 
以下才是比较保险的写法 (也是节录自 SafeCode 范例项目 ): 
procedure TForm1.btnTryFClick(Sender: TObject);  
var 
   a1, a2: TAClass;  
begin  
   a1 := TAClass.Create;  
   try  
 393       a2 := TAClas s.Create;  
      try 
        a1.whatever := 'one';  
        a2.whatever := 'two';  
      finally  
        a2.Free;  
      end;  
    finally  
       a1.Free;  
    end;   
end;   
 
  动态型别检查  
在型别之间进行动态的转换是常见的处理，且类别型别也可能是另一种错
误的发生来源。特别是如果我们没有使用 is或as运算符号，直接硬着进行
型别转换的时候。事实上，每一 个直接型别转换的动作就是潜在的原始码
错误来源 (除非进行转换之前有先做过 is检查 )。 
 
从对象到指针的型别转换，转换成或转换自类别参考，从对象到接口，转
换自字符串或者转换成字符串都是极度具有潜在危险性的，但在特别的情
形下却难以避免。举例来说，我们可能希望把对象参考存放在一个组件的
Tag属性里。另一个例子则是当我们把对象存放在一个指针列表里面，一个
旧型的 TList(并不是型别安全的泛型列表，我们在下一章里面会介绍 )。这
是一个相当笨的范例：  
procedure TForm1.btnCastClick(Sender : TObject);  
var 
   list: TList;  
begin  
  list := TList.Create;  
  try 
    list.Add(Pointer(Sender));  
    list.Add(Pointer (23422));  
    // direct cast  
    TButton(list[0]).Caption := 'ouch';  
    TButton(list[1]).Caption := 'ouch';  
   finally  
      list.Free;   
 394    end;   
end;   
 
执行上面的程序代码通常会触发违规存取。  
_________________________________________________________________________  
我写成通用的情形，因为当我们随机存取内存的时候，我们永远没有机会
知道实际的效果。 有时候程序会简单的重写内存， 不会导致立即的错误 ……
但我们接下来会很难搞清楚为什么其他数据会被破坏。  
 
我们应该在任何时候都要避免类似的情形，但如果我们突然没有其他的替
代方案， 那要怎么修正这份程序代码 ?比较直觉 的方法是使用 as这种安全型
别转换，或者透过 is做型别检测，像以下的程序片段所做的 : 
// as cast  
(TObject(list[0]) as TButton).Caption := 'ouch';  
(TObject(list[1]) as TButton).Caption := 'ouch';  
 
// is cast  
if TObject(list[0]) is TButton then  
  TButton(list[0]).Caption := 'ouch';  
if TObject(list[1])  is TButton then  
  TButton(list[1]).Caption := 'ouch';  
 
然而，这并不是解决方法，我们还是会继续发生 违规存取 。问题在于 is跟
as最终还是会呼叫 TObject.InheritsFrom ，这是另一个动作，会被执行好几
次。  
 
那解决方法呢 ?实际的解决方法是避免类似的情形一开始就发生 (这种写法
真的没什么意义 )，使用 TObjectList 或者其他的安全机制 (我们在下一章会
介绍泛型的容器类别 )。如果我们真的需要低阶对系统进行处理，像是跟指
标深入处理，我们可以试着检查 一个特定的『数值』是否是一个对象的参
考。不过，这个动作并不直觉。它也有趣味的一面，这也是我拿来为范例
说项的点，要为大家说明一个对象内部的结构，当然也适用在类别参考啦。  
 
 
 
  这个指针是对象参考吗 ? 
这一小节说明了对象跟类别参考的内部结构， 并超越了本书绝筆記   
 395 大部分的章节所涉及的程度。 它可以提供一些有趣的内部观点
给更多专业的读者，所以我决定保留这些内容，这些是过去我
曾为内存管理所写的一篇进阶的文章的内容。 也要留意到，以
下的实作有部分是只能在 Windows 上面使用的，尤其是内存
检测的部份。  
 
有些时候，我们会很常 使用指标 (指标只是一个数值，这个数值代表储存某
些数据的物理内存地址 )。这些指针可能实际上是某些对象的参考，我们通
常会知道指标指向的是什么，以及要把它们拿来做什么。但每当我们要做
低阶的型别转换，我们可能随时位于搞砸整个程序的边缘。有些技术可以
让这样的指标管理稍微安全一点，但不是百分之百保证安全。  
 
我们可能要使用指标之前，考虑这个作法的出发点会是『它是否是一个合
法的指标』 ?Assigned 函式只会检测一个指标是否为 nil，而在这样的情境里
面并没有实质帮助。然而，很少人知道在 Object Pascal 里面有个名 为
FindHInstance 的函式 (在System单元文件里面，只有 Windows 平台可用 )，
会回传包含该函式的参数对象在 heap当中的基础地址，如果该指针所指的
是一个不合法的分页，就会回传 0(避免不常发生，但真的很难侦测的内存
页面错误问题发生 )。如果我们随机抓了一个数字，想要用这个数字当成内
存地址来取得内存里面的数据，绝大多数的情形都不会抓到合法的内存的。  
 
这是个很好的开始，但我们可以做的更好，因为如果这个值是一个字符串
参考或任何有效的指针，而不是对象参考，就没有任何帮助。现在我们要
怎么知道一个指针是否 是一个对象的参考呢 ? 我已经提出以下的实证。每
个对象为首的 4个bytes是其类别的指标。 如果我们想得知一个类别参考的
内部数据结构，它是位于类别参考的 vmtSelfPtr 地址，当中是一个只到自
己的指标。我们可以透过图 13.5来表示：  
_________________________________________________________________________  
 
 
 
 
 
 
换句话说，从类别参考指针的 vmtSelfPtr 位回溯到内存地址 (这是在内存中
向前寻找，是在比较前面的地址 )，我们应该 可以找到相同类别参考的指标
才对。而且在类别参考的内部数据结构中，我们可以取得实体大小的信息
(在vmtInstacneSize 的位置 )以及看到是否有合理的数字。 以下是实际的程序圖13.5 : 物件與
類別參考的內部
結構表示  
 
 396 代码 : 
function IsPointerToObject (Address: Pointer): Boolean;  
var 
  classPointer, vmtPointer: PChar;  
  instsize: Integer;  
begin  
  Result := False;  
  if (FindHInstance (Add ress) > 0) then  
  begin  
    vmtpointer := pchar(Address^);  
    classpointer := vmtpointer + vmtSelfPtr;  
    if Assigned (vmtpointer) and  
      (FindHInstance (vmtpointer) > 0) then  
    begin  
      instsize := (Pinteger(  
        vmtpointer + vmtInstanceSize ))^; 
      // check self pointer and "reasonable" instance size  
      if (pointer(pointer(classpointer)^) =  
           pointer(vmtpointer)) and  
          (instsize > 0) and (instsize < 10000) then  
        Result := True;  
    end;  
  end;   
end;   
 
透过这个函式，在前一个 SafeCode 范例项目，我们可以在进行安全型别转
换前加上一个指针 -到-对象的检查：  
if IsPointerToObject (list[0]) then  
  (TObject(list[0]) as TButton).Caption := 'ouch';  
if IsPointerToObject (list[1]) then  
  (TObject(list[1]) as TButton).Caption := 'ouch';  
 
相同的概念也可以直接应用在类别参考上，也可以用来实作类别参考之间
的安全型别转 换。而且，最好能够一开始就写好安全、明白的程序代码，
试着避免类似的问题，但如果我们无法避免，这个函式就有机会派上用场
了。无论如何，这一节的用意应该是在对于这些系统数据结构的内容多做
一些说明。  
  
 397  
  
 398 第三部 : 进阶功能  
 
我们已经深入研究了 Object Pascal 的基础功能，以及面向对象程序语言的
范例，接下来我们可以来看看 Object Pascal 最新以及更进阶的功能了。泛
型(Generics) 、匿名方法 (Anonymous methods) ，以及镜射 (reflection) 都让我
们使用最新的技术跟更明确 的方法来延伸面向对象程序。  
 
事实上，这些更进阶的程序语言功能，让开发人员在写程序上局限在特定
的方法上，但透过更多型别与程序的抽象化、允许在程序代码里面使用镜
射等更多动态的功能，则更能让我们发挥出 Object Pascal 全面的潜力。  
 
这一节的最后也会透过介绍核心的运行时间函式库的内容，来扩展这些程
序语言的功能，这些都是 Object Pascal 开发模式的核心，也使得程序语言
跟函式库本身的界线更为模糊。我们也会检视，例如我们在前面的篇幅里
提到的 TObject，它是所有我们撰写的类别的最源头 :它的影响至深至 远，所
有函式库的实作细节都与之相关。  
 
第三部的章节列表 : 
第十四章 : 泛型  
第十五章 : 匿名方法  
第十六章 : 镜射与属性  
第十七章 : TObject 类别  
第十八章 : 执行时期函式库   
 399 14:泛型 
 
Object Pascal 所提供的强型别检查对于提升程序代码的正确性是很有效的，
这也是我在本书中不断提到的。强型别的检查有时候也很烦，就像有时候
我们想要写一个程序，让这个程序可以处理不同数据型别或类别。这个议
题已经被 Object Pascal 纳入成为功能之一，就像 C#, Java 这些相似的语言
一样，我们称之为 泛型 (Generics) 。 
 
泛型的概念，或者用 C++的名词来说，叫做类别样板 (template classes) 。我
在1994年所著，关于 C++的书里面有写道 : 
我们可以宣告一个类别，其中的一个或多个数据成员不特别指定使
用哪种型别：这个型别的指定可以延迟到当我们需要定义该类别的
变量时才来决定。我们在定义函式的时候也可以用相似的作法，不
在撰写的函式的时候定义一个或多个参数的型别，直到该函式要被
呼叫的时候才来指定。  
_______________________________________________ __________________________  
这本书的书名是 ”Borladn C++ 4.0 Object -Oriented Programming” ，由 Marco 
Cantu和Steve Tendon 合着，在 1990年代前期出版。  
 
通用的键 -值对 (Key -Value Pairs)  
本章的第一个范例就用一个很常见的类别，我实作了一个键 -值对的数据结
构。以下第一个程序片段，就是用传统的写法来建立这个数据结构，透过
一个对象来储存数据的数值：  
type  
   TKeyV alue = class  
   private  
      FKey: string;  
      FV alue: TObject;  
      procedure SetKey(const V alue: string);  
      procedure SetV alue(const V alue: TObject);  
   public  
      property Key: string read FKey write SetKey;   
      property V alue: TObject read FV alue write SetV alue;   
   end;   筆記   
 400 要使用这个类别，我们可以建立一件对象，设定它的键与值，然后使用它，
就像下列的程序代码，节录自 KeyValueClassic 范例项目的主窗体中的几个
方法：  
// FormCreate  
kv := TKeyV alue.Create;  
 
// Button1Click  
kv.Key := 'mykey';  
kv.V alue := Sender;  
 
// Button2Click  
kv.V alue := self; // the form  
 
// Button3Click   
ShowMessage('[' + kv.Key +',' + kv.V alue.ClassName + ']');   
 
要是我们需要一个类似的类别，储存的是整数，而不是对象呢 ?好吧，我们
也可以自己把整数作强制型别转换 (这么做，出错的风险很高的 )，或者建立
一个新的类别，储存字符串键以及整数值。或许直接剪贴程序代码，然后
修改里面的一部分也是种解决方法，最后我们就会有两段程序代码看起来
长得很像，这样做，我们就抵触了良好程序设计的原则之一，而且我们以
后如果发现程序代码里面有问题，就得同时改两次程序代码，如果复制三
次，就要改三次，如果复制 20次呢…… 那就烦死了。  
 
泛型让我们可以对上例中的值的定义变得比较有弹性，而只要写一个泛型
类别即可。一旦我们对键 -值泛型类别进行了初始化，它就变成了特定的类
别，直接跟特定的型别进行连结了。所以我们可以透过同样的作法，在我
们的应用程序里面让这个类别宣告分别跟两种、三种，甚至 20种型别进行
连结，但类别的程序代码还是同一份，只是在变量或者属性宣告的时候，
指定这个类别要跟哪一种数据型别进行链接。这样就不会在执行时期产生
多余的动作了。我们接着继续做吧，开始定义一个泛型类别：  
type  
   TKeyV alue<T> = class  
   private  
      FKey: string;  
      FV alue: T;  
      procedure SetKey(const V alue: string);  
      procedure SetV alue(const V alue: T);   
 401   public  
     property Key: string read FKey write SetKey;   
     property V alue: T read FV alue wri te SetV alue;   
  end;   
 
在上述的类别定义里，有一个尚未明确定义的型别，以字母 T来代表。字
母T在很多语言中都被使用来当做泛型类别中的符号，但我们可以在程序
代码中用任何我们喜欢的字眼来代表泛型的类别或型别。 使用 T这个字母，
是为了增加程序的可读性，泛型类别只是用这个符号来表示这个符号出现
的地方，未来会以参数指定的型别来进行替换。如果类别中要进行泛型处
理的地方有很多个，我们在实务上就会用它的角色来为这个代号进行命名，
不用多个字母来代表 (T, U, V)，这种方法是早期 C++里面的写法。  
_________________________________________________________________________  
T已经是通用的不成文写法，因为 C++语言在 1990年代前期提出样板
(template) 这个概念的时候，就直接以 T来表示样板。当时作者是要用 T来
表示样板 (template) 还是型别 (Type)，目前已不可考。  
 
泛型类别 TKeyValue<T> 使用了尚未明确定义的型别作为它储存的两个数
据字段之一、属性的值，以及设定方法 (setter)的参数。方法的程序代码则
很平常，但 要注意到这当中也是使用了泛型型别，它们的定义包含了该类
别的完整名称，包含泛型型别：  
procedure TKeyV alue<T>.SetKey(const V alue: string);   
begin   
   FKey := V alue;  
end;  
procedure TKeyV alue<T>.SetV alue(const V alue: T);   
begin   
   FV alue := V alue;  
end;  
 
然而要使用这个类别时，我们就得完整的写出真正的型别了，必须提供实
际的数据型别作为泛型型别。例如我 们可以宣告一个键 -值对象把按钮作为
类别中储存的值，可以这样写 : 
kv: TKeyV alue<TButton>;  
 
在建立实体的时候，也需要写出完整的名字，因为这已经是确切的型别了
(泛型型别中尚未实体化的型别名称看起来则像是一个型别建构机制 )。 
 筆記   
 402 在键 -值对当中使用尚未明确定义的型别来定义值的字段，会使得程序代码
更能有弹性， 我们现在只用了 TButton来当做储存的值的字段， 当然 TButton
的所有衍生类别对象也都可以存在这里面，我们也可以在解析出值字段的
对象之后， 使用该对象的各种方法。 以下的程序片段节录自 KeyValueGeneric
范例项目的主窗体：  
// FormCreate   
kv := TKeyV alue<TButton>.Create;   
 
// Button1Click   
kv.Key := 'mykey';   
kv.V alue := Sender as TButton;   
 
// Button2Click   
kv.V alue := Sender as TButton; // was "self"   
// Button3Click   
ShowMessage ('[' + kv.Key + ',' +  kv.V alue.Name + ']');   
 
在前一版的程序代码里面，要指派泛型对象的时候，我们可以指派一个按
钮或者窗体，但现在只能储存按钮了，这也适用了编译程序的强型别规则。
但在泛型类别里面，输出字符串 kv.value.ClassName 则可以适用于所有型
别， 因为组件的 Name或者 TButton类别的任何方法或属性我们都可以在程
序代码中使用。  
 
当然我们也可以稍微改动一下原始程序中宣告键 -值对的定义：  
kvo: TKeyV alue<TObject>  
 
这样修改后，我们就可以把任何对象当成值的字段加以储 存了。然而，我
们就不能对解析出来的对象作太多动作，除非我们先把该对象转型成特定
的型别。为了找到一个比较好的平衡点，我们可能会想要在特定的按钮跟
任何对象之间找个介于中间的型别，例如说让储存的值只允许视觉组件 : 
kvc: TKeyV alue<TComponent>;  
 
对应的程序代码在 KeyValueGeneric 范例项目里面也有。最后，我们也可以
建立一个储存一般数据的键 -值对类别的实体，不让它储存任何对象，而是
储存整数值 : 
var 
   kvi: TKeyV alue<Integer>;  
begin   
 403    kvi := TKeyV alue<Integer>.Create;   
   try  
     kvi.Key := 'object';  
     kvi.V alue := 100;  
     kvi.V alue := Left;  
     ShowMessage ('[' + kvi.Key + ',' +  
         IntToStr (kvi.V alue) + ']');   
   finally  
         kvi.Free;  
   end;   
 
  泛型的型别规则  
当我们宣告了一个泛型型别 的实体，这个型别就固定下来了，同时在后续
的所有动作中，就会被编译程序视为确定型别，所以如果我们有个泛型类
别是像这样的 : 
type  
   TSimpleGeneric<T> = class   
      V alue: T;  
   end;  
 
当我们为这个类型声明特定的对象时， 我们在 Value字段就不能指派跟宣告
时不同型别的数据了。以下面两个对象为例，以下的部份指派就是不合法
的(以下节录自 TypeCompRules 范例项目 ): 
var  
   sg1: TSimpleGeneric<string>;   
   sg2: TSimpleGeneric<Integer>;   
begin  
   sg1 := TSimpleGeneric<string>.Create;   
   sg2 := TSimpleGeneric<Integer>.Create;   
 
   sg1.V alue := 'foo';   
   sg1.V alue := 10; // Error   
   // E2010 Incompatible types: 'string' and 'Integer'   
 
   sg2.V alue := 'foo' ; // Error   
   // E2010 Incompatible types: 'Integer' and 'string'   
   sg2.V alue := 10;    
 404 一旦我们在泛型的宣告中确定了特定的型别，编译程序就已经确定了要检
查的型别，我们的程序代码就必须要遵循 Object Pascal 的强型别规则了。
型别检查也会把泛型对象当成一个特殊的型别。当我们把泛型类别指定了
特定的型别，我们就不能把指定另一个型别的泛型类别对象指派到不同泛
型类别的变量了。只看文字说明很容易昏头，还是看一下程序代码，比较
容易理解 : 
sg1 := TSimpleGeneric<Integer>.Create; // Error   
// E2010 Incompatible types:   
// 'TSimpleGeneric<System.string>'   
// and 'TSimpleGeneric<System.Integer>'   
 
我们接下来会在 ”泛型型别兼容性规则 ”这一节里面用明确的案例，指出型
别兼容性规则是以结构检查，而不是以型别名称检查。我们不能在泛型型
别已经确认了特定型别之后，指派一个不同的、不相容的型别给 一个泛型
型别过去。  
 
Object Pascal 里面的泛型  
在前一个范例里，我们已经看过了如何在 Object Pascal 里面定义、使用泛
型型别。我决定在深入到技术概念前，先用范例来介绍这个功能。因为泛
型的技术概念相当复杂，也相当重要。从程序语言的观点看完泛型之后，
我们再回头多看几个范例，包含了定义、使用泛型容器类别，这是 Object 
Pascal里面主要使用这个技术的地方之一。  
 
我们已经介绍过，当我们定义一个类别的时候，可以加入额外的参数，使
用尖括号把特定的型别括起来即可 : 
type  
   TMyCla ss<T> = class  
      ...  
   end;   
 
泛型型别可以用来当做数据字段的型别 (就像我们在前一个例子里面介绍
的)、当做属性的型别、或者作为参数的型别，甚至是一个函式的回传型别，
还可以用在更多地方。请注意，对一个区域字段 (或者数组 )使用这个型别并
不是一种义务，有些情境下，泛型型别只用在作为回传值、参数，不能用
在类别的宣告上，但可以用来定义类别的某些方法。  
 
这种形式的延伸或泛型型别的宣告，不只是能对类别使用，也能用在记录 
 405 上面 (我们在第五章介绍过，记录也可以有方法、属性、重载的运算方法 )。
泛型类别也可以有多个参数化的型别，我们用下面的程序代码作范例，让
大家可以了解怎么在泛型的宣告中用上两个型别当成参数，一个当成方法
的参数，另一个则是回传值的型别 : 
type  
   TPWGeneric<TInput,TReturn> = class   
   public   
      function AnyFunction (V alue: TInput): TReturn;   
   end;   
 
Object Pascal 里面对泛型的实作，跟其他静态程序语言一样，并不是基于执
行时期的支持。这个功能是由 编译程序跟链接程序来处理的，在运行时间
的机制几乎完全没有作什么事。跟虚拟函式的呼叫不同，虚拟函式是在执
行时期进行绑定，而泛型类别的方法则是在我们定义出完整的泛型型别实
体时就被建立了，而且是在编译时建立的！我们将会看到这个功能可能的
缺陷，但正面来看这个问题，它让我们知道泛型类别比一般类别的效率来
的好，甚至连执行时期的检查所需的动作都省下了。在我们深入看到这些
问题前，我们先来看些很明确的规则，这些规则打破了传统 Pascal语言的
型别兼容规则。  
 
  泛型型别兼容性规则  
在传统的 Pascal语言跟 Object P ascal的核心型别兼容性规则都是基于型别
名称是否一致。换句话说，两个变量的型别如果兼容，这两个型别的名称
一定是一样的，不管两个型别里面实际上是怎么储存数据或定义方法的。  
 
以下是一个静态数组间型别不兼容的传统例子 (节录自 TypeCompRules 范例
项目 ): 
type  
   TArrayOf10 = array [1..10] of Integer;   
 
procedure TForm30.Button1Click(Sender: TObject);   
var  
   array1: TArrayOf1 0;  
   array2: TArrayOf10   
   array3, array4: array [1..10] of Integer;   
begin  
   array1 := array2;    
 406    array2 := array3; // Error   
   // E2010 Incompatible types: 'TArrayOf10' and 'Array'   
 
   array3 := array4;   
   array4 := array1; // Error   
   // E2010  Incompatible types: 'Array' and 'TArrayOf10'   
end;   
 
我们可以从上面的程序代码看到，四个数组在结构上是完全相同的。然而
编译程序只会让我们对型别兼容的数组进行指派。兼容的规则是必须型别
名称完全相同 (两个变量的型别都是 TArrayof10) ， 或者根本就是同一个型别
(array3, array4 直接是宣告在同一行变量的宣告上 )。 
 
这个型别兼容性规则是很有局限性的例外，就像衍生类别的相关性。这个
规则的另一个例外，而且是很明显的例外，就是泛型型别的型别兼容性，
这个情境也只会发生在编译程序内部使用上，编译程序会自行决定是否要
位这个泛型型别建立一个新的内部型别，套用在该型别所有出现的地方。  
 
新规则会界定泛型型别如果使用的是同样的泛别类别，且在定义时使用同
样的实体型别，就视为相同的型别，不管在定义时，型别的名称是否相同。
换句话说，泛型型别实体的全名会是泛型型别跟实体型别的组合。  
 
在以下的范例中，四个变量就是完全型别兼容的：  
type  
   TGenericArray<T> = class   
      anArray: array [1..10] of T;   
   end;   
 
   TIntGenericArray = TGenericArray<Integer>;   
 
procedure TForm30.Button2Click(Sender: TObject);   
var  
   array1: TIntGenericArray;   
   array2: TIntGenericArray;   
   array3, array4: TGenericArray<Integer>;   
begin  
   array1 := TIntGenericArray.Cre ate;  
   array2 := array1;    
 407    array3 := array2;   
   array4 := array3;   
   array1 := array4;   
end;   
 
  标准类别的泛型方法  
使用泛型型别来定义类别是最常见的情境，泛型型别也可以用在非泛型的
类别中。换句话说，一般的类别也可以有泛型方法。在这个情形下，我们
不用在泛型符号出现的位置指定特定的型别，等到呼叫时再处理即可。以
下就是一个简单的泛型方法的例子，节录自 GenericMethod 范例项目 : 
type  
   TGenericFunction = class   
   public   
     function WithParam <T> (t1: T): string;   
   end;   
_________________________________________________________________________  
当我第一次撰写上面这个程序代码的时候，或许是怀念以前 C++的日子吧，
我把参数写成了 (t: T)。不用特别说， Object Pascal 的语法是不分大小写的，
在所有不分字母大小写的 程序语言里面，这样的写法都是不合法的。编译
程序会指出上面两个 t是无法辨识的 ……  
 
我们没办法在类似的类别方法内部中作太多处理 (至少在我们使用特定限
制之前， 我们会在下一章里面介绍 )， 所以我用特殊的泛型函式 (稍后会介绍 )
写了一些程序代码来把这个型别转换成字符串，我们来看一下 : 
function TGenericFunction.WithParam<T>(t1: T): string;   
begin   
   Result := GetTypeName (TypeInfo (T));   
end;   
 
我们可以看到这 个方法没有使用任何实际的值当做参数，只要求一些型别
信息。在还不知道 t1的型别之前，让写这段程序的时候相对变得很复杂。  
 
我们可以用以下的参数来呼叫这个『全局泛型函式』 ，可以使用的版本可多
了: 
var 
   gf: TGenericFunction;  
begin  筆記   
 408    gf := TGenericFunction.Create;  
   try 
      Show (gf.WithParam<string>('foo'));   
      Show (gf.WithParam<Integer> (122));   
      Show (gf.WithParam('hello'));   
      Show (gf.WithParam (122));   
      Show (gf.WithParam(Button1));   
      Show (gf.WithParam<TObject>(Button1));   
   finally   
         gf.Free;  
   end;  
 
以上所有呼叫这个函式的写法都是正确的，参数化的型别在这些呼叫的程
序代码里面是暗中传递的。注意到泛型型别是被明确指定的，但参 数的型
别并没有被指定，所以我们会看到以下的执行结果 : 
string  
Integer  
string  
ShortInt  
TButton  
TObject  
 
如果我们在呼叫这个方法的时候没有在尖括号中指定型别，实际的型别就
会从该参数的型别来指定。如果我们用一个型别、一个参数来呼叫这个方
法，参数的型别就必须跟泛型型别的宣告一致。所以以下三行就无法被编
译了 : 
Show (gf.WithParam<Integer>('foo'));   
Show (gf.WithParam<string> (122));   
Show (g f.WithParam<TButton>(self));   
 
  泛型型别实体化  
请注意，这一节的主题是比较进阶的，我们会介绍泛型的内部运
作机制跟它的潜在优化方式。如果您对泛型已经有研究过，第二
次读到这一节，也会对您很有帮助。  
 
因为一些优化的例外，每次我们在为泛型型别实体化的时候，不管是泛型
方法或是泛型类别，编译程序都会产生一个新的型别。这个新的型别在同 
 409 一个泛型型别的不同实体 (或者是同一个方法的不同版本 )之间是不会共享
程序代码的。  
 
我们来看一个范例 (节录自 GenericCodeGen 范例项目 )。在这个程 序中定义
了一个泛型类别，定义如下 : 
type  
   TSampleClass <T> = class   
   private   
     data: T;  
   public  
     procedure One;  
     function ReadT: T;  
     procedure SetT (value: T);  
   end;   
 
这三个方法的实作程序代码如下 (请注意到 One方法是绝对跟泛型型别独立
的): 
procedure TSampleClass<T>.One;   
begin   
   Form30.Show ('OneT');  
end;  
function TSampleClass<T>.ReadT: T;   
begin   
   Result := data;  
end;  
procedure TSampleClass<T>.SetT(value: T);   
begin   
   data := value;  
end;  
 
这个主程序当中使用了泛型型别要把它的方法被实体化时 (这个动作会由
编译程序来处理 )内存内的地址厘清。以下是它的程序代码 : 
procedure TForm30.Button1Clic k(Sender: TObject);   
var  
   t1: TSampleClass<Integer>;  
   t2: TSampleClass<string>;  
begin  
   t1 := TSampleClass<Integer>.Create;    
 410    t1.SetT (10);   
   t1.One;   
 
   t2 := TSampleClass<string>.Create;  
   t2.SetT ('hello');   
   t2.One;   
 
   Show ('t1.SetT: '  +  
      IntToHex (PInteger(@TSampleClass<Integer>.SetT)^, 8));   
   Show ('t2.SetT: ' +   
      IntToHex (PInteger(@TSampleClass<string>.SetT)^, 8));   
   Show ('t1.One: ' +   
      IntToHex (PInteger(@TSampleClass<Integer>.One)^, 8));   
   Show ('t2.One: ' +   
      IntToHex (PInteger(@TSampleClass<string>.One)^, 8));   
end;   
 
执行结果如下 (实际的数值每次都不会一样 ): 
t1.SetT: C3045089  
t2.SetT: 51EC8B55  
t1.One: 4657F0BA  
t2.One: 46581CBA  
 
如我所预期的，编译程序不只在内存里面为每一种数据型别的 SetT方法都
建立了不同的版本，就连 One方法也是如此，尽管事实上各版本的 One方
法都是一模一样的。  
 
不仅如此，如果我们重复宣告了一 个完全相同的泛型型别，我们也会得到
另一组新的实作函式。同样的，一个泛型型别的相同实作型别，在不同的
单元文件里面被使用时，也会强迫编译程序一再产生相同的程序代码，而
可能会导致建立出的执行档明显变得很大。为了这个原因，如果我们要建
立一个内含很多个方法的泛型类别，而这些方法跟泛型的型别没有什么关
系的话，我会建议把这些方法定义在一个非泛型的类别里面，然后以这个
非泛型的类别衍生一个需要使用到泛型型别的泛型类别：透过这个方法来
实作，基础类别的方法就只会被编译程序产出一次，执行档也就不会太大
了。  
____________ _____________________________________________________________  
在目前的编译程序、链接程序、以及低阶 RTL里面有些功能，用来缩减因
筆記   
 411 为使用泛型而导致 文件变大的状况，这些状况刚刚我们有提到过了。目前
这些功能可以从一些网络上的文章阅读中稍微了解一下 :http://delphis  
orcery.blogspot.it/2014/10/new -language -feature -in-xe7.html  
 
  泛型函式  
目前我们在看泛型型别定义的最大问题，就是 我们能对泛型类别型别的元
素所做的非常少。我们可以用两个科技来降低这个限制。第一项就是使用
在RTL里面特别用来支持泛型的特殊函式。第二项 (也更有效 )则是在泛型
类别可以使用的类别上面作限制。  
 
这一节我们将聚焦在第一项上面，下一节再来介绍使用上的限制。我们刚
提到过，在 RTL里面有一些函式是可以用来对泛型型别定义中的参数化型
别进行处理的 : 
 
 Default(T) 是一个和泛型功能一起出现的新函式，如果我们传入了任何
一个非泛型的型别，它会回传空值，或 0，或 null，回传值可以是 0、
空字符串、 nil等等。以 0清除过的内 存对同一种型别的全局变量也会
有一样的值 (跟局部变量不同，事实上，全局变量会被编译程序以 0作
初始化 ) 
 TypeInfo(T) 回传目前这个泛型型态在运行时间的指针， 我们会在第十六
章里面介绍更多关于型别信息的相关数据。  
 SizeOf(T) 会以 Byte数回传该型别里面所使用的内存大小 (如果 T是对象
或是字符串的话，这个回传值就是每个内存地址的大小，在 32位系统
中会回传 4 bytes, 64 位则回传 8 bytes)。 
 IsManagedType(T) 会告诉我们该型别在内存中是否是受管理的，如果是
字符串或者动态数组的话， 回传值就会是 true. 
 HasWeakRef(T) ，这个函式是跟支持 ARC的编译程序相关的，会回传一
个内存参考是否为弱参考，需要特定的内存管理支持。  
 GetTypeKind(T) ：是让我们能够从型别信息中取得型别种类的快捷方
式，这个回传值比 TypeInfo 所回传的型别定义来的更高阶。  
_________________________________________________________________________  
以上这些方法所回传的，都是编译程序处理过的常数，而不是在运行时间
中实际呼叫什 么函式所响应的值。重要的不是这些处理很快，而是让编译
程序跟链接程序可以对产出的程序代码进行优化，把没有使用到的程序代
码移除。如果我们打算用这些函式的回传值来进行判断，编译程序会发现
判断式 (if..else)其中的一段程序代码会被执行，而会自动移除掉没有被使用
到的那一段。当相同的泛型方法被指定不同的型别，在编译时就会使用不筆記   
 412 同的判断状况，但要记得，程序代码都会先被产生，在优化的时候才有这
些处理。  
在GenericTypeFunc 范例项目中有一个泛型类别， 会显示三个泛型型别函式 : 
type  
   TSample Class <T> = class   
   private   
      data: T;  
   public  
      procedure Zero;  
      function GetDataSize: Integer;  
      function GetDataName: string;  
   end;   
 
function TSampleClass<T>.GetDataSize: Integer;   
begin   
   Result := SizeOf (T);  
end;  
function T SampleClass<T>.GetDataName: string;   
begin   
   Result := GetTypeName (TypeInfo (T));   
end;   
procedure TSampleClass<T>.Zero;   
begin   
   data := Default (T);  
end;  
 
在GetDataName 方法中，我使用了 GetTypeName 函式 (宣告在 TypeInfo 单
元文件里面 )，而不是直接存取数据结构，因为这样会从储存型别名称的已
编码字符串进行适当的转换  
 
因为有上述的宣告，我们可以把下列的测试程序代码进行编译，它会重复
三次，使用三个不同的泛型型别实体。我就省略了重复的程序代码，只显
示用来存取 data字段的程序，它们会依照实际型别来进行内容变更：  
var 
   t1: TSampleClass<Integer>;  
   t2: TSampleClass<string>;  
   t3: TSampleClass<double>;  
begin   
 413    t1 := TSampleClass<Integer>.Create;   
   t1.Zero; Show ('TS ampleClass<Integer>');   
   Show ('data: ' + IntToStr (t1.data));   
   Show ('type: ' + t1.GetDataName);   
   Show ('size: ' + IntToStr (t1.GetDataSize));   
 
   t2 := TSampleClass<string>.Create;   
   ...  
   Show ('data: ' + t2.data);   
 
   t3 := TSampleClass<d ouble>.Create;   
   ...  
   Show ('data: ' + FloatToStr (t3.data));   
 
执行上面这段程序代码 (节录自 GenericTypeFunc 范例项目 )，结果如下 : 
TSampleClass<Integer>  
data: 0  
type: Integer  
size: 4  
TSampleClass<string>  
data:  
type: string  
size: 4  
TSampleClass<double>  
data: 0  
type: Double  
size: 8 
 
请注意，我们也可以对指定的型别使用泛型型别函式，在泛型类别的内容
之外，例如可以这样写 : 
var 
   I: Integer;  
   s: string;  
begin  
   I := Default (Integer);  
   Show ('Default Integer': + IntToStr (I));  
 
   s := Default (string);    
 414    Show ('Default String': + s);   
   Show ('TypeInfo String': +   
     GetTypeName (TypeInfo (string));   
 
结果很直觉，当然就是 : 
Default Integer: 0  
Default String:  
TypeInfo String: string  
_________________________________________________________________________  
我们不能直接对变量进行 TypeInfo 呼叫，例如上面的 TypeInfo(s) ，这个呼
叫的参数只能是一个型别。  
 
  泛型类别的类别建构函式  
有个很有趣的例子，就是为泛型类别定义一个类别建构函式。事实上，这
样的建构函式是由编译程序所建立，并由每一个泛型类别的实体所呼叫的，
也就是说，每一个实际的型别被定义时，都使用了泛型样板。这一点就相
当有趣了，因为这会让我们的程序在不使用类别建构函式来建立每个泛型
类别实体的时候，初始化程序的程序代码变得相当复杂。  
 
举个例子，想象一下内含一些类别数据的泛型类别。我们只会取得一个类
别数据的实体，共享于每一个泛型类别实体上。如果我们需要为这个类别
数据进行初始化，指派一个初始值给它，我们就不能透过单元文件的初始
区来做这个事情 ，因为我们并不知道这个类别实际上会使用哪个型别来宣
告泛型类别。  
 
以下是一个最简单的范例，范例中，泛型类别里包含有类别建构函式，用
来为 DataSize 这个类别数据字段进行初始化，节录自 GEnericClassCtor 范
例项目 : 
type  
   TGenericWithClassCtor <T> = class   
   private   
      FData: T;   
      procedure SetData(const V alue: T);  
   public  
      class constr uctor Create;   
      property Data: T read FData write SetData;   
      class var   筆記   
 415         DataSize: Integer;  
   end;   
 
接下来是这个泛型类别建构函式的程序代码，用了一个内部的字符串列表
(请看完整的实作区程序代码 )来追踪哪一个类别建构函式有被呼叫到 : 
class constructor TGenericWithClassCtor<T>.Create;   
begin   
   DataSize : = SizeOf (T);  
   ListSequence.Add(ClassName);   
end;   
 
这范例程序建立了，也使用了几个泛型类别的实体并宣告了第三个数据型
别，这地三个资料型别则会被链接程序移除掉 : 
var  
   genInt: TGenericWithClassCtor <SmallInt>;   
   genStr: TGenericWithClassCtor <string>;   
type  
   TGenDouble = TGenericWithClassCtor <Double>;   
 
如果我们要求程序显示 ListSequence 的内容，我们只会看到已经被初始化
的型别名字 : 
TGenericWithClassCtor<System.SmallInt>   
TGenericWithClassCtor<System.string>   
 
然而，如果我们用相同的数据型别在不同的单元文件里面建立了泛型实体，
链接程序就不会如预期中那样运作，我们会对同一个泛型类别建构函数调
用多次 (或者更精确一点来说，两个相同型别的泛型类别建构函式 )。 
________________________________ _________________________________________  
类似的程序并不容易界定。为了避免重复进行初始化，我们可能会想要检
查类别建构函式是否已经被执行过。通常这个问题对于泛型类别来说，是
全面性的限制当中的一个，而链接程序并没有能力对这情形加以优化。  
 
我在本范例的第二个单元文件当中加入了一个名为 Useless的程序，当我们
取消这些程序代码的批注状态时，编译程序就会标明这些程序代码有问题，
当初始的顺序如下 : 
TGenericWithClassCtor<System.string>   
TGenericWithClassCtor<System.SmallInt>  
TGenericWithClassCtor<System.string>   筆記   
 416  
泛型的约束 (Generic Constraints)  
我们已经看过，在泛型类别中，我们能对泛型型别的值所做的处理很少。
我们可以把它传过来传过去，或是对它进行我们已经介绍过的型别处理中
的任何一项。  
 
要能够对泛型类别的型态作更确切的动作，我们通常必须给它一些约束才
行。例如如果我们规定泛型类别必须是一个类别，编译程序就会让我们透
过它来使用 TObject的方法。 我们也可以进一步约束该类别必须是类别架构
中的特定部分，或者一定要实作特定的接口，这样我们才可能透过泛型类
别的实体呼叫特定的方法。  
 
  类别约束  (Class Constraints)  
最简单的约束就是我们要求该型别必须是一个类别，我们可以这么写，来
达到这个约束：  
type  
   TSampleClass <T: class> = class   
 
透过特定的类别约束，我们可以指定只有哪些对象型别可以作为泛型型别。
以下的程序代码就可以作为例子 (节录自 ClassConstraint 范例项目 ): 
type  
   TSampleClass <T: class> = class   
   private   
      data: T;  
   public  
      procedure One;  
      function ReadT: T;  
      procedure SetT (t: T);  
   end;   
 
我们可以用前两个指令成功建立出泛型实体，但第三个指令就不行了：  
sample1: TSampleClass<TButton>;   
sample2: TSampleClass<TStrings>;   
sample3: TSampleClass<Integer>; // Error   
 
编译程序会指出第三个指令有错，错误讯息为 :  
 417 E2511 Type parameter 'T' must be a class type   
指定这个限制的好处是什么 ?在泛型类别方法中，我们现在已经可以使用
TObject的任何一个方法了，包含虚拟方法喔！以下就是 TSampleClass 泛型
类别的方法 One的程序代码 : 
procedure TSampleClass<T>.One;   
begin   
   if Assigned  (data) then  
   begin  
      Form30.Show ('ClassName: ' + data.ClassName);   
      Form30.Show ('Size: ' + IntToStr (data.InstanceSize));   
      Form30.Show ('ToString: ' + data.ToString);   
   end;   
end;   
_____________________________________________________ ____________________  
这里我们有两个建议。第一个是 InstanceSize 会回传该对象的实际大小，跟
我们刚用过的 SizeOf泛型函式不同， SizeOf会回传参考型别的大小。其次，
要留意到我们如何使用 TObject类别的 ToString方法。  
 
我们可以执行个几次，玩玩看这个程序，看一下实际的效果，在程序代码
中我们定义了几个不同的泛型型别实体，就像这段程序片段 : 
var  
   sample1: TSampleClass<TButton>;   
begin  
   sample1 := T SampleClass<TButton>.Create;   
   try  
      sample1.SetT (Sender as TButton);   
      sample1.One;  
   finally  
       sample1.Free;  
   end;  
 
请注意到透过宣告一个具有客制化过的 ToString 方法的类别，这个版本会
在数据对象的型别确定的时候被呼叫，不管实际上是什么型别被指派给泛
型型别。换句话说，如果我们建立了一个以 TButton 为类别的泛型类别实
体：  
type  
   TMy Button = class (TButton)  
   public  筆記   
 418      function ToString: string; override;   
end;   
 
我们可以把这个对象当成 TSampleClass<TButton> 型别的对象，或者作为一
个特定泛型型别的实体。在两种情形下， One方法都会呼叫到 ToString 这
个特别版本的方法 : 
var  
   sample1: TSampleClass<TButton>;   
   sample2: TSampleClass<TMyButton>;   
   mb: TMyButton;   
begin   
   ...  
   sample1.SetT (mb);  
   sample1.One;  
   sample2.SetT (mb);  
   sample2.One;  
 
跟类别约束一样，我们也可以建立记录约束，例如这样宣告 : 
type  
   TSampleRec <T: record> = class  
 
然而，这跟大多数的记录并没有太多的不同 (并没有共同的基础类别 )，所以
这个宣告相对的没有太多的新功能。  
 
  特定的类别约束  
如果我们的泛型类别需要跟特定的类别 子集一起运作 (特定的类别继承结
构树 )，我们可能会想要以特定的基础类别进行泛型类别约束，例如我们可
能会想要这样宣告 : 
type  
   TCompClass <T: TComponent> = class   
 
这个泛型类别的实体只容许组件类别， 也就是 TComponent 的任一个衍生类
别。 这让我们的泛型类别变得很确切 (对， 听起来很奇怪， 但它的确很奇怪 )，
而且编译程序会让我们在这个泛型类别的实体当中使用 TComponent 的所
有方法。  
 
如果这看起来很棒，再多想一下。如果我们考虑到要达成继承的目标与型 
 419 别兼容性规则 ，我们可能会指出使用传统面向对象技术的相同问题，而不
会使用泛型类别了。我不是说特定的类别约束完全没用，但它显然不如高
阶的类别约束或 (我发现这个还蛮有趣的 )以接口为基础的约束那么强大。  
 
  界面约束  
不限制泛型类别只能使用特定的类别，改以限制只能使用有实作特定接口
的类别，可以透过参数型别的开放性来达成泛型类别的通用性。这使得我
们可以在泛型赢别的实体当中呼叫特定接口的方法。在泛型上使用接口约
束在 C#程序语言是很常见的。我们用一个例子作为开场白 (节录自
IntfConstraint 范例项目 )。首先，我们得先宣告一 个界面：  
type  
   IGetV alue = interface  
     ['{60700EC4 -2CDA -4CD1 -A1A2 -07973D9D2444}']   
     function GetV alue: Integer;   
     procedure SetV alue (V alue: Integer);   
     property V alue: Integer   
           read GetV alue write SetV alue;  
  end;  
 
接着我们可以定义一个实作它的类别 : 
type  
   TGetV alue = class (TSingletonImplementation, IGetV alue)   
   private   
     fV alue: Integer;  
   public  
     constructor Create (V alue: Integer = 0);   
     function GetV alue: Integer;   
     procedure SetV alue (V alue: Integer);   
   end;   
 
在定义限制使用有实作 特定接口的泛型类别时，就开始有趣了：  
type  
   TInftClass <T: IGetV alue> = class   
   private   
     val1, val2: T; // or IGetV alue   
   public   
     procedure Set1 (val: T);   
 420      procedure Set2 (val: T);  
     function GetMin: Integer;  
     function GetAverage: Integer;  
     procedure IncreaseByTen;  
   end;   
 
请留意实作这个类别的泛型方法的程序代码：  
function TInftClass<T>.GetMin: Integer;   
begin   
   Result := min (val1.GetV alue, val2.GetV alue);   
end;   
 
procedure TInftClass<T>.IncreaseByTen;   
begin   
   val1.SetV alue (val1.GetV alue + 10);   
   val2.V a lue := val2.V alue + 10;  
end;  
 
有了这些定义，我们就可以这样来用这个泛型类别了 : 
procedure TFormIntfConstraint.btnV alueClick( Sender: TObject);   
var  
   iClass: TInftClass<TGetV alue>;   
begin  
   iClass := TInftClass<TGetV alue>.Create;   
   try  
      iClass.Set1 (TGetV alue.Create (5 ));  
      iClass.Set2 (TGetV alue.Create (25));   
      Show ('Average: ' + IntToStr (iClass.GetAverage));   
      iClass.IncreaseByTen;   
      Show ('Min: ' + IntToStr (iClass.GetMin));   
   finally  
     iClass.val1.Free;  
     iClass.val2.Free;  
     iClass.F ree; 
   end;   
end;   
 
为了显示这个泛型类别的弹性，我为这个接口建立了另一个完全不同的实 
 421 作方法 : 
TButtonV alue = class (TButton, IGetV alue)   
public   
   function GetV alue: Integer;   
   procedure SetV alue (V alue: Integer);   
   class function MakeTButtonV alue (Owner: TComponent;   
      Parent: TWin Control): TButtonV alue;   
end;   
function TButtonV alue.GetV alue: Integer;   
begin   
   Result := Left;  
end;  
procedure TButtonV alue.SetV alue(V alue: Integer);   
begin   
   Left := V alue;  
end;  
 
我们在以下的程序代码里面， 用类别函式 (没有在本书中列出 )为Parent控件
建立了一个组件，其位置随机指定：  
procedure TFormIn tfConstraint.btnV alueButtonClick( Sender: TObject);   
var  
   iClass: TInftClass<TButtonV alue>;   
begin  
   iClass := TInftClass<TButtonV alue>.Create;   
   try  
      iClass.Set1 (TButtonV alue.MakeTButtonV alue ( self, ScrollBox1));   
      iClass.Set2 (TButton V alue.MakeTButtonV alue ( self, ScrollBox1));   
      Show ('Average: ' + IntToStr (iClass.GetAverage));   
      Show ('Min: ' + IntToStr (iClass.GetMin));   
      iClass.IncreaseByTen;   
      Show ('New Average: ' + IntToStr (iClass.GetAverage));   
   finally  
     iClass.Free;  
   end;   
end;   
 
 
  
 422   界面参考 v.s.泛型界面约束  
在刚刚最后一个范例中，我定义了一个泛型类别，可以接受有实作特定接
口的任何类别作为其实作类别。我们也可以透过建立一个基于接口参考的
标准类别 (非泛型类别 )来达到相似的效果。 事实上， 我们可以定义一个类别，
像这样 (节录自 IntfConstraint 范例项目 ): 
type  
   TPlainInftClass = class   
   private   
       val1, val2: IGetV alue;  
   public  
       procedure Set1 (val: IGetV alue);  
       procedure Set2 (val: IGetV alue);  
       function GetMin: Integer;  
       function GetAverage: Integer;  
       procedure IncreaseByTen;  
   end;   
 
这两个作法之间的差别是什么 ?首先，在上述的类别里面我们可以传递两个
不同型别的对象给设定方法 (setter)，提供的类别都实作了特定的接口。但
在泛型版本里面，我们只能够传递一种特定型别的对象 (要看该泛型类别实
体要求哪一种型别 )。所以泛型版本的程序在型别检查这一点，比较保守，
限制也比较多。  
 
从我的观点来看，主要的不同是使用接口为基础的版本表示当中有 Object 
Pascal的参考计算器制在运作着，而使用泛型版本的时候，类别会直接以特
定型别的一般对象家里处理，因此参考计算器制并没有介入。再者，泛型
版本可能有多重的限制，像是建构函式的约束，以及使用不同的泛型函式
(像是位泛型型别要求特定的型别 )，有些动作我们就不能做 (事实上，当我
们透过接口来处理，我们就不能使用基础类别 TObject的方法 )。 
 
换句话说，使用具有接口约束的泛型类别，可以让这个类别具有接口的好
处，却没有界面的麻烦。但值得一提的是，这两种技术在大多数的情形来
看都是完全一样的，且在其他情形下，这种作法则有更多的弹性。  
 
  预设建构函式约束  
还有另一种可能的泛型型别约束，称为预设建构函式或者无需参数的建构 
 423 函式。如果我们需要呼叫预设的建构函式来建立泛型型别的对象 (例如要填
满一个列表 )，我们就可以使用这个约束。理论上 (出处为官方说明文件 )，
编译程序应该只让我们在具 备预设建构函式的型别上使用它，如果没有预
设的建构函式的话， 编译程序会跳过它， 直接呼叫 TObject的预设建构函式。  
 
一个具备建构函式约束的泛型类别可以用以下的方式来写 (节录自
IntfConstraint 范例项目 )： 
type  
  TConstrClass <T: class, constructor> = class   
  private   
    val: T;  
  public  
    constructor Create;  
    function Get: T;  
  end;  
_________ ________________________________________________________________  
我们也可以指定不具备类别约束的建构函式约束，就像先宣告的可能会指
向后宣告的。把两者都列出来，会让程序更具备可读性。  
 
来做个假设的宣告，我们可以使用建构函式来建立一个泛型内部对象，而
不用知道该类别实际上的运作方法：  
constructor TConstrClass<T>.Create;   
begin   
   val := T.Create;  
end;  
 
我们要怎么使用这个泛型类 别，且实际的规则是什么 ?在下一个范例里面，
我们提供了两个类别。第一个是有预设建构函式的 (无需参数 )，第二个则是
要求一个参数的建构函式：  
type  
    TSimpleConst = class  
    public  
       V alue: Integer;  
       constructor Create; // set V alue to 10   
    end;   
    TParamConst = class  
    public  
      V alue: Integer;  筆記   
 424       cons tructor Create (I: Integer); // set V alue to I   
    end;   
 
就像前面提过的，理论上我们应该只能使用第一个类别，但实务上我们却
是两个都能使用 : 
var  
   constructObj: TConstrClass<TSimpleCost>;  
   paramCostObj: TConstrClass<TParamCost>;   
begin  
   constructObj := TConstrClass<TSimpleCost>.Create;   
   Show ('V alue 1: ' + IntToStr (constructObj.Get.V alue));   
 
   paramCostObj := TConstrClass<TParamCost>.Create;   
   Show ('V alue 2: ' + IntToStr (paramCostObj.Get.V alue));   
 
执行结果是 : 
V alue 1: 10  
V alue 2: 0  
 
事实上，第二个对象从没有被初始划过，假如我们试着对这个范例项目侦
错，并深入到程序代码，我们就会发现一个呼 叫TObject.Create 的程序代码
(这是我犯的错误了 )。注意，假如我们试着直接呼叫 : 
with TParamConst.Create do   
 
编译程序会指出以下的错误 : 
[DCC Error] E2035 Not enough actual parameters   
_________________________________________________________________________  
即使直接呼叫 TParamConst.Create 在编译时期会犯错 (如上例所示 )。类似的
呼叫如果使用类别参考或者其他间接方式呼叫就会成功，这或许也说明了
建构函式约束效果的规则。  
 
  泛型约束的总整理以及组合应用  
我们可以在泛型型别上应用许多中不同的约束，在此我们做个简单的整理，
直接用程序代码来进行吧 : 
type  
   TSampleClass <T: class> = class   
   TSampleRec <T: record> = class   筆記   
 425    TCompClass <T: TButton> = class   
   TInftClass <T: IGetV alue> = clas s  
   TConstrClass <T: constructor> = class   
 
看过这些约束 (我也花了不少时间来熟悉它们 )之后， 没办法很直觉的知道我
们可以把这些约束进行组合。例如我们可以定义一个泛型类别，让它局限
在特定类别的子类别架构下并且要求它具备特定的接口，像是 : 
type  
   TInftComp <T: TComponent, IGetV alue> = class   
     ...  
   end;   
 
并不是所有的组合都有意义：例如我们不可以同时要求使用类别跟记录，
在使用类别约束时 ，合并使用特定的类别约束是多余的。最后，请注意方
法约束则是一个特例，它可以达成单一方法接口约束的要求 (然而比实际上
体验的更复杂 )。 
 
预先定义的泛型容器  
因为在 C++语言发展样板的早期，最常被使用的样板类别已经被定义在样
板容器或者整个清单里面了，对这些已定义的类别， C++语言则是把他们定
义为一个标准样板函式库 (Standard Template Library, 简称  STL)。 
 
当我们在定义一个对象的列表时，就像在 Object Pascal 里面提供的
TObjectList ，我们就拥有了一个可以储存任何型 别对象的列表。使用继承或
者组合的方式，我们都需要定义一个特殊型别的自定容器，但这会是个乏
味(其中也潜藏危机 )的功能。  
 
Object Pascal 编译程序原本就内建了一些泛型容器的类别，我们可以在
Generics.Collections 单元文件里面找到。 当中的四个核心容器类别都是独立
实作的 (彼此之间没有继承关系 )，这些类别都是以类似的现代方法实作的
(使用动态数组 )，而且也都对应到相应的非泛型容器类别中，原来的容器类
别都放在 Contnrs单元文件里面 : 
type  
   TList<T> = class   
   TQueue<T> = class   
   TStack<T> = class   
   TDictionary<TKey,TV alue> = class    
 426    TObjectList<T: class> = class(TList<T>)   
   TObjectQueue<T: class> = class(TQueue<T>)   
   TObjectStack<T: class> = class(TStack<T>)   
   TObjectDictionary<TKey,TV alue> = clas s(TDictionary<TKey,TValue>)   
 
这些类别逻辑上的差异，应该是它们的名称明显的不同。要熟悉跟测试它
们最好的方法，是弄清楚我们在原本使用非泛型容器类别的程序代码里面，
要做多少修改才能改为使用泛型类别。  
_________________________________________________________________________  
这个程序中只使用了一些方法，所以在泛型与非泛型的类别当中，并没有
对接口兼容性做太多的测试，不过我决定用一个已存在的程序，不要重新
写一个。 另一个要使用这个范例的原因，则是我们可能在原有的程序代码
里面进行泛型修改的时候，可以透过泛型这个功能而获得额外的改进。  
 
  使用 TList<T>  
名为 ListDemoMd2005 的程序里面，有一个用来定义 TDate类别的单元文
件，而主窗体里面就使用了一个 TList来储存日期数据。在程序一开始的
uses区段，我加入了 Generics.Collection 的引用，然后把主窗体里面的宣告
改成了这样 : 
private  
   ListDate: TList <TDate>;  
 
当然， 用来建立这个列表的主窗体 OnCreate事件处理程序也需要做些修改，
得改成这样 : 
procedure TForm1.FormCreate(Sender: TObject);   
begin   
   ListDate := TList<TDate>.Create;   
end;   
 
现在，我们可以直接编译看看，先不管其他的程序代码。此时，程序中还
包含一些『待协寻』的问题，试着把 TButton 加入到这个列表里面。对应
的程序代码原本是可以正常编译的，但现在则会出现错误了 : 
procedure TForm1.ButtonWrongClick(Sen der: TObject);   
begin   
   // add a button to the list   
   ListDate.Add (Sender); // Error:   
   // E2010 Incompatible types: 'TDate' and 'TObject'   筆記   
 427 end;   
 
新的日期列表在型别检查上比原本通用的指标列表更能自动的对型别进行
检查。移除了上面这一行有问题的程序代码以后，程序就可以正常编译、
正常运作了。不过，它还有改进的空间。  
 
以下的源代码，会把列表中所有的日期数 据显示在 ListBox组件里头：  
var 
   I: Integer;  
begin  
   ListBox1.Clear;   
   for I := 0 to ListDate.Count - 1 do   
      Listbox1.Items.Add (  (TObject(ListDate [I]) as TDate).Text);   
 
请注意当中的型别转换，因为这个程序使用了指针型的列表 (TList)，而不
是组件列表 (TObjectList) 。我们可以把这个程序先改进一下，改写成：  
for I := 0 to ListDate.Count - 1 do   
   Listbox1.Items.Add (ListDate [I].Text);   
 
这个程序片段的另一个改进空间，可以是使用列举 (预先定义的泛型列表中
完全支持此一功能 )，而不要使用 for循环：  
var 
   aDate: TDate;  
begin  
   for aDate in ListDate do  
   begin  
      Listbox1.Items.Add (aDate.Text);   
   end;   
 
最后，这个程序还可以再改进一 个地方，就是透过使用 TObjectList 来储存
TDate组件，但这是下一节的主题了。  
 
就像前面提到的 TList<T> 这个泛型类别有较高的兼容性。它包含了所有原
有的方法，像是 Add, Insert, Remove, 以及 IndexOf。同时也提供了 Capacity
跟Count属性。只是 Items变成了 Item，而且是默认属性 (可以直接用变量
名称加上方括号来存取，不用透过属性名称 )，过去我们不常直接用这种方
式存取。   
 428   对TList<T> 进行排序  
了解这当中排序的作法也是挺有趣的 (我的目的是为 ListDem oMd2005 范例
项目加入排序的功能 )。Sort方法是这样定义的 : 
procedure Sort; overload;   
procedure Sort(const AComparer: IComparer<T>); overload;   
 
这里的 IComparer<T> 接口，是定义在 Generics.Defaults 单元文件里面的。
如果我们执行了这个程序的第一个版本，它会使用预设的比较函式，由
TList<T> 的预设建构函式进行初始化。在我们的案例中，这是没有用处的。  
 
反之，我们要做的是为 IComparer <T>定义一个适当的实作方法。为了让型
别能兼容，我们得定义能够针对 TDate类别进行排序的实作程序代码。有
很多个方法可以完成这个目标，包含使用匿名方法 (我们虽然在下一章才会
介绍到匿名方法，不过下一节会先介绍作法 )。这是个有趣的技术，也是因
为它让我们有机会可以介绍许多种泛型的设计模式。这是透过位于
Generics.Defaults 单元文件的部分结构化类别，名为 TComparer 来达成的。  
_____________________________________________________________ ____________  
我之所以把这个类别称为结构化类别，是因为它协助了程序代码结构化，
而没有在实作上加入一大堆多余的名词。所以这算是一个不错的名字。  
 
这个类别是定义成抽象化类别，并以泛型实作当中的界面：  
type  
   TComparer<T> = class(TInterfacedObject, IComparer<T>)   
   public  
      class function Default: IComparer<T>;   
      class function Construct (  
          const Comparison: TComparison<T>): IComparer<T>;   
      function Compare(   
          const Left, Right: T): Integer; virtual; abstract;   
   end;   
 
我们所要做的，是先以特定的数据型别 (例如本例中的 TDate)为泛型类别实
体化，也继承一个实作了为这个数据型别处理的 Compare 方法的类别。这
两个动作可以一次完成，我们透过以下的程序来说明一下 : 
type  
   TDateComparer = class (TComparer<TDate>)   
     function Compare(  const Left, Right: TDate): Integer; override;   筆記   
 429    end;   
 
如果你觉得这段程序看起来不太适应，那很正常。新类别继承自泛型类别
的特定实体，我们可以从以下两个独立的步骤来体验 : 
type  
   TAnyDateComparer = TComparer<TDate>;  
   TMyDateComparer =  class (TAnyDateComparer)   
     function Compare(  const Left, Right: TDate): Integer; override;   
   end;   
_________________________________________________________________________  
这两个独立的宣告应该可以精简需要建立的程序代码，我们只要在宣告
TAnyDateComparer 型别的单元文件里面宣告它们即可。  
 
我们可以在原始码里面 找到 Compare 函式的实际程序代码，不过因为它不
是这一节的关键，所以我就不在这里特别贴出来了。但是要记得，即使我
们把列表排序过了， 用 IndexOf方法也不会比较有效率 (这一点跟 TStringList
类别完全不同喔 ) 
 
  以匿名方法进行排序  
在前一节出现的排序程序代码看起来相当复杂，实际上的确也是如此。把
排序函式直接传递给 Sort方法相对的简单，也清楚多了。在还没有支持泛
型功能之前，这一直都是通用排序功能的作法。在 Object Pascal 里面，现
在我们也可以透过匿名方法来达成这个功能了 (匿名方法是一种方 法指标，
里面包含几种额外的功能，我们在下一章里面加以介绍 )。 
_________________________________________________________________________  
我建议大家看一下这一节，就算您对匿名方法所知不多，也可以先读一次，
等读完下一章之后再回头重看一次。  
 
TList<T> 类别的 Sort方法的参数 IComparer<T> ，事实上可以被用来呼叫
TComparer<T> 的Construct 方法，会把一个匿名方法当做参数传递，可以写
成: 
type  
  TCo mparison<T> = reference to function(  
     const Left, Right: T): Integer;  
 
实务上，我们可以写一个型别兼容的函式，然后把它当成参数传递 : 
function DoCompare (const Left, Right: TDate): Integer;   筆記  
筆記   
 430 var  
  ldate, rDate: TDateTime;  
begin  
   lDate := EncodeDate(Left.Y ear, Left.Month, Left.Day) ;  
   rDate := EncodeDate(Right.Y ear, Right.Month, Right.Day);   
   if lDate = rDate then   
     Result := 0  
   else if lDate < rDate then  
      Result := -1 
   else  
      Result := 1;  
end;  
 
procedure TForm1.ButtonAnonSortClick(Sender: TObject);   
begin   
   ListDate.Sort (TComparer<TDate>.Construct (DoCompare));   
end;   
_________________________________________________________________________  
上例中的 DoCompare 方法是以类似匿名方法的原理运作的，即使没有函式
名称也能运作。我们稍后会以另一个程序片段来说明不需要函式名称的这
个事实。我们到下一章会介绍 Object Pascal 这个新功能的更多信息。也请
留意到，我们为 TDate记录也定义了两个比较用的运算符号，可以让程序
代码稍微简化，但即使有类别的存在，比对的程序代码也必须放在该类别
的方法里面才行。  
 
这看起来相当传统，我们在使用这种作法时可以省却独立函式的宣告，直
接把程序代码当做参数传给 Construct 方法，如下 : 
procedure TForm1.ButtonAnonSortClick(Sender: TObject);   
begin   
    ListDate.Sort (TComparer<TDate>.Construct (  
         function (co nst Left, Right: TDate): Integer   
         var  
            ldate, rDate: TDateTime;  
         begin  
             lDate := EncodeDate(Left.Y ear,  
                Left.Month, Left.Day);  
             rDate := EncodeDate(Right.Y ear,   
                Right.Month , Right.Day);   筆記   
 431              if lDate = rDate then  
               Result := 0  
             else if lDate < rDate then  
               Result := -1 
             else  
               Result := 1;  
          end));   
end;   
 
这个例子应该有激发你对于匿名方法学习的欲望吧 !肯定的是，最后这个例
子写起来比前一 节里面的程序代码简单的多，虽然对许多 Object Pascal 开
发人员来说建立一个衍生类别看起来已经很简洁易懂了 (继承的版本会把
逻辑区隔的很清楚，让未来可能重复使用程序代码时相对简单的多，但许
多时候，我们仍然还是不会去使用这个功能 )。 
 
  对象容器 (Object Containers)  
除了在这一节一开始介绍的泛型类别，还有四个从定义在 Generics.  
Collections 单元中的基础类别继承而来的泛型类别，可以模仿现存在
Contnrs单元里面的类别功能：  
type  
  TObjectList<T:  class> = class(TList<T>)   
  TObjectQueue<T: class> = class(TQueue<T>)   
  TObjectStack<T: class> = class(TStack<T>)   
 
和它们的基础类别相较之下，有两个关键性的差异。第一个是这些泛型类
别只能用在对象上，第二则是他定义了一个客制化的 Notification 方法，万
一对象要从列表当中 (除了选择性的呼叫 OnNotify 事件处理常数 )被移除了，
就会释放掉该对象。  
 
换句话说， TObjectList<T >类别的规则跟它的非泛型类别 OwnsObjects 属性
被设定成 true的时候规则是一样的。如果您觉得对于为什么这个属性不再
是可以被设定的感到好奇，可以回想一下 TList<T> 也是一样，可以直接使
用对象型别，跟它的非泛型类别规则有些不同了。  
 
还有第四个类别 TObjectDictionary<TKey, TValue> ，这个类别则是以不同的
方法定义的，它可以拥有 Key对象， Value对象，或者两者同时拥有。我们
可以在类别建构方法的 TDictionaryOwnerships 属性中看到所有可能性。   
 432   使用泛型字 典(Dictionary)  
在所有预先定义的泛型容器类别中， Dictionary 或许是最值得我们花时间好
好了解的了： TObjectDictionary<TKey, TValue> 。 
_________________________________________________________________________  
Dictionary 在这个案例中，意指一种元素的集合，在这个集合当中，可以透
过唯一键作为查询与写入的依据，用以存取对应的元素。我们也可以把这
种数据集合想成是关系型数组。在古典的 Dictionary当中，我们只能用字符
串当成唯一键，但在程序实作的时候，唯一键未必要是字符串 (虽然字符串
是比较常用的对象 )。 
 
其他的类别也很重要，但是它们似乎相对容易使用，也容易理解。为了示
范Dictionary 的使用，我写了一个范例，可以从数据表里面取出数据，为每
个记录建立一个对象，然后使用综合索引值作为键值。这个作法的原因是
相似的结构可以很容易就用来建立代理关系 (proxy)，而这种关系里，键值
可以当成从数据库加载数据时轻量化的数据版本。  
 
以下是两个在 CustomerDictionary 范例项目中使用 到的类别， 用以透过键与
值的对应储存数据。第一个只有两个对应数据来呼应数据库的数据表，第
二个则有比较复杂的数据结构 (我已经省略了私有数据字段，取得数据的方
法，以及设定数据的方法 )： 
type  
   TCustomerKey = class  
   private  
      ... 
   published  
      property CustNo: Double  read FCustNo write SetCustNo;   
      property Company: string  read FCompa ny write SetCompany;   
   end;   
    
   TCustomer = class  
   private  
       .. 
       procedure Init;  
       procedure EnforceInit;  
   public  
      constructor Create (aCustKey: TCustomerKey);   
      property CustKey: TCustomerKey   筆記   
 433          read FCustKey wr ite SetCustKey; published   
      property CustNo: Double  read GetCustNo write SetCustNo;   
      property Company: string  read GetCompany write SetCompany;   
      property Addr1: string  read GetAddr1 write SetAddr1;   
      property City: string  read GetCity  write SetCity;   
      property State: string  read GetState write SetState;   
      property Zip: string  read GetZip write SetZip;   
      property Country: string  read GetCountry write SetCountry;   
      property Phone: string  read GetPhone write SetPhone;   
      property FAX: string  read GetFAX write SetFAX;   
      property Contact: string  read GetContact write SetContact;   
   class var  
      RefDataSet: TDataSet;  
   end;   
 
第一个类别非常单纯 (每一个对象在被建立的时候就已经完成了初始化 )，
TCustomer 类别使用了延迟初始化 (或者代理 )模式且把一个参考记录在原始
码数据库中，以对象变量的 (class var) 形式分享给所有对象。当对象被建立
的时候，它的参考就已经被指派为对应的 TCustomerKey ，而类别数据则参
照到源数据集合 (dataset)。在每一个数据取得的方法中，该类别会检查对应
的对象是否的确已经完成了初始化，然后才进行回传：  
function TCustomer.GetCompany: string;   
begin   
   EnforceInit;  
   Result := FCompany;  
end;  
 
EnforceInit 方法会检查一个区域旗标， 最后会呼叫 Init从数据库把 数据加载
到数据库内的内存对象：  
procedure TCustomer.EnforceInit;   
begin   
   if not fInitDone then  
     Init; 
end;   
 
procedure TCustomer.Init;  
begin  
   RefDataSet.Locate('custno', CustKey.CustNo, []);   
 434    // could also load each published field via RTTI   
   FCustNo := RefDa taSet.FieldByName ('CustNo').AsFloat;   
   FCompany := RefDataSet.FieldByName ('Company').AsString;   
   FCountry := RefDataSet.FieldByName ('Country').AsString;  
   ...  
   fInitDone := True;   
end;   
 
透过这两个类别，我在这个应用程序中加入了一个特殊用途的 dictionary 。
这个客制化的 dictionary 类别继承 自特定型别实体化的泛型类别，并加入一
个特定的方法 : 
type  
   TCustomerDictionary = class (   
      TObjectDictionary <TCustomerKey, TCustomer>)   
   public   
      procedure LoadFromDataSet (dataset: TDataSet);   
   end;   
 
加载方法则把数据填入了 dictionary 、把数据复制到内存中，但只有键值的
对象 : 
procedure TCustomerDi ctionary.LoadFromDataSet( dataset: TDataSet);   
var 
   custKey: TCustomerKey;  
begin  
   TCustomer.RefDataSet := dataset;   
   dataset.First;   
   while not dataset.EOF do  begin   
     custKey := TCustomerKey.Create;   
     custKey.CustNo := dataset ['CustNo'];   
     custKey.Company := dataset ['Company'];   
     self.Add(custKey, TCustomer.Create (custKey));   
     dataset.Next;   
   end;   
end;   
 
范例程序中包含了一个主窗体，以及一个数据模块，里面放置了一个
ClientDataSet 组件。主窗体里面有一个 ListView 组件，当用户点选窗体上
的按钮时，就会加载数据。   
 435 __________________________________ _______________________________________  
你可能会想要用一个实际的数据集合来换掉 ClientDateSet 组件，把这个范
例扩展成真的可以使用的程序。这样就可以透过查询一个键值和每一个实
际的 TCustomer 对象的数据进行关连了。我有类似的程序代码，但是在这
里介绍的话有点离题太远，目前这个范例只是一个实验性的泛型 dictionary
类别而已。  
 
把数据加载到 dictionary 之后， btnPopulateClick 方法会把 dictionary 的键值
做列举 : 
proced ure TFormCustomerDictionary.btnPopulateClick( Sender: TObject);   
var 
   custkey: TCustomerKey;  
   listItem: TListItem;  
begin  
   DataModule1.ClientDataSet1.Active := True;   
   CustDict.LoadFromDataSet(DataModule1.ClientDataSet1);   
 
   for custkey in CustDi ct.Keys do   
   begin   
     listItem := ListView1.Items.Add;   
     listItem.Caption := custkey.Company;   
     listItem.SubItems.Add(FloatTOStr (custkey.CustNo));   
     listItem.Data := custkey;   
   end;   
end;   
 
这会把 ListView 组件的前两个字段填入数据， 所有在 dictionary 的key当中
的数据都会被显示出来。当用户点选 ListView 组件中的任何一个项目时，
程序就会填入第三个字段 : 
procedure TFormCustomerDictionary.ListView1SelectItem(   
    Sender: TObject; Item: TListItem; Selected: Boolean);   
var 
   aCustomer: TCustomer;  
begin  
   aCustomer := CustDict.Items [Item.data];   
   Item.SubIte ms.Add(IfThen (   
        aCustomer.State <> '',   
        aCustomer.State + ', ' + aCustomer.Country,   筆記   
 436         aCustomer.Country));   
end;   
 
上面的这个方法会取得该键值相对的对象，并使用对应的数据。在背景里，
特定的对象第一次被使用到时，存取属性的方法就会把完整的数据加载到
TCustomer 对象。  
 
  Dictionary v.s. StringList  
经过了这么多年，许 多Object Pascal 的开发人员，包含我自己，都过度使
用了 TStringList 类别 (译者 :我也是 )。我们不只可以用 TStringList 来储存字
符串，还可以用来储存成对的名称与内容。不仅如此，还可以用来储存成
对的名称与对象，更可以透过搜寻名称来取得对应的对象。  
 
从简单的介绍来看，字符串列表看起来比泛型好多了，简直就像个瑞士万
用刀一样了嘛。特定、聚焦的容器类别，的确相对是比较好的选择。举例
来说，一般的 TDictionary 类别，以字符串当做键值，以对象当做内容，会
比字符串列表来的好，至少有两个优点 :程序清晰明白、也比较安全。因为
当中会牵涉到的型别转换比较少，且执行速度比较快，这当然是假设该
dictionary 是使用哈希表 (Hash table) 的。  
 
要表现出这些不同点， 我也写了一个相对简单的范例项目， 叫做 StringListVs  
Dictionary 。它的主窗体储存了两个相同的列表，宣告如下 : 
private   
   sList: TStringList;   
   sDict: TDictionary<string,TMyObject>;   
 
这个列表会随机的填入数据，但相同的节点则会循环填入，重复 执行的程
序代码内容如下 : 
sList.AddObject (aName, anObject);   
sDict.Add (aName, anObject);   
 
窗体上的两个按钮，分别是取得该列表中的每个元素，以及透过名称进行
搜寻。两个方法都会搜寻整个字符串列表来找到对应的值，但是第一个方
法则是会找出字符串列表中的对象，第二个方法会使用 dictionary 。请注意，
使用第一个方法时， 我们需要用到 as型别转换来变成特定的型别， dictionary
则是已经跟类别绑定了。以下是这两个方法的主要循环 : 
  
 437 theTot al := 0;  
for I := 0 to sList.Count -1 do   
begin   
   aName := sList[I];   
   // now search for it   
   anIndex := sList.IndexOf (aName);   
   // get the object   
   anObject := sList.Objects [anIndex] as TMyObject;   
   Inc (theTotal, anObject.V alue);   
end;   
 
theTotal := 0;   
for I := 0 to sList.Count -1 do   
begin   
   aName := sList[I];   
   // get the object   
   anObject := sDict.Items [aName];   
   Inc (theTotal, anObject.V alue);   
end;   
 
我不想依序存取字符串，但需要得知存取了几次以后才在已经排序过后的
字符串列表中找到要找的内容 (字符串列表的搜寻是以二元搜寻法进行 )，来
跟使用哈希键值的 dictionary做个比较。毫无意外的， dictionary 当然比较
快，以下是测试时用 ms为单位得到的数字 : 
 Total: 99493811  
 StringList: 2839  
 Total: 99493811  
 Dictionary: 686  
 
这个结果是相同的，假设初始值是完全相同的，但时间上差的可远了，同
样处理一百万笔数据，使用 dictionary 的搜寻大概只花了使用字符串列表四
分之一的时间。  
 
泛型界面  
在『对 TList<T> 进行排序』那一小节里，对预先定义的接口比较奇怪的用
法，应该还有印象吧，当中有 提到泛型的宣告。当中的技术细节值得我们
仔细一谈，因为它制造了相当明确的机会。   
 438 第一个要提到的技术部分是它完美的合法定义了一个泛型接口，就像我们
在GenericInterface 范例项目中所做的 : 
type  
   IGetV alue<T> = interface  
     function GetV alue: T;  
     procedure SetV alue (V alue: T);  
   end;  
______________________________________________________ ___________________  
这是 IntfCotraints 范例项目中， IGetValue 接口的泛型版本，我们在本章稍
早的『接口约束』那一节里面介绍过。在该案例中，这个接口是记录一个
整数的数值，而在此则改为泛型。  
 
注意到其中和标准接口的差异，在泛型接口中，我们不需要定义明确的
GUID作为该接口的代号 (或称 IID)。编译程序会在我们为泛型接口进行实
体化的时候主动建立一个 IID，也算是隐藏式的宣告。事实上，我们不用为
泛型接口建立特定的实体也可以实作它，只要定义一个泛型类别，让该类
别实作这个泛型接口 即可：  
type  
   TGetV alue<T> = class (TInterfacedObject, IGetV alue<T>)   
   private   
      fV alue: T;  
   public  
      constructor Create (V alue: T);   
      destructor Destroy; override;   
      function GetV alue: T;   
      procedure SetV alue (V alue: T);   
   end;  
 
在建构函式指派该对象的初始值的时候，解构函式的唯一要求是把该对象
先记录下来注记成未来要释放的对象。我们可以建立这个泛型类别的实体
(在背景建立一个接口型别的特定实体 )，可以这么写：  
procedure TFormGenericInterface.btnV alueClick( Sender: TObject);   
var 
   aV al: TGetV alue<string>;  
begin  
   aV al := TGetV alue<string>.Create (Caption);   
   try  
      Show ('TGetV alue value: ' + aV al.GetV alue);   筆記   
 439    finally  
     aV al.Free;  
   end;   
end;   
 
我们在 IntfConstraint 范例项目里面看过一个替代的作法，是用一个特定型
别的接口变量，然后明确的写明该接口型别的定义 (不像一般我们在写型别
时都是隐藏的写法 ): 
procedure TFormGenericInterface.btnIV alueClick( Sender: TObject);   
var 
   aV al:  IGetV alue<string>;  
begin  
   aV al := TGetV alue<string>.Create (Caption);   
   Show ('IGetV alue value: ' + aV al.GetV alue);   
   // freed automatically, as it is reference counted   
end;   
 
当然，我们也可以定义一个特定的类别来实作这个泛型接口，就像以下这
个案例 (节录自 GenericInterface 范例项目 ): 
type  
   TButtonV alue = class (TButton, IGetV alue<Integer>)   
   public   
      function GetV alue: Integer;   
      procedure SetV alue (V alue: Integer);   
      class function MakeTButtonV alue (Owner: TComponent;   
           Parent: TWinControl): TButtonV alue;   
   end;   
 
请留意， TGetValue<T> 泛型类别实作了 IGetValue<T> 接口， TButtonValue
特定类别实作了 IGetValue<Integer> 这个特定接口。在前面的例子当中，这
个接口会被重新对应到组件的 Left属性 : 
function TButtonV alue.GetV alue: Integer;   
begin   
   Result := Left;  
end;  
 
在上面的这个类别中， MakeTButtonValue 这个类别函式是一个已经准备好
随时可以用来建立该类别对象的方法。这个方法会在主窗体 的地三个按钮 
 440 里面被用上：  
procedure TFormGenericInterface.btnV alueButtonClick( Sender: TObject);   
var 
   iV al: IGetV alue<Integer>;  
begin  
   iV al := TButtonV alue.MakeTButtonV alue (self, ScrollBox1);   
   Show ('Button value: ' + IntToStr (iV al.GetV alue));   
end;   
 
虽然这跟泛型 类别完全没关系，以下是 MakeTButtonValue 这个类别函式的
程序代码 : 
class function TButtonV alue.MakeTButtonV alue(   
     Owner: TComponent; Parent: TWinControl): TButtonV alue;   
begin  
   Result := TButtonV alue.Create(Owner);   
   Result.Parent := Parent;   
   Result.SetBounds(Random (Pa rent.Width),   
       Random (Parent.Height), Result.Width, Result.Height);   
   Result.Caption := 'btnv';   
end;   
 
  预先定义的泛型接口  
现在我们已经看过了如何定义泛型接口，以及如何把泛型接口跟泛型类别
或一般类别结合的方法，我们再回头看一下 Generics.Default 单元文件。这
个单元文件定义了两个泛型比较用的界面 : 
 IComparer<T> 拥有一个 Compare 方法  
 IEqualityCom parer<T> 则拥有 Equals跟GetHashCode 方法  
 
这些接口则由一些泛型类别或者一般类别实作出来，兹列于下 (实作的内容
就不列了 ): 
type  
   TComparer<T> = class(TInterfacedObject, IComparer<T>)   
   TEqualityComparer<T> = class(   
     TInterfacedObject, IEqualityComparer<T>)   
   TCustomComparer<T> = class(TSinglet onImplementation,   
     IComparer<T>, IEqualityComparer<T>)   
  TStringComparer = class(TCustomComparer<string>)    
 441 在上面的列表中，我们可以看到用于实作泛型接口的基础类别要不是传统
的参考计数功能的 TInterfacedObject 类别，就是 TSingletonImplementation
类别。 这是一个名字很奇怪的类别， 因为它只提供了 IInterface 的基本实作，
而且没有用到参考计数。  
______ ___________________________________________________________________  
singleton 这个名词一般是用来定义只能被建立出一个实体对象的类别，而
不是不具备参考计数功能的类别。我觉得这个名字取得真的不恰当。  
 
就像我们在本章『对 TList<T> 进行排序』那一节所提到的，这些比较用的
类别会被泛型容器使用到。为了让程序能不要太复杂， Generics.Default 单
元文件里面大量使用了匿名方法，所以您或许需要先看一下下一章再回来
重新阅读一次。  
 
在Object Pascal 里 面 的 智 能 指 标 (Smart 
Pointer)  
开始接触泛型的时候，我们一开始可能会误以为 Object Pascal 大多数是用
它来处理集合对象的。当然处理集合对象对泛型类别来说是最基本的情境，
在文件或者书籍里面的第一个范例也大多都是使用集合或者容器类别来说
明泛型。在本章的最后一个范例里，我们会介绍非集合类的泛型类别，也
就是定义一个智能指标 (Smart Pointer) 。 
 
如果您原本就很习惯写 Object Pascal ，您可能完全没听过智能指标，这个概
念是从 C++程序语言而来。在 C++里面，我们可以有指向对象的指针，透
过这个指标，我们可以直接进行人工内存管理，区域对象变量则会自动被
管理，但有其他的限制 (包含缺乏对多型的支持 )。智能指针的概念是使用在
区域中被管理的对象来处理指向我们会用到的实际对象指针的生命周期。
如果这听起来很太复杂， 我希望 Object Pascal 版(跟它的程序代码 )可以协助
厘清这个概念。  
_________________________________________________________________________  
在OOP里面，多型 (polym orphism)这个名词是用来标注以下情形：我们把
一个衍生类别的对象指派给基础类别的变量，并且呼叫基础类别中的虚拟
方法，最后可能会呼叫到特定子类别所重新实作的版本。  
 
  智能指针的泛型记录  
在Object Pascal 当中的对象都是以参考进行管理，但记录的生命周期跟宣筆記  
筆記   
 442 告了该记录变量的方法紧密结合着。当方法执行结束，该记录的内存空间
也会自动被清除掉。所以我们可以透过记录来管理 Object Pascal 对象的生
命周期。当然，我们希望同一段程序代码只写一次，所以我们可以使用泛
型记录，以下是第一版的程序代码 : 
type  
  TSmartPointer<T: class> = record   
  strict private   
     FV alue: T;   
     function GetV alue: T;  
  public  
     constructor Create(AV alue: T);  
     property V alue: T read GetV alue;   
  end;   
 
记录当中的 Create跟GetValue 方法可以单纯的指派、读回该值。使用这段
程序，我们可以建立一个对象，建立一个智能指 标来替代它，并让彼此互
相参考：  
var  
  sl: TStringList;   
  smartP: TSmartPointer<TStringList>;   
begin  
   sl := TStringList.Create;   
   smartP .Create (sl); sl.Add('foo');   
   smartP .V alue.Add ('foo2');   
 
当我们已经让程序运作了，如果没有使用智能指标，上面这段程序代码可
是会导致内存泄漏的情况发生喔。事实上，记录会自动在离开程序区块后
被释放， 但它却无法释放内部对象。可是记录并没有解构函式，那我们要
怎么管理对象的释放呢 ?可以用一个小技巧来处理，透过在记录里面使用接
口来处理这情形即可，因为记录会自动释放掉接口对象。我们该在进行转
换过的对象上面加上接口吗 ?或许不要，因为这表示我们可能会把即将传递
给智能指针的对象加上一个很明显的限制。  
 
  用界面来救援  
另一个比较好的替代方案或许是写一个特定的转换类别，把这个转换类别
跟一个接口绑定，并把这个接口的参考计算器制用在转换过的对象上。内
部的类别程序代码会像这样：   
 443 type  
  TFreeTheV alue = class (TInterfacedObject)   
  private   
     fObjectToFree: TObject;  
  public  
     constructor Create(anObjectToFree: TObject);   
     destructor Destroy; override;   
  end;   
 
constructor TFreeTheV alue.Create( anObjectToFree: TObject);   
begin  
   fObjectToFr ee := anObjectToFree;   
end;   
destructor TFreeTheV alue.Destroy;   
begin   
   fObjectToFree.Free;  
   inherited;  
end;  
 
好多了，在实际案例上，我是把这个类别当成泛型智能指标宣告成嵌套类
型。我们需要在智能指标泛型型别上所做的，好让这个功能能够使用的，
是新增一个接口参考，并用 TFreeTheValue 对象进行初始化，以参照到内部
对象：  
type  
   TSmartPointer<T: class> = record   
   strict private   
       FV alue: T;  
       FFreeTheV alue: IInterface;  
       function GetV alue: T;  
   public  
       constructor Create(AV alue: T); overload;   
       property V alue: T read GetV alue;   
   end;   
 
虚构的建构函式 (记录不会有实际的建构函式 )变成了 : 
constructor  TSmartPointer<T>.Create(AV alue: T);   
begin   
   FV alue := AV alue;   
 444    FFreeTheV alue := TFreeTheV alue.Create(FV alue);   
end;   
   
  使用智能指标  
透过前述的程序代码，我们现在就可以在程序里面写以下的程序代码，而
不会造成内存泄漏了。  
procedure TFormSmartPointers.btnSmartClick( Sender: TObject);   
var  
   sl: TSt ringList;   
   smartP: TSmartPointer<TStringList>;   
begin  
   sl := TStringList.Create;  
   smartP .Create (sl);  
   sl.Add('foo');  
   Show ('Count: ' + IntToStr (sl.Count));  
end;   
 
在方法的最后， smartP记录会被释放掉，同时也会连带使得内部接口对象
一起被清除，并释放掉 TStringList 对象。留意到这个释放动作就算是发生
了例外状况也 一样会进行的，所以在这里不用透过 try-finally区块来保护程
序代码。  
_________________________________________________________________________  
在实务上，编译程序会自动加入一个 try-finally区块在所有包含了接口的纪
录，但我们不用实际把它写出来 (编译程序不会忘了加上它 )。 
 
在程序中，我们在初始区块中透过设定全局变量 ReportMemoryLeakOn  
Shutdown 验证了所有对象都实际被释放掉了，为了提供计数器做检查 ，在
程序中有一个按钮会造成内存泄漏，它会导致程序终止。  
 
  加入隐晦转换 (Adding Implicit Conversion)  
所以使用智能指针记录，我们可以不用呼叫 Free方法，也不用再使用
try-finally区块了，但还是有些程序代码得写 (要记得写 )。延伸智能指标类
别是包含了隐晦 (Implicit) 转换运算符号，提供了指派目标对象给智能指针
的能力：  
class operator TSmartPointer<T>.   筆記   
 445     Implicit(AV alue: T): TSmartPointer<T> ;  
begin  
    Result := TSmartPointer<T>.Create(AV alue);   
end;   
透过这段程序代码 (以及使用 Value数据字段 )我们现在可以让程序代码更为
精简了，精简过的版本如下 : 
var  
  smartP: TSmartPointer<TStringList>;   
begin  
   smartP := TStringList.Create;   
   smartP .V alue.Add('foo');   
   Show ('Count: ' + IntToSt r (smartP .V alue.Count));   
 
作为替代方案，我们可以使用一个 TStringList 变量，并使用一个比较复杂
的建构函式来位智能指针记录进行初始化，即使没有特别写明其参考：  
var 
  sl: TStringList;  
begin  
   sl := TSmartPointer<TStringList>.   
   Create(TStringList.Create).V alue;   
   sl.Add('foo');   
   Show ('Count: ' + IntToStr (sl. Count));   
 
正如我们已经开始进行的，我们也可以定义完全相反的转换，并使用转换
符号，而不要用 Value属性：  
class operator TSmartPointer<T>.   
     Implicit(AV alue: T): TSmartPointer<T>;   
begin  
   Result := TSmartPointer<T>.Create(AV alue);   
end;   
 
var  
   smartP: TSmartPointer<TStringList>;   
begin  
   smartP := TStringList.Create;   
   TStringList(smartP).Add('foo2');   
 
现在，我们应该也要注意到上面这段程序代码里面使用了虚构建构函式， 
 446 但这对记录并不需要。我们需要的是找到一个方法对内部对象进行初始化，
可能是呼叫它的建构函式，当我们第一次使用到它的时候。我们无法检查
内部对象是否已经被指派，因为记录 (跟类别不同 )并不会被初始化为 0。然
而我们可以从接口变量来测试，接口变量会被初始化。  
  加入自动建立  
智能指针记录型别的额外程序代码是一个重载的 Create程序 (它不会是一个
建构函式，记录中是不能有不含参数的建构函式的 )，以及一个延迟初始化
的Value属性：  
procedure TSmartPointer<T>.Create;   
begin   
   TSmartPointer<T>.Create (T.Create);   
end;   
 
function TSmartPointer<T>.GetV alue: T;   
begin   
   if not Assigned(FFreeTheV alue) then   
     self := TSmartPoint er<T>.Create (T.Create);   
   Result := FV alue;  
end;  
 
透过这段程序，我们现在可以透过很多种方法来使用智能指标，包含不用
释放，甚至不用写明了建立它：  
var  
   smartP: TSmartPointer<TStringList>;   
begin  
   smartP .V alue.Add('foo');   
   Show ('Count: ' + IntToStr (smartP .V alue.Count));   
end;   
 
上述的方法事实上建立了一个字 符串列表，并且在离开函式的时候把它释
放掉了，这听起来跟一般 Object Pascal 程序开发人员的标准写法很不一样。
而这也是把泛型用在非集合型别的唯一案例。  
 
  完整的智能指标程序代码  
在这一节的最后，我们来列出智能指针泛型记录的完整程序代码吧 : 
type   
 447    TSmartPointer<T: class, constructor> = record   
   strict private   
     FV alue: T;  
     FFreeTheV alue: IInterface;  
     function GetV alue: T;  
   private   
      type  
        TFreeTheV alue = class (TInterfacedObject)   
        private   
           fObjectToFree: TObject;  
        public  
           constructor Create(anObjectToFree: TObject);   
           destructor Destroy; overrid e;  
        end;   
   public  
      constructor Create(AV alue: T); overload;   
      procedure Create; overload;   
      class operator Implicit(AV alue: T): TSmartPointer<T>;   
      class operator Implicit(smart: TSmartPointer <T>): T;   
      property V alue: T read GetV alue;   
   end;   
 
上面的程序代码跟本节里面所提到的使用模式都在 SmartPointer 范例项目
中。现在，我不主张常常使用这种写法来取代标准的内存管理方式。在本
书中撰写这一节的用意是要彰显 Object Pascal 的技术深度，我们是可能用
它来写出像本节中所介绍的智能指标这样既强大又复杂的程序的。  
 
以泛型处理协同变异 (Covariant) 回传型别  
在Object Pascal 当中 (以及大多数静态面向对象程序语言 )， 一般来说一个方
法可以回传一个类别的对象，但我们不能把一个对 象重载成另一个衍生类
别之后，当成该类别来回传。这个作法称为『协同变异回传型别』 ，在一些
程序语言里面是有明确支持的，例如 C++。 
 
  属于Animals, Dogs, 跟 Cats 
从程序代码的词语来看，如果 TDog是继承自 TAnimal，我们就可以呼叫这
些方法 :  
 448 function TAnimal.Get (name: string): TAnimal;   
function TDog.Get (name: string): TDog;   
 
然而在 Object Pascal 里面我们不能让虚拟方法回传不同的值，我 们也不能
对回传型别进行多载，只能在参数上进行多载。我们来透过简单的范例介
绍完整的程序代码吧，以下是三个我们会用到的类别 : 
type  
   TAnimal = class  
   private  
     FName: string;  
     procedure SetName(const V alue: string);  
   public  
      property Name: string read FName write SetName;   
   public  
      class functi on Get (const aName: string): TAnimal; function ToString: string; override;   
   end;   
    
   TDog = class (TAnimal)  
   end;   
 
   TCat = class (TAnimal)  
   end;   
 
这两个方法的实作程序代码非常简单，我们注意到类别函式是实际上用来
建立新组件的，它会从内部呼叫一个建构函式。理由是我不想直接建立一
个建构函式，这已经介绍过很多次了，建构函式是一个类别用来建立 对象
的方法 (或者类别架构 )。程序代码如下 : 
class function TAnimal.Get(const aName: string): TAnimal;   
begin   
   Result := Create;  
   Result.fName := aName;  
end;  
 
function TAnimal.ToString: string;   
begin   
   Result := 'This ' + Copy (ClassName, 2, maxint) +   
      ' is called ' + FName;   
end;    
 449  
现在我们可以用以下的程序代码来使用这个类别了，这不是我喜欢的用法，
假设我们要把回传来的结果转成适当型别 : 
 
var 
   aCat: TCat;  
begin  
   aCat := TCat.Get('Matisse') as TCat;   
   Memo1.Lines.Add (aCat.ToString);   
   aCat.Free;   
 
再次强调， 我想做的是让 TCat.Get 的回传值能够被指派到 TCat型别的参考，
而不要多做一次转型，我们该怎么做呢 ? 
 
  回传泛型结果的方法  
泛型可以协助我们解决这个问题。并不是泛型型别，泛型型别是最常用的
泛型形式。但我们已经在本章前面的篇幅里面介绍过提供非泛型型别的泛
型方法了。我们可以在 TAnimal 类别中加入的是一个以泛型型别作为参数
的方法：  
class function GetAs<T: class> (const aName: string): T;   
 
这个方法会要求一个泛型型别作为参数，在这个例子里泛型型别是个类别
(或实际的型别 )，并回传该型别的物件。简单的实作程序代码如下 : 
class function TAnima l.GetAs<T>(const aName: string): T;   
var  
   res: TAnimal;  
begin  
   res := Get (aName);   
   if res.inheritsFrom (T) then   
     Result := T(res)  
   else  
     Result := nil;  
end;  
 
现在我们可以建立一个实际的案例了，透过 as转型，不过我们还是可以把
型别当成参数传进去 : 
var  
 450    aDog: TDog;  
begin  
   aDog := TDog.GetAs<TDog>('Pluto');   
   Memo1.Lines.Add (aDog.ToString);   
   aDog.Free;   
 
  回传不同类别的衍生对象  
当我们回传相同类别的对象时，我们可以直接改上面的程序代码来当做建
构函式。但使用泛型来取得协同变异回传型别是更有弹性的。事实上我们
可以用它来回传不同类别的对象，甚至是不同架构的类别：  
type  
   TAnimalShop = class  
     class function GetAs<T: TAnimal, c onstructor> ( const aName: string): T;   
   end;   
_________________________________________________________________________  
像这样的类别，被用来为其他类别 (或者不只一个类别，视其参数或者状态
而定 )建立对象，通常称为类别工厂 (class factory) 。 
 
我们现在可以使用这个特定的类别约束 (在该类别来说，也许不可能达成 )，
且我们必须确立建构函式约束，好让泛型方法可以用来建立特定的类别 对
象：  
class function TAnimalShop.GetAs<T>(const aName: string): T;   
var  
   res: TAnimal;  
begin  
   res := T.Create;   
   res.Name := aName;   
   if res.inheritsFrom (T) then   
     Result := T(res)  
   else  
      Result := nil;  
end;  
 
要注意，现在在这个呼叫的写法中，我们不用重复该类别两次了 : 
aDog := TAnimalShop.GetAs<TDog>('Pluto');   
 筆記   
 451 15:匿名方法  
 
Object Pascal 同时包含了程序型别 (也就是可以宣告指向程序或函式的指针
型别 )以及方法指标 (也就是可以宣告指向方法的指标 )。 
_________________________________________________________________________  
关于程序型别的相关知识，我们在第四章有详尽的介绍。而关于方法指标
型别，则在第十章里面有详细的介绍。  
 
虽然您可能不常 直接使用匿名方法，但这是 Object Pascal 当中每个开发人
员都会用到的关键功能喔。事实上，方法指针型别是控制组件与视觉组件
中事件处理程序的基础：每当我们宣告了一个事件处理程序，即使只是简
单的 Button1Click ，事实上我们就宣告了一个方法，会用来跟一个事件连结
(在这个例子里面是跟 OnClick事件连结 )，连结的关键就是方法指标。  
 
匿名方法延伸了这个功能，让我们可以把一个方法的实际程序代码当成参
数来传递，而不用先定义一个方法，然后把方法的名字当成参数了。然而
这并不是唯一的差异。让匿名方法跟其他技术 不同的地方，还有它对局部
变量生命周期的管理。  
 
上述的定义跟其他语言里面所称的 Closure功能 (例如 Javascript) 一样。如果
Object Pascal 的匿名方法事实上就是这些程序语言里面所说的 Closure，为
什么 Object Pascal 要用跟其他语言不一样的名词 ?原因是两个不同语言中使
用了不同的名词。在 Embarcadero 所提供的 C++编译程序所称的 closure是
用来称呼 Object Pascal 所称的事件处理程序 (所以为了避免同一个名词被用
来表达两种不同的技术可能会造成的混淆，就把名词分 开了 ) 
 
匿名方法在这几年里面已经用不同的形式、不同的名字，在一些程序语言
里面出现在世界里，大多是标注式的动态语言。我自己也有用 JavaScript
的closure来开发的经验，主要是使用 jQuery函式库跟 AJAX来呼叫。对应
的功能在 C#里面则是被称为匿名委任。  
 
但在这里我不想花太多时间来比较 closure跟不同语言当中的相关技术，我
们只描述这个技术在 Object Pascal 里面的工作细节。  
 
 筆記   
 452 _____________________________________________________ ____________________  
从比较高阶的观点来看，泛型允许程序代码可以用型别作为参数，而匿名
方法则是允许程序代码可以用方法作为参数。  
 
匿名方法的语法和语意  
在Object Pascal 里的匿名方法，是一种 在表达式的写法中建立方法内容 的
机制。这个定义听起来很神秘，也相当精确的强调它与方法指标的关键差
异，也就是 表达式写法的内容 。在我们介绍到内容之前，我们先从很简单
的范例程序开始吧 (本节的程序片段几乎都包含在 AnonymFirst 范例项目里
面了 )。 
 
以下是匿名方法型别的宣告，我们可以从这里看出 Object Pascal 的确是一
个强型别的语言 : 
type  
   TIntProc = reference to procedure (n: Integer);   
 
这个宣告跟方法指标型别的差异只在用于宣告的关键词 : 
type  
   TIntMethod = procedure (n: Integer) of object;   
 
  匿名方法变量  
以最简单的案例来看，一旦我们宣告了匿名方法型别，当然就可以用这个
型别来宣告变量，然后指派一个型别兼容的匿名方法给它，并且后过这个
变量来呼叫该方法：  
proc edure TFormAnonymFirst.btnSimpleV arClick( Sender: TObject);   
var 
    anIntProc: TIntProc;  
begin  
    anIntProc :=  
    procedure (n: Integer)  
    begin  
        Memo1.Lines.Add (IntToStr (n));   
    end;   
    anIntProc (22);  
end;  
 筆記   
 453 请记得上例中，用来指派一个实际程序的语法，它是把内嵌的程序 代码指
派给变数喔。  
 
  匿名方法的参数  
当成一个有趣的范例 (或许用更让人惊讶的语法 )， 我们可以把一个匿名方法
作为参数传给一个函式。假设我们有一个要以匿名方法当成参数的函式 : 
procedure CallTwice (value: Integer; anIntProc: TIntProc);   
begin  
   anIntProc (value);  
   Inc (value);  
   anIntProc (value);  
end;   
 
这个函式里面会呼叫这个当成参数被传进来的匿名方法两次，把两个不同
的整数数值传递进去， 第一个数字会被当成第二个参数 (匿名方法 )的参数传
递进去处理。我们呼叫这个函式的时候，只要把一个匿名方法当成第二个
参数传进去即可，它的语法非常简单、直接：  
procedure TFormAnonymFirst.btnProcParamClick( Sender: TObject);   
begin  
   CallTwice (48,  
         procedure (n: Integer)  
         begin  
           Show (IntToHex (n, 4));  
         end);  
 
   CallTwice (100,  
            procedure (n: Integer)  
            begin  
              Show (FloatToStr(Sqrt(n)));  
            end);  
end;   
 
从语法的观点来看，我们要注意到在小括号里面要把程序当成参数传进去
时，最后不用加上分号喔。实际的程序代码里面，是呼叫了 IntToHex ，以
48跟49和FloatToStr 来处理 100跟101的平方根，得到了 以下的结果 : 
0030  
0031   
 454 10 
10.0498756211209  
 
使用局部变量  
我们也可以透过方法指标来达成一样的功能，虽然语法比较不同，也比较
不容易理解。匿名方法最明显的不同，是匿名方法当中在执行程序代码时
使用局部变量的方法。先来一段范例：  
procedure TFormAnonymFirst.btnLocalV alClick( Sender: TObject);   
var 
   aNumber: Integer;  
begin  
   aNumber := 0;  
   CallTwice (10,  
       procedure (n: Integer)  
       begin  
           Inc (aNumber, n);  
       end);  
   Show (IntToStr (aNumber));  
end;  
 
这里所用的范例仍然呼叫 CallTwice 程序，使用了区域参数 n，也从被呼叫
的程序当中使用了一个名为 aNumber 的局部变量。 效果是什么 ?这两次呼叫
匿名方法的过程中，都会改变局部变量，把传入的参数加进这个变量中，
第一次执行的时候是 10， 第二次执行的时候则是 11， 所以两次 执行完以后，
aNumer的值就变成了 21。 
 
  展延局部变量的生命周期  
前例中显示了一个有趣的效应，但透过一连串巢状函式的呼叫，这个局部
变量的变化也就不令人惊讶了。然而匿名方法的强大，是在于它可以使用
局部变量，并且展延局部变量的生命周期直到匿名方法不再需要它。范例
程序就可以证明，不用再多用文字说明了。  
_________________________________________________________________________  
很明显的，从技术观点来看，匿名方法会把局部变量跟参数都复 制到自己
被呼叫的当时所使用的 heap，并维持这些变量的生命周期直到匿名方法执
行结束为止。  
 筆記   
 455 我已经透过类别自动完整的功能，在 TFormAnonymFirst 窗体类别 (属于
AnonymFirst 范例项目 )中加入了一个属性，其类别是匿名方法指标型别
(嗯…实际上我已经在该项目中使用了相同的匿名方法指标型别了 ): 
  private  
     FAnonMeth: TIntProc;   
     procedure SetAnonMeth(const V alue: TIntProc);   
  public  
     property AnonMeth: TIntProc  
       read FAnonMeth write SetAnonMeth;   
 
接着，我们在程序的窗体画面上加了两个按钮，第一个储存了使用局部变
量的匿名方法属性 (就像前一个 btnLocalValclick 方法一样 ): 
procedure TFormAnonymFirst.btnStoreClick( Sender: TObject);   
var 
   aNumber: Integer;  
begin  
    aNumber := 3;  
    AnonMeth :=  
       procedure (n: Integer)  
       begin  
          Inc (aNumber, n);  
          Show (IntToStr (aNumber));  
       end;  
end;   
当这个方法执行值，匿名方法并没有被执行，只是被储存下来了。局部变
量aNumber 当时初始化之后，内容是 3，并没有被变更，接着这个方法执
行完毕，然后被从内存移除了。至少这是我们从标准的 Object Pascal 程序
代码的语法所得到的理解。  
 
我们加在窗体面的第二个按钮，就会实质呼叫储存在 AnonMeth 属性里面
的匿名方法了 : 
procedure TFormAnonymFirst.btnCallClick(Sender: TObject);   
begin   
   if Assigned (AnonMeth) then   
   begin   
      CallTwice (2, AnonMeth);  
   end;  
end;    
 456 这段程序代码被执行的时候， 会呼叫使用到局部变量 aNumber 的匿名方法，
但这个时候 aNumber 这个变量在内存当中已 经不复存在了。然而，因为匿
名方法的程序代码中有使用到 aNumber，这个情形会让 aNumber 的生命周
期被延用到匿名方法结束。  
 
我们再延伸举证，按下 Store按钮一次， Call按钮两次，我们就可以看到该
变量的内容变化如下 : 
5 
8 
10 
13 
_________________________________________________________________________  
使用这个操作步骤的原因，是这个变量开始的时候内容是 3，每次点击时，
第一次呼叫 CallTwice 来传递匿名方法 (变量值会被加 2)， 第二则会多加 1(所
以第二次呼叫就会被加 3)。 
 
现在，再按一次 Store，然后再按 Call。发生了什么事 ?为什么局部变量的内
容被重设了 ?因为新的匿名方法实体被指派了，旧的匿名方法实体就被删除
掉了 (包含它的执行内容 )，新的执行内容就被储存下来，连同新的局部变量
实体一起。完整的程序 Store -Call-Call-Store -Call程序：  
5 
8 
10 
13 
5 
8 
 
这是匿名方法行为的含义，重组了一些其他程序语言所做的，这使得匿名
方法成为一个很强大的程序语言功能，透过这个功能，我们可以实作出一
些以前根本难以完成的东西。  
 
在背景里的匿名方法  
如果变量连带储存的功能是匿名方法的众多功能中，我们可能最常用到的
功能之一，但其中还有许多技术是值得我们深入探讨的，在我们开始仔细
深入到一些实际案例之前。  
 筆記   
 457   (潜在的 )漏掉括号  
请注意上面的程序代码，我们使用了 AnonMeth 这个属性来储存匿名方法，
而没有直接呼叫它，要呼叫它的话，我们应该这么写 : 
AnonMeth (2)   
 
差异之处很明显，我们需要传递一个参数给这个方法。如果匿名方法没有
括号就更容易混淆了，如果我们这样宣告 : 
type  
   TAnyPr oc = reference to procedure;   
var 
   AnyProc: TAnyProc;  
 
呼叫 AnyProc 必须一定要写空括号了，不然的话编译程序会以为我们是要
取得该函式的参考，而不是要呼叫它：  
AnyProc ();   
 
当我们呼叫一个会回传匿名方法的含事实，类似的效应也会发生，就像以
下的案例 (节录自 AnonymFirst 范例项目 )： 
function GetShowMethod: TIntProc;   
var  
   x: Integer;  
begin  
    x := Rand om (100);  
    ShowMessage ('New x is ' + IntToStr (x));  
    Result :=  
       procedure (n: Integer)  
       begin  
           x := x + n;   
           ShowMessage (IntToStr (x));  
       end;  
end;   
 
现在问题只剩我们是怎么呼叫它的 ?如果我们简单的直接呼叫 : 
GetShowMethod;  
 
编译会通过，也可以执行，但实际上 执行的动作只是进行了匿名方法指派
的动作，把匿名方法从该函式回传回来而已。   
 458 我们要怎么真正呼叫到匿名方法，并将参数传递进去呢 ?选项之一，是使用
暂存的匿名方法变量：  
var 
  ip: TIntProc;  
begin  
   ip := GetShowMethod();  
   ip (3);  
 
请留意这个情况下，在 GetShowMethod 函数调用后面的小括号。如果我们
省略不输入这个小括号 (标准 Pascal语法是可以忽略小括号的 )， 就会出现以
下的错误讯息 : 
E2010 Incompatible types: 'T IntProc' and 'Procedure'   
 
把小括号省略掉，编译程序会以为我们想要指派 GetShowMethod 函式，而
不是呼叫它所储存的 ip方法指标。同样的，使用暂存变量也可能是这个案
例的最佳选项，同时也把程序不由自主的变得复杂了些，单纯呼叫 : 
GetShowMethod(3);  
 
这样是不能通过编译的，因为我们不能把参数传递到方法里面，我们得在
第一个呼叫上面先加上一个空的小括号，然后再把整数参数写在第二个小
括号里面，实在够奇怪的，变成要这样写 : 
GetShowMethod()(3);  
 
替代解决方法之一，是使用匿名函式的内部实作，并且呼叫低层的 Invoke
方法， 它是由编译程序所附加的 (在这个案例里， 就可以省略空的小括号了 ): 
GetShowMethod.Invoke (3);  
 
  匿名方法实作  
Invoke方法是什么 ?在匿名方法实作的背地里，到底发生了什么事 ?由编译
程序所建立的程序代码是基于接口，透过名为 Invoke的单一呼叫函式，加
上常用的参考技术技术 (这对于决定匿名方法以及其实质内容的生命周期
相当有用 )。 
 
我们可以在编辑器里面看到这些接口方法，假如我们使用了程序代码自动
完成的技术，用图 15.1所示的方法。深入内部实作的细节可能会很复杂，
且得到的知识相对有限。我只想说，这样的实作是很有效率的，而且每个
匿名方法只需要大概多 500个字符。   
 459 _________________________________________________________________________  
 
 
  
 
 
换句话说，在 Object Pascal 里面，方法参考是以特别的方法接口来实作的，
透过编译程序产生的方法具备了相同的特征，而让方法参考来使用。接口
的好处则是具备了参考计数以及自动释放的功能。  
_________________________________________________________________________  
虽然用来实作匿名方法的接口看起来跟其他接口没什么差别，但编译程序
仍然会把这两种接口自行做出区隔，所以我们可以在程序代码当中把两者
混在一起使用。  
 
除了隐藏式的接口，每一次呼叫匿名方法时，编译程序就会建立一个隐藏
的对象，储存匿名方法的程序代码与其所使用的相关内容。这也是为什么
我们在每次呼叫匿名方法的时候，都会得到一组被保留的变量了。  
 
  预先准备好的参考型别  
每当我们 把一个匿名方法用作参数时，我们就需要定义一个相对的参考指
针数据型别。避免这种区域型别不断增加， Object Pascal 提供了一些预先准
备好的参考指标型别，就放在 SysUtils 单元文件里面。我们可以看一下下
面的程序片段，大多数的型别定义都使用了参数化的型别，所以透过以下
任何一种通用的宣告，我们都可以用来定义任一种可能的数据型别的参考
指针型别：  
type  
   TProc = reference to procedure;   
   TProc<T> = reference to procedure (Ar g1: T);   
   TProc<T1,T2> = reference to procedure (   
      Arg1: T1; Arg2: T2);   
   TProc<T1,T2,T3> = reference to procedure (   
      Arg1: T1; Arg2: T2; Arg3: T3);   
   TProc<T1,T2,T3,T4> = reference to procedure (   
      Arg1: T1; Arg2: T2; Arg3: T3; Arg4 : T4);  
 
使用这些宣告，我们可以定义以下的匿名方法参数：  
 圖15.1: 
GetShowMe
thod啟動程
式碼自動完成
的畫面  
筆記   
 460 procedure UseCode (proc: TProc);   
function DoThis (proc: TProc): string;   
function DoThat (procInt: TProc<Integer>): string;   
 
在前两个案例中，我们是传递不需要参数的匿名方法，在第三个案例中，
则是传递一个要求一个整数参数的匿名方法 : 
UseCode (  
   procedure  
   begin  
      ...  
   end);   
strRes := DoThat (  
   procedure (I: Integer)  
   begin  
      ...  
   end);   
 
同样的，在 SysUtils 单元文件里面还定义了一系列匿名方法的型别，这些
型别会回传一个通用的回传值 : 
type  
   TFunc<TResult> = reference to function: TResult;   
   TFunc<T,TResult> = reference to function (   
   Arg1: T): TResult;  
   TFunc<T1,T2,TResult> = reference to function (   
     Arg1: T1; Arg2: T2): TResult;   
   TFunc<T1,T2,T3,TResult> = reference to function (   
     Arg1: T1; Arg2: T2; Arg3: T3): TResult;   
   TFunc<T1,T2,T3,T4,TResult> = reference to function (   
     Arg1: T1; Arg2: T2; Arg3: T3; Arg4: T4): TResult;   
   TPredicate<T> = reference to function (   
            Arg1: T): Boolean;  
 
这些定义很广泛，我们可以任选需要一到四个参数的匿名方法，而这个匿
名方法还可以包含回传值。最后一个定义跟第二个很像，但它用来处理的
情形是比较常见的一个特殊案例，是接受一个通用参数，并回传布尔值的
函式。  
 
  
 461 实战上的匿名函式  
第一眼看上去，不太容易看出匿名 方法的强大威力以及在什么情形下使用
匿名方法才是最适合的。这就是我决定把重点放在一些实务上的影响，并
开始提供进一步说明，而不要再提更多涵盖程序语言功能的实例了。  
 
  匿名事件处理程序  
Object Pascal 最明确的功能之一， 就是它使用了方法指标来实作事件处理程
序。匿名方法可以用来跟新的行为、事件进行绑定，而无需宣告一个独立
的方法也无须实作该方法。这样一来就可以让窗体省下一个额外字段，不
用把参数从一个方法传到另一个方法去。  
 
我们再来看另一个范例 (AnonButton) ， 我已经在范例中的按钮上加入了一个
匿名的点击事件，宣告一个适当的方法指标型别，并为一个自定的按钮类
别(使用中介类别定义 )加入一个新的事件：  
type  
   TAnonNotif = reference to procedure (Sender: TObject);   
 
   // interceptor class  中介类别  
   TButton = class (FMX.StdCtrls.TButton)   
   private   
      FAnonClick: TAnonNotif;  
      procedure SetAnonC lick(const V alue: TAnonNotif);   
   public   
      procedure Click; override;   
   public   
      property AnonClick: TAnonNotif  read FAnonClick write SetAnonClick;   
end;   
_________________________________________________________________________  
中介类别是和其基础类别有着 相同名称的衍生类别。让两个类别有相同的
名称是可能的，因为只要这两个类别位于不同的单元文件里面，他们的完
整名称 (单元文件名 .类别名称 )就会不同。宣告中介类别是很容易的，就像
我们把一个按钮组件放到窗体上，然后再加一些控制事件的逻辑上去那么
简单，不用在 IDE里面安装什么组件了。唯一要注意的事项只有一个，就
是要记得如果使用了中介类别，它一定是宣告在另一个单元文件里面，记
得要使用中介类别的单元文件必须 use宣告该类别的单元文件才行。  
 筆記   
 462 这个类别的程序代码相对的简单， 只有在 Click方法被呼叫的时候在标准处
理程序进行前 ， 把新的指标存起来而已 (也就是呼叫 OnClick事件处理程序，
如果它有被定义的话 ): 
procedure TButton.SetAnonClick(const V alue: TAnonNotif);   
begin   
    FAnonClick := V alue;  
end;  
procedure TButton.Click;  
begin  
    if Assigned (FAnonClick) then   
      FAnonClick (self)   
      inherited;  
end;  
 
我们要怎 么使用这个新的事件处理程序呢 ?基本上我们可以指派一个匿名
方法给它 : 
procedure TFormAnonButton.btnAssignClick( Sender: TObject);   
begin  
   btnInvoke.AnonClick :=  
   procedure (Sender: TObject)  
   begin  
      Show ((Sender as TButton).Text);   
   end;   
end;   
 
现在看起来这写法没有什么重点，因为相同的效果可以用标准的事件处理
程序来达成。不过接下来就有点不同了，匿名方法储存一个组件的参考，
然后把它传递给事件处理程序，透过参考 Sender这个参数来达成。  
 
这也可以在它暂时指派给一个局部变量来完成，因为匿名方法的 Sender参
数会把 btnKeepRefClick 方法的 Sender参数隐藏起来 : 
procedure TFormAnonButton.btnKeepRefClick( Sender: TObject);   
var 
   aCompRef: TComponent;  
begin  
   aCompRef := Sender a s TComponent; btnInvoke.AnonClick :=   
   procedure (Sender: TObject)  
   begin   
 463        Show ((Sender as TButton).Text +  
            ' assigned by ' + aCompRef.Name);  
   end;   
end;   
 
当我们点击了 btnInvoke 按钮，我们会看到被指派给匿名方法处理程序的组
件名字被显示在窗口标题上。  
 
  计算匿名方法的时间  
开发人员常常会在已开发好 的程序代码里面加入计算时间的程序代码，用
来比较执行速度。假设我们有两段程序代码，想要比较看看它们执行上百
万次所花的时间，我们可以用以下的程序代码来做，这是第六章里面的
LargeString 范例项目里面节录出来的：  
procedure TForm1.Button1Click(Sender: TObject);   
var  
   str1, str2: string;  
   I: Integer;  
   t1: TStopwatch;  
begin  
   str1 := 'Marco ';  
   str2 := 'Cantu ';  
 
   t1 := TStopwatch.StartNew;   
   for I := 1 to MaxLoop do   
     str1 := str1 + str2;  
 
   t1.Stop;  
   Show('Length: ' + str1.Length.ToString);   
   Show('Concatenation: ' + t1.ElapsedMilliseconds.ToString);   
end;   
 
第二个方法的程序代码也很类似，但使用了 TStringBuil der类别，而不是直
接使用字符串连接。现在我们可以用匿名方法的长处来建立一个时间点，
然后把特定的程序代码当成参数传递，就像我载 AnonLargeStrings 范例项
目中已经改版的程序代码一样。  
 
不使用持续的计时程序代码一再计算，我们可以写一个方法，包含着计时 
 464 的程序代码，让程序代码被呼叫的时候可以呼叫不用小括号的匿名方法 : 
function TimeCode (nLoops: Integer; proc: TProc): string;   
var  
   t1: TStopwatch;  
   I: Inte ger;  
begin  
   t1 := TStopwatch.StartNew;   
   for I := 1 to nLoops do   
      proc;  
   t1.Stop;  
   Result := t1.ElapsedMilliseconds.toString;   
end;   
procedure TForm1.Button1Click(Sender: TObject);   
var  
   str1, str2: string;  
begin  
   str1 := 'Marco ';  
   str2 := 'Cantu ';  
   Show ('Concatenation: ' +  
     TimeCode (MaxLoop,  
       procedure ()  
       begin  
         str1 := str1 + str2;  
       end));  
   Show('Length: ' + str1.Length.ToString);   
end;   
 
请注意，如果我们执行了标准版的程序，以及使用匿名方法的版本，就会
从输出的结果发现当中明显的差异，匿名方法的版本可 以看出有大约 10%
左右的延迟。原因是没有能够直接执行区域程序代码，这个程序必须透过
虚呼叫匿名方法的实作方式。由于这个差异持续存在，测试程序的意义就
达到了。然而如果我们要追求较高的执行效率，使用匿名方法并不会比直
接写个一般函式的效率来的好。使用非虚拟方法指标的效能可能会介于这
两种作法之间。  
 
  线程的同步  
在多线程的应用程序中，如果需要更新用户接口，我们不可以直接去存取 
 465 视觉组件的属性 (或者内存内对象的属性 )，因为它们都是全局线程的一部
分，并不具备线程同步的机制。 Object Pascal 的视觉组件函式库事实 上并不
是”线程安全 (Thread -Safe)”(但大多数的用户接口函式库则是 )。两个线程同
时企图存取同一个对象，会使该对象的状态被混淆。  
 
传统的解决方法是由 Object Pascal 的TThread 类别所提供，是透过呼叫一
个特别的方法 : Synchronize ，我们把指向另一个方法的参考当成参数传给这
个特别的方法，这个被作为参数传入的方法就会被安全的执行。被传入的
参数不能要求参数，所以实务上我们通常会在线程类别中加入一个额外的
字段当成传递信息的媒介。  
 
在Mastering Delphi 2005 这本书当 中，我曾写过一个叫做 WebFind 的范例
项目当成例子 (这个程序会透过 HTTP搜寻 Google的内容， 然后把搜寻结果
里面的网址从 HTML里面解析出来 )，用以下的线程类别来使用 : 
type  
   TFindWebThread = class(TThread)   
   protected   
      Addr, Text, Status: string;   
      procedure Execute; override;   
      procedure AddToList;   
      procedu re ShowStatus;   
      procedure GrabHtml;   
      procedure HtmlToList;   
      procedure HttpWork (Sender: TObject;   
         AWorkMode: TWorkMode; AWorkCount: Int64);   
   public   
      strUrl: string;  
      strRead: string;  
end;  
 
保护区的三个字符串字段跟一些额外的方法已经被介绍成支 持用户接口同
步的功能。举例来说， HttpWork 事件处理程序会跟内部的 IdHTTP对象 (这
是Indy的组件之一，提供 HTTP客户端协议的功能 )的事件绑定，程序代码
如下，它会呼叫 ShowStatus 方法 : 
procedure TFindWebThread.HttpWork(Sender: TObject;   
  AWorkMode: TWorkMode; AWorkCount: Int64);   
begin  
   Status := 'Received ' + IntToStr (AWorkCount) +    
 466      ' for ' + strUrl;  
   Synchronize (ShowStatus);  
end;   
 
procedure TFindWebThread.ShowStatus;   
begin   
   Form1.StatusBar1.SimpleText := Status;   
end;   
 
Object Pascal 的Synchronize 方法有两个不同的多载定义：  
type  
   TThreadMethod = procedure of object;   
   TThreadProc edure = reference to procedure;   
   TThread = class  
     ... 
     procedure Synchronize(   
        AMethod: TThreadMethod); overload;   
     procedure Synchronize(   
        AThreadProc: TThreadProcedure); overload;   
 
为了这个原因，我们可以移除 Status文字字段以及 ShowStatus 方法，然后
用新版的 Synchronize 来重写 HTTPWork 事件处理程序跟一个匿名方法 : 
procedure TFindWebThreadAnon.HttpWork(Sender: TObject;   
   AWorkMode: TWorkMode; AWorkCount: Int64);   
begin  
   Synchronize (  
     procedure  
     begin  
        Form1.StatusBar1.SimpleText :=   
           'Received ' + IntToStr (AWorkCount) +  
           ' for ' + strUrl;   
     end);   
end;   
 
使用相同的目标来思考这个类别的程序代码，则线程类别变成以下所示 (我
们可以在本书范例程序代码的 WebFind 范例项目中找到这两种版本的线程
类别 ): 
  
 467 type  
   TFindWebThreadAnon = class(TThread)   
   protected   
      procedure Execute; override;   
      procedu re GrabHtml;   
      procedure HtmlToList;   
      procedure HttpWork (Sender: TObject;   
          AWorkMode: TWorkMode; AWorkCount: Int64);   
   public   
      strUrl: string;  
      strRead: string;  
   end;  
 
使用匿名方法简化了线程同步作业所需的程序代码。  
___________________________ ______________________________________________  
匿名方法跟线程有许多关连性，因为线程是用来执行某些程序代码的，而
匿名方法则是用来显示程序代码的。这也是为何 TThread 类别会支持匿名
方法，在平行程序函式库 (在TParallel.For 当中，以及定义一个 TTask的时
候)当中也支持。在本章里面介绍多线程之后，我不会在这方面再提供其他
的范例了。但在下一个范例中，我会使用另一个线程，因为在使用到 HTTP
联机的时候，使用线程来运作是很常见的要求。  
 
  Object Pascal里的AJAX 
这一节的前一个例子， AnonAjax 范例项目，是我最中意的匿名方法范例 (虽
然这个范例有点难度 )。理由是我学到使用 JavaScript 里面的 closure(或者我
们也可以叫他匿名方法 )来透过 jQuery函式库写 AJAX应用程序。  
_________________________________________________________________________  
AJAX是Asychronous Javascript XML 的简写，通常用来在浏览器里面呼叫
Web服务。这 个技术近年来越来越受欢迎，也被广泛使用， Web服务也逐
渐往 REST架构跟 JSON格式发展，因此 AJAX这个名词也开始慢慢失去
光环， REST成为了新一代的浪头。  
 
AjaxCall 全局函式会生出一个线程，然后把这个线程传给一个匿名方法，
让该匿名方法可以完整执行。函式只是一个用来包装线程建构函式的外壳
而已：  
type  
   TAjaxCallback = reference to procedure (   筆記  
筆記   
 468        ResponseContent: TStringStream);   
procedure A jaxCall (const strUrl: string; ajaxCallback: TAjaxCallback);   
begin  
    TAjaxThread.Create (strUrl, ajaxCallback);   
end;   
 
这些程序代码都在 TAjaxThread 类别中，这个线程包含一个内部的 Indy 
HTTP客户端组件用来浏览指定的 URL，当然是以异步形式进行 : 
type  
   TAjaxThread = class (TThread)  
   private  
      fIdHtt p: TIdHttp;   
      fURL: string;   
      fAjaxCallback: TAjaxCallback;   
   protected   
      procedure Execute; override;   
   public  
     constructor Create (const strUrl: string;  
         ajaxCallback: TAjaxCallback);   
     destructor Destroy; override;   
end;  
这个建构函式做了一些初始化的动作，复制它的参数到线程类别中对应的
字段， 并建立 fIdHttp对象。 这个线程类别实际执行的程序代码， 都在 Execute
方法里面，它会进行 HTTP要求，把结果储存在一个串流结构中，稍后会
进行重置，并把它传递给 callback函式 -一个匿名方法 : 
procedure TAjaxThread.Execute;   
var  
  aResponseContent: TStringStream;   
begin   
   aResponseContent := TStringStream .Create;   
   try  
     fIdHttp.Get (fURL, aResponseContent);   
     aResponseContent.Position := 0;   
     fAjaxCallback (aResponseContent);   
   finally  
     aResponseContent.Free;  
   end;   
end;    
 469 我们再拿 AnonAjax 范例项目来当一个例子， 它有一个按钮用来把网页内容
复制到一个 Memo组件上 (会在最开头加上要求的网址 ): 
procedure TFormAnonAjax.btnReadClick(Sender: TObject);   
begin   
   AjaxCall (edUrl.Text,   
      procedure (aResponseContent: TStringStream)   
      begin   
         Memo1.Lines.Text := aResponseContent.DataString;   
         Memo1.Lines.Insert (   
             0, 'From URL: ' + edUrl.Text);   
      end);   
end;   
 
等HTTP要求完成，我们就可以在上面做我们想要进行的任何处理了。  
 
另一个例子则是把 HTML文件里的连结解析出来 (这也算是把稍早的
WebFind 范例执行的结果进行重组 )。重申一下，要让这个函式更有弹性，
它可以要求一个匿名方法当做参数，这样每个连结就有独立的程序代码来
处理对应的数据了：  
type  
   TLinkCallback = reference to procedure (   
     const strLink: string);  
procedure ExtractLinks (strData: string; procLink: TLinkCallback);   
var 
   strAddr: string;  
   nBegin, nEnd: Integer;  
begin  
   strData := LowerCase (strData);  
   nBegin := 1;  
   repeat  
      nBegin := PosEx ('href="http', strData, nBeg in); 
      if nBegin <> 0 then  
      begin  
          // find the end of the HTTP reference   
          nBegin := nBegin + 6;   
          nEnd := PosEx ('"', strData, nBegin);   
          strAddr := Copy (strData, nBegin, nEnd - nBegin); // move on   
          nBegin := nEnd + 1;   
 470           // execute anon method  
          procLink (strAddr)  
      end;  
   until nBegin = 0;  
end;   
 
如果我们拿这个函式来处理 AJAX呼叫后的结果，然后提供另一个方法作
为进阶的处理， 我们实质上就会有两个巢状的匿名函数调用， 就像 AnonAjax
范例项目的第二个按钮 : 
procedure TFormAnonAjax.btnLinksClick(Sender: TObject );  
begin   
   AjaxCall (edUrl.Text,   
      procedure (aResponseContent: TStringStream)   
      begin   
         ExtractLinks(aResponseContent.DataString,   
            procedure (const aUrl: string)   
            begin   
                Memo1.Lines.Add (aUrl + ' in ' + edUrl.Text);   
            end);   
      end);   
end;   
 
在这个例子里， Memo组件会接收到一连串的连结，而不是回传网页的
HTML文字。上面这段程序代码所解析出来的连结也可以改成完全针对图
片的网址进行解析。 ExtractImages 函式就会从 HTML原始码里面抓出 img
卷标的 src属性，然后呼叫另一个 TLinkCallback 兼容的匿名方法 (请仔细阅
读程序代码，就能理解该函式的细节 )。 
 
现在，我们可以在背景开启一个网页 (透过 AjaxCall 函式 )，解析出当中的图
片网址，然后再呼叫一次 AjaxCall 把图片抓回来。这表示使用一个三层的
巢状匿名方法的程序代码，对一些 Object Pascal 开发人员来说可能会变得
很难懂 (这会需要一些时间来习惯 )，但这真的功能很强大，也很令人印象深
刻: 
procedure TFormAnonAjax.btnImagesClick(Sender: TObject);   
var  
   nHit: Integer;  
begin  
   nHit := 0;   
 471    AjaxCall (edUrl.Text,  
       procedure (aResponseContent: TStringStream)   
       begin   
          ExtractImages(aResponseContent.DataString,   
               procedure (const aUrl: string)   
               begin   
                  Inc (nHit);   
                  Memo1.Lines.Add (IntToStr  (nHit) + '.' +   
                     aUrl + ' in ' + edUrl.Text);  
                 if nHit = 1 then // load the first  
                 begin  
                     AjaxCall (aUrl,   
                         procedure (aResponseContent: TStringStream)   
                         begin   
                           // load image of the current type only  
                           Image1.Picture.Graphic.  
                              LoadFromStream(aResponseContent);   
                         end);   
                 end;   
               end);   
       end);   
end;   
_________________________________________________________________________  
这个程序片段是我在 2008年九月的部落格文章中，标题为 ”Anonymous, 
Anonymous, Anonymous” ，当中也有一些网友的想法交流，读者可以上网看
原文 : http://blog.marcocantu.com/blog/anonymous_3.ht ml。 
 
除了只能在图片组件中以同样的格式加载 文件时，才能让图片显示这一点
之外，上面这段程序代码跟执行的结果都令人印象深刻。  
 
请留意到编号的顺序是以被保留的局部变量 nHit为基础的。如果我们快速
点击了该按钮两次会如何 ?每一次匿名方法都会取得一份 nHit的数值， 然后
被用来显示在列表中，当第二个线程开始提供输出结果时，第一个线程的
结果可能还没出现呢。  筆記   
 472 16:镜射与标注  
 
基本上，强型别的编译程序，静态型别语言，例如 Pascal，在执行时期提供
的可用型别信息很少，甚至没有。所有关于数据型别的信息只有在编译过
程中可以被看的到。  
 
Object Pascal 的第一版就打破了这个传统， 它提供了属性与其他类别成员的
执行时期信息，只需透过一个特别的区段宣告关键词 :published 。这个类别
功能只要在编译程序时有加上 {$M+}这个编译设定即可，它同时也是 VCL
的DFM文件串流化机制的基础 (FireMonkey 函式库的 FMX文件也是使用
此一机制 )，在窗体与其他可视化组件的设计环境也是使用此一机制。在
Delphi第一版推出的时候，这功能算是整个程序设计工具业界最创新的想
法，后来许多程序开发工具也都用了各种不同的方法提供这个功 能，并把
这个功能加以延伸。  
 
首先，在型别系统中有延伸功能来为方法进行注记跟检测 (此功能仅有
Object Pascal 语言提供 )，以及在 COM面动态进行呼叫。在 Object Pascal
里面这功能仍然以 dispatch ID 进行支持，在方法中使用变异变量 (Variant)
以及其他跟 COM相关的功能。最后，在 Object Pascal 里面对 COM的支持
已经由程序语言内建的动态时期型别信息来外延支持了，但这已经超过本
书作为介绍程序语言功能的书该涵盖的范围了。  
 
后来系统管理环境的出现，像是 Java跟.NET，提出了一个很有延伸形式的
执行时期型别信息 (Run Time Type Information ，以后简称 RTTI)，透过由编
译程序把详细的 RTTI跟执行模块进行绑定， 程序中就可以对这些模块检测
与使用了。这有让内部程序代码跟模块的大小增加的副作用，但它也透过
新的程序模块，以及结合动态程序语言的一些弹性到固定结构、增加强型
别速度的优点。  
 
不管你喜欢与否 (在该功能被加入的时候，的确引发了激烈的争论 )，Object 
Pascal已经慢慢朝向相同的方向前进，并且提供 RTTI的延伸功能，使这个
方向的发展越发明显了。正如我 们看到的，我们可以选择不用 RTTI，但如
果我们使用 RTTI，则可以在应用程序中整合更多的功能进去。  
 
这个主题并不简单，所以我们会一步一步介绍。首先我们会先介绍新的延 
 473 伸RTTI，这功能已经内建在编译程序，我们可以透过使用 RTTI单元文件
来使用里面的新功能与类别。其次，我们应该也要留意到新的 TValue结构
跟动态呼叫的技术。第三，我会介绍自定标注，这个功能在 .NET上也有提
供，并且可以让我们可以延伸由编译程序产生的 RTTI信息。我们会在本章
的最后部分来探讨在延伸的 RTTI背后的理由，以及看一些使用 RTTI使用
的实际案例。  
 
延伸的 RTTI  
Object Pascal 编译程序默认就会建立许多延伸的 RTTI信息。执行时期信息
包含所有型别、包含类别与所有其他使用者定义的型别，都会像是系统提
供的核心数据型别一样提供相同层级的数据，并包含到私有区、保护区、
公开区、发布区的所有元素。这需要深入到任何一个对象的所有内部结构。  
 
  第一个范例  
在我们开始看到编译程序产生的信息以及几种不同存取这些信息的技术之
前，我们先直接跳去看结论，并看一下使用 RTTI可以达到什么功能吧。具
体的例子并不多，而且可能是以旧版的 RTTI写成的，但 这些例子可以让您
理解我所要介绍的想法 (也要考虑到并不是所有的 Object Pascal 开发人员都
使用传统的 RTTI来开发 )。 
 
假设我们有一个窗体上头放了一个按钮，就像 RttiIntro 范例项目。我们可
以用以下这段程序代码来读取控制组件的 Caption属性 : 
uses Rtti;   
procedure TFormRttiIntro.btnInfoClick(Sender: TObject);   
var  
   context: TRttiContext;  
begin  
   Show (context.   
      GetType(TButton).   
      GetProperty('Caption').   
      GetV alue(Sender).ToString);   
end;   
 
这段程序代码使用了 TRttiContext 记录来参考 TButton型别的信息， 从这个
型别的信息到 RTTI关于属性的数据， 以及这个属性的数据被用来参考到属
性的内容值，它被转型成为了一个字符串。如果您好奇这是怎么运作的， 
 474 请继续读下去。在这里我的重点是，这种方法现在不只可以用来动态的存
取属性，也可以读取数据字段的内容，包含 私有区的字段。  
 
我们还可以改变一个属性的值，就像 RttiIntro 范例项目中第二个按钮的动
作一样：  
procedure TFormRttiIntro.btnChangeClick(Sender: TObject);   
var  
    context: TRttiContext;  
    aProp: TRttiProperty;  
begin  
    aProp := context.GetType(TButton).GetProperty('Caption');   
    aProp.SetV alue( btnChange, StringOfChar (   
         '*', random (10) + 1));  
end;  
 
这段程序代码以随机长度的＊符号来取代 Caption的内容。 跟以上的程序代
码的不同点是它用了暂存的局部变量来参考属性的 RTTI信息。现在，您该
对于我们要介绍的想法有些轮廓了，我们先从检查由编译程序建立的延伸
RTTI信息开始。  
 
  编译程序产生的信息  
我们不用特别作什么，编译程序就会把这些额外信息加入到我们的执行档
(不论它的形式为何 : 应用程序、函式库、套件等 )。就开启一个项目， 然后
编译它。编译程序默认就会为所有数据字段 (包含私有区的字段 )以及公开
区、发布区的所有方法与属性建立延伸 RTTI。您可能会觉得惊讶， RTTI
居然也涵盖到私有区，但这是由于动态处理的需求，像是二进制对象的串
行化以及对在 heap内存区的对象进行追踪。  
 
我们可以用以下列表的设定值来控制延伸 RTTI的建立 :X轴代表成员的种
类， Y轴代表不同访问权限区。以下的列表是系统默认值 : 
 
 数据字段  方法  属性  
私有区  X   
保护区  X   
公开区  X X X 
发布区  X X X 
  
 475 技术上来说，这四个访问权限设定 是使用以下宣告在 System单元文件的集
合型别来进行对应的 : 
type  
   TVisibilityClasses = set of (vcPrivate,   
      vcProtected, vcPublic, vcPublished);   
 
系统中提供了一些预先定义好的常数值，可以和预设的 RTTI内容对应，这
些访问权限的可视范围是跟 TObject的可视设定关连， 所有的类别也都继承
了这些相同的权限：  
const  
   DefaultMethodRttiVisibility = [vcPublic,  vcPublished];   
   DefaultFieldRttiVisibility = [vcPrivate..vcPublished];   
   DefaultPropertyRttiVisibility = [vcPublic, vcPublished];   
 
编译程序是否要建立这些信息，可以用一个新的编译程序设定来处理：
$RTTI，这当中包含了一个状态，用来指示特定型别或它的衍生类别 (明确
指示或是继承 )，并以三个特定的关键词来标明方法、数据字段或者属性的
可视状态。在 System单元文件中的默认 值是 : 
{$RTTI INHERIT   
   METHODS(DefaultMethodRttiVisibility)   
   FIELDS(DefaultFieldRttiVisibility)   
   PROPERTIES(DefaultPropertyRttiVisibility)}   
 
要完整的关闭为所有类别的成员建立延伸 RTTI的话， 我们可以使用以下的
设定 : 
{$RTTI EXPLICIT METHODS([]) FIELDS([]) PROPERTIES([])}   
______________ ___________________________________________________________  
我们无法在单元文件的宣告之前设定 RTTI的设定值， 就跟其他编译程序设
定值一样，因为这些设定值的定义是在 System单元文件里面宣告的。如果
我们在单元文件最前面 (uses区段之前 )就写好编译程序设定值的话， 就会出
现内部错误，这看起来不太直觉。总之，就把它放在单元的指令之后吧。  
 
使用这个设定的时候，要记得它只会被套用在我们自己写的程序代码，而
且不可能完全移除，因为用于 RTL跟其他函式库的类 别的 RTTI信息已经
被编译到对应的 DCU文件跟套件文件里面了。同时也要记得， $RTTI设定
对于为已发布的型别所建立的传统 RTTI的建立不会有任何影响： 它还是会
建立，跟是否设定 $RTTI无关。  
 筆記   
 476 _________________________________________________________________________  
RTTI处理类别，是透过 RTTI单元文件，我们稍后的章节会加以介绍，它
是透过挂载在传统 RTTI跟它的 PTypeInfo 结构来达成的。  
 
我们可以透过这个设定值来停止为我 们自定的类别建立延伸 RTTI。 相对的，
我们也可以增加 RTTI要建立的范围，包含私有区、保护区的方法跟属性，
只要有需求的话 (虽然建立这些信息不一定都有实质用处 )。 
 
把延伸 RTTI加到执行档，最明显的影响就是执行档的 文件变大了 (大的文
件在进行散布的时候绝对算是一个缺点，因为额外的加载时间跟所使用的
内存对于程序执行来说并不很相关 )。现在，我们可以把 RTTI从我们的程
序代码当中的单元文件移除，重新编译后，就可以看出两者之间的差距了
(如果我们决定不要使用 RTTI这个技术的话 )。RTTI是个很强大的技术，从
本章的介绍 中就可以感觉的到，或者在大多数的状况下，它也值得多用一
些额外的空间。  
 
  强型别与弱型别连结  
我们还有什么方法可以让执行档的 Size变小一点吗 ? 有的， 虽然影响不大，
但绝对值得我们注意。  
 
当我们可以从执行 文件里面取得 RTTI信息， 要注意到编译程序加进去的信
息，有时候链接程序会这些信息给移除掉。预设情形下，没有被编译到执
行档的类别跟方法就不会建立延伸 RTTI(因为在此一情形下， 这些信息建了
也没用 )，因为也无法取得基础的 RTTI。另一种情况下，如果我们想要让所
有的延伸 RTTI都被建立，并可以被使用，我们就需 要把这些几乎没有用到
的类别跟方法进行连结。  
 
我们可以使用两个编译程序设定值来控制与执行文件链接的信息。第一个
是$WeakLinkRTTI 设定值，它在文件里面有完整的叙述。设定这个值，在
程序里面没有被使用到的型别以及该型别所属的 RTTI都会被从执行档当
中移除。  
 
或者我们也可以强制把所有型别，以及这些型别的延伸 RTTI透过
$StrongLinkTypes 这个编译程序设定值包进执行档里面。对很多程序来说，
这个效果可是很戏剧化的，不过执行档的大小也大概会多出一倍来。  
 
 筆記   
 477 RTTI单元文件  
如果为所有型别建立延伸 RTTI是Object Pascal 镜射功能的第一根柱子， 第
二根柱子是能够用简单、高阶的方式来浏览这些型别的能力 (多亏了
System.Rtti 单元文件 )，第三根柱子我们待会会介绍，就是对于自定标注的
支持，我们一个个来看吧。  
 
传统的 Object Pascal 程序可以 (现在还是可以喔 )使用 TypeInfo 单元文件里面
的函式来存取类别『发布区』的执行时期型别信息。这个单元文件定义了
一些低阶的数据结构跟函式 (都是以指针跟记录为基础 )， 并定义了一些高阶
的子程序来简化程序的运作。  
 
不同的是， Rtti单元文件则让使用 延伸 RTTI变得很容易，当中提供了一整
组的类别，包含了适当的方法跟属性。要存取不同的对象，进入点都是
TRttiContext 记录结构，当中有四个方法用来搜寻可用的型别 : 
function GetType (ATypeInfo: Pointer): TRttiType; overload;   
function GetType (AClass: TClass): TRttiType; overload;   
function GetTypes: TArray<TRttiType>;   
function FindT ype (const AQualifiedName: string): TRttiType;   
 
正如我们可以看到的，我们可以传递一个类别，以一个从型别所取得的
PTypeInfo 指标， 一个完整的名称 (包含从该类别被宣告的单元文件开始到型
别的完整名称，像是 ”System.TObject”) ，或者取得型别的完整列表，被定义
成一个 RTTI型别的数组，或者更精确的说，是定义成 TArray<TRttiType> 。 
 
我在以下的列表当中也有使用到最后的函式，是 TypesList 范例项目的版本简化 : 
procedure TFormTypesList.btnTypesListClick(Sender: TObject);   
var  
   aContext: TRttiContext;  
   theTypes: TArray<TRttiType>;  
   aType: TRttiType;  
begin  
    theTypes := aContext.GetTypes;  
    for aType in theTypes do  
       if aType.IsInstance then  
         Show(aTy pe.QualifiedName);  
end;   
  
 478 GetTypes 方法回传了数据型别的完整列表，但程序会过滤掉内容，只留下
型别所表示的相关类别而已。在这个单元文件里面大概有十几个类别所表
示的型别。  
_________________________________________________________________________  
RTTI单元文件是把类别型别当成 ”实体”或者”实体型别 ”(就像在
TRttiInstanceType 里面 )。这听起来有点容易混淆，就像我们平常把实际的
对象称为实体一 样。  
 
在型别列表里面的独立对象是属于从 TRttiType 衍生而来的一些类别。 我们
可以特别来看一下 TRttiInstanceType 类别型别，把上面的程序代码重写成
以下的程序片段 : 
for aType in theTypes do   
   if aType is TRttiInstanceType then   
     Show(aType.QualifiedName);  
 
这个范例的程序代码有些复杂，它会先建立一个字符串列表，把里面的元
素进行排序，然后建立一个 ListView 组件，使用 BeginUpdat e跟EndUpdate
来进行优化 (并且会用一个 try finally 区块把这些程序代码包起来， 确定最后
的动作一定会被执行到 )： 
var 
   aContext: TRttiContext;  
   theTypes: TArray<TRttiType>;  
   sList: TStringList;  
   aType: TRttiType;  
   sTypeName: string;  
begin  
   ListView1.ClearItems;  
   sList := TStringList.Create;  
   try 
     theTypes := aContext.GetTypes;  
     for aType in theTypes do  
       if aType.IsInstance then   
         sList.Add(aType.QualifiedName);   
     sList.Sort;  
     ListView1.BeginUpdate;  
     try 
        for sTypeName in sList do   
           (ListVie w1.Items.Add).Text := sTypeName;   筆記   
 479      finally  
       ListView1.EndUpdate;  
     end;   
   finally   
     sList.Free;  
   end;  
end;   
 
这段程序代码会建立一个数以百计的数据型别列表，实际的数字要看编译
程序的版本跟其使用的平台了，我们可以看一下图 16.1。当中从 RTTI单元
文件列出了影像列表型别，我们会在下一节里面加以介绍。  
_____________________________ ____________________________________________  
 
  
 
 
 
 
 
 
 
 
 
 
  在Rtti单元文件里面的 RTTI类别 
在以下的列表衷，我们可以看到类别继承关系的完整图表，这些类别都是
从TRttiObject 衍生出来的，它们都定义在 Rtti单元文件里面：  
TRttiObject (abstract)  
       TRttiNamedObject  
         TRttiType   
           TRttiStructuredType (abstract)   
             TRttiRecordType  
             TRttiInstanceType  
             TRttiInterfaceType  
           TRttiOrdinalType  
             TRttiEnumerationType  
           TRttiInt64Type  圖16.1: 
TypeList 範例
專案的執行結
果 
 
 480            TRttiInvokableType  
             TRttiMethodType  
             TRttiProcedureType  
           TRttiClassRefType  
           TRttiEnumerationType  
           TRttiSetType  
           TRttiStringType  
             TRttiAnsiStringType  
           TRttiFloatType  
           TRttiArrayType  
           TRttiDynamicArrayType  
           TRttiPointerType  
         TRttiMember  
           TRttiField  
         TRttiProperty  
               TRttiInstanceProperty  
             TRttiIndexedProperty  
             TRttiMethod  
           TRttiParameter  
           TRttiPackage  
         TRttiManagedField  
_________________________________________________________________________  
在Rtti单元文件的第一次实作衷， 并没有 RTTI对象可以存取被索引过的属
性(像TStringList 类别的 Strings[]那样 )。这是后来的版本才加上去的，现在
仍旧可以使用，也让运行时间型别信息得以真正的完整。  
 
  RTTI对象的生命周期管理以及 TRttiContext 记录 
如果看过了刚刚列出的 btnTypesListClick 方法的原始码，里头有些地方 看
起来应该是相当严重的错误。 GetTypes 呼叫的函式回传了一个型别的数组，
但那段程序并没有把内部的对象释放掉。 原因是 TRttiContext 记录结构变成
了所有被建立出来的 RTTI对象的拥有者。当这个记录被释放 (亦即程序执
行脱离了该函式 )，一个内部接口会明确的呼叫它自己的解构函式来释放掉
被建立出来的所有 RTTI对象。  
 
TRttiContext 记录事实上扮演了两个角色。一方面它控制了 RTTI对象的生
命周期 (我们刚刚介绍过 )，另一方面它也对 RTTI信息进行快取，因为每次
对RTTI信息进行搜寻时所需要的重建程序 是很昂贵的。 这也是为什么我们筆記   
 481 会想要把 TRttiContext 记录的参考的生命周期做一个延伸， 好让我们在存取
RTTI信息的时候可以不用重新建立它们 (重申一下，这些步骤是很花时间
的)。 
 
内部作业里， TRttiContext 记录使用了 TRttiPool 型别的一个全局缓冲区，
它使用了临界区 (Critical section, 这个名词我很习惯直接用英文，所以用这
个翻译字眼不知道恰不恰当 )来保证多线程的作业安全。  
___________________________________________________ ______________________  
在RTTI的缓冲机制里面也会发生多线程同时存取的意外， 相关的信息就直
接被写在 Rtti单元文件里面的批注文字。  
 
所以，精确的说， RTTI缓冲区是让所有的 TRttiContext 记录所共享的，因
此被保留着的 RTTI对象会一直被维持着， 直到所有内存里面的 TRttiContext
记录都被释放掉为止。让我引用一下该单元文件里面的批注 : 
{... working with RTTI objects without at least one context being a live is an error. Keeping at least one 
context alive should keep the Pool variable valid}   
{译文 : 想要不透过至少一个 context来让 RTTI运作，是会出错的。保持最少一个 context存在可以让 Pool
变量能够被正常使用 } 
 
换句话说，我们必须避免在释放了 RTTI内容之后还快取住，或是继续使用
RTTI对象。 以下是会导致内存违规存取的简单范例程序代码 (它也是节录自
TypesList 范例项目 ): 
function G etThisType (aClass: TClass): TRttiType;   
var  
   aContext: TRttiContext;  
begin  
    Result := aContext.GetType(aClass);   
end;   
procedure TFormTypesList.Button1Click(Sender: TObject);   
var  
   aType: TRttiType;  
begin  
    aType := GetThisType (TForm);  
    Show (aType.QualifiedName);  
end;  
 
简单的做个整理， RTTI对象是由内容所管理的，我们没办法让它随时保持
可以使用的状态。这个内容是一个记录，所以会自动被编译程序释放掉。筆記   
 482 我们可以看到一些程序代码是像这样来使用 TRttiContext 的: 
context := TRttiContext.Create;   
try  
   // use the context  
finally  
  context.Free;  
end;  
 
虚构的建构函式跟虚构的解构函式会设定内部的接口，这些内部接口则会
管理实际在背景使用到的数据结构，并把它设定成 nil来清除这些缓冲区。
然而，这个动作会对于区域型别，像是记录自动执行，这个动作不用特别
处理，除非我们用了指标来参照这些记录。  
 
  显示类别信息  
我们在运行时间中最想要进行检查的相关型别，当然是结构化的型别，例
如接口或记录。聚焦在这些实例上，我们可以参照这些类别之间的关系，
透过以下可以用在实例型别上的 BaseType 信息。  
 
存取型别当然是一个很有趣的开始，但相对的也是具备认识这些型别的内
容的能力中相对比较新的，包含它们的成员。当我们点击这些型别中的任
何一个 (我们在范 例中使用了 TPopup组件类别 )，程序就会显示一连串的属
性、方法，以及该型别的数据字段，我们透过三个分页加以呈现，请见图
16.2:  
_________________________________________________________________________  
 
 
 
  
 
 
 
 
 
 
 
 
 圖16.2: 在
TypesList 範
例專案中 所顯
示的詳細型別
資訊  
 
 483 第二个窗体的单元文件，可以用以延伸成为一个用在其他应用程序中通用
的的型别浏览器，当中有一个名为 ShowTypeInformation 的方法，可以浏览
特定型别当中的每一个属性、方法，以及数据字段，浏览的 方式则是把它
们加入到三个独立的列表，各自以不同的可视权限作为每个列表显示的内
容(pri会显示私有区， pro会显示保护区， pub则会显示公开区， pbl则是显
示发布区，这个显示的判别是写在 VisibilityToken 函式里面 ): 
procedure TFormTypeInfo.ShowTypeDetails(typename: string);   
var  
   aContext: TRttiContext;  
   aType: TRttiType;  
   aProperty: TRttiProperty;  
   aMethod: TRttiMethod;  
   aField: TRttiField;  
begin  
   aType := aContext.FindType(typename);   
   if not Assigned(aType) then   
     Exit;   
 
   LabelType.Text := aType.QualifiedName;   
   for aProperty in atype.GetProperties do   
      FormTypeInfo.LVProper ties.Items.Add.Text := aProperty.Name +  
         ': ' + aProperty.PropertyType.Name + ' ' +   
         VisibilityToken (aProperty.Visibility);   
   for aMethod in atype.GetMethods do   
      LVMethods.Items.Add.Text := aMethod.Name + ' ' +   
         Visibilit yToken (aMethod.Visibility);   
   for aField in aType.GetFields do   
      LVFields.Items.Add.Text := aField.Name + ': ' +   
         aField.FieldType.Name + ' ' +   
         VisibilityToken (aField.Visibility);   
end;   
 
我们可以继续解析这些属性所属的型别，来找出更深入的信息，取得该方
法的参数列表， 并 检测回传型别等等。 这个范例并不是要建立出完整的 RTTI
浏览器，只是要让我们知道，我们可以透过 RTTI的功能获得哪些信息。  
 
  
 484   套件中的 RTTI 
除了我们可以用来存取某个型别或者一系列型别的方法， TRttiContext 记录
也提供了另外一个很有趣的方法 ”GetPackages” ，这个方法可以回传目前应
用程序有使用到的运行时间套件列表。如果我们在一个没有使用任何运行
时间套件应用程序里面呼叫这个方法，回传值的内容就只会有目前的执行
档而已。但如果我们在一个使用了许多运行时间套件的应用程序里面呼叫
它，回传值的内容 就会是这些套件的清单。从这个信息，我们就可以深入
到每个套件里可以使用的型别。请留意到这个案例中，型别的清单可能会
非常冗长，因为 RTL跟视觉组件函式库当中没有被使用到的型别并不会被
链接程序自动排除。  
 
如果我们使用了运行时间套件，我们也可以取得每个套件当中所有型别的
清单 (也包含执行文件自己 )，我们可以使用以下的程序代码 : 
var 
   aContext: TRttiContext;  
   aPackage: TRttiPackage;  
   aType: TRttiType;  
begin  
   for aP ackage in aContext.GetPackages do   
   begin   
      ListBox1.Items.Add('PACKAGE ' + aPackage.Name);   
      for aType in aPackage.GetTypes do   
         if aType.IsInstance then  
         begin  
            ListBox1.Items.Add('   - ' + aType.QualifiedName);  
         end;  
      end;   
_________________________________________________________________________  
Object Pascal 的套件可以用来为开发环境加入视觉组件，就像我们在 11章
里面介绍过的。然而，套件也可以只在运行时间使用，把主要的执行档跟
几个运行时间套件一起散发，不用把所有的程序代码组合成一个单一的执
行文件。如果您对 Windows 开发还算熟悉，可以把套件想象成是 DLL文件
的角色 (这些套件在技术上的确也是 DLL文件 )，或者我们也可以把它想成
是.NET的二进制文件。不过套件在 Windows 上面扮演了重要的角色，但在
行动平台上却是不支持的 (也是跟操作系统对应用程序的散发限制有关，例
如iOS就不允许应用程序进行动态链接 )。 
 筆記   
 485 TValue 结构 
新的延伸 RTTI不只让我们可以对程序内部结构进行浏览， 还提供了特定的
信息， 包含属性和数据字段值。 在 TypInfo单元文件提供了名为 GetPropValue
的函式可以存取一般的属性，并以当中的值存取其对应的变异型别，新的
Rtti单元文件则使用了不同的结构来处理这一类没有特别定义型 别的元素，
这个结构称为 TValue记录。  
 
这个记录几乎可以储存 Object Pascal 里面所有的数据型别，并且可以追踪
它的原始数据表示方式，它的作法则是同时记录数据与其数据型别。因此
我们就可以对该变量指定的型别进行读写。如果我们把整数写进 TValue，
我们读出的就只能是整数型别了，如果写进去的是字符串的话，读出来的
也就会是字符串。 (在XE6之后， FireMonkey 里面的 TGrid就已经使用 TValue
来设定每个 Cell的内容，所以不像以往有分成 TStringGrid 等不同型别，
TGrid就涵盖了所有型 别的 Grid)。 
 
但TValue不能提供不同型别之间的格式转换，因此就算 TValue有提供
AsString 与AsInteger 方法， 我们也只能在 TValue的内容的确是字符串时使
用AsString，而在 TValue内容的确是整数的时候才能使用 AsInteger 。举例
来说，在以下的案例里，我们可以使用 AsInteger 方法，如果我们呼叫
IsOrdinal 方法的话，回传值就会是 True:  
var 
   v1: TV alue;  
begin  
   v1 := 100;  
   if v1.IsOrdinal the n 
     Log (IntToStr (v1.AsInteger));  
 
然而，我们不能使用 AsString 方法，强制使用的话，会导致一个 invalid 
typecast例外 : 
var 
   v1: TV alue;  
begin  
    v1 := 100;  
    Log (v1.AsString);  
 
不过，如果我们需要使用字符串来表示 TValue的内容，则可以用 ToString
方法，这个方法里面有一个 case判别逻辑，可以把大多数数据型别的内容 
 486 煮换成字符串：  
var 
   v1: TV alue;  
begin  
   v1 := 100;  
   Log (v1.ToString);  
 
我们可以阅读以下 Barry Kelly 所写的这段文字， 增进对 RTTI的了解， Barry
是前 Embarcadero 研发人员，他的工作主要就是 RTTI： 
TV alue是个型别，可以用来存取以 RTTI为基础的方法，并且读写
相关的数据字段与属性。  
这个型别跟变异型别 (V ariant)类似，但其工作原理更偏向 Object 
Pascal的型别系统。举例来说，实体可以被直接储存，像是集合
(set)、类别参考等等。它也是更具局限性的型别，并 且不会 (例如 )
在背景进行字符串对数字的转换。  
 
现在我们对 TValue的角色应该有更深一层的理解了，让我们来看一下
TValue记录的实际能耐吧。它具备一组高阶的方法，可以指派、解析出实
际的内容，也包含一组低阶的以指标为基础的方法。我们接下来会集中篇
幅在高阶方法上。  
 
在指派内容时， TValue定义了许多个 Implict运算方法，让我们可以直接在
程序代码里面把特定的值指派给 TValue型别的变数：  
class operator Implicit(const V alue: string): TV alue;   
class operator Implicit(V alue: Integer): TV alue;   
class operator Implicit(V alue: Extended): TV alue;   
class operator Implicit(V alue: Int64): TV alue;   
class operator Implicit(V alue: TObject): TV alue;   
class operator Implicit(V alue: TClass): TV alue;   
class ope rator Implicit(V alue: Boolean): TV alue;   
 
这些运算方法所做的，就只是呼叫泛型类别方法 From而已 : 
class function From<T>(const V alue: T): TV alue; static;   
 
当我们呼叫这些类别函式的时候，我们需要确定数据型别，并传递一个该
型别的数据过去，像是以下的程序代码，会透过上述的这些类别方法，把
整数值 100进行指派 : 
v1 := TV alue.From<Integer>(100);    
 487 这是一系列的统一技术，用来把所有型 别的数据搬移到 TValue型别的变数
里去。一旦资料被指派完成，我们就可以用以下的几个方法来检测该数据
的实际型别了 : 
property Kind: TTypeKind read GetTypeKind;   
function IsObject: Boolean;   
function IsClass: Boolean;   
function IsOrdinal: Boolean;   
function IsType<T>: Boolean; overload;   
function IsArray: Boolean;   
 
请注意这里面的 IsType泛型方法，几乎可以用在任何数据型别上。  
对于解析出来的数据，也有对应的方法，但我们只能对 TValue里面储存的
数据使用型别兼容的方法，因为当中并不会有任何转换的动作发生：  
function AsObject: TObject;   
function AsClass: TClass;   
function AsOrdinal: Int64;   
function AsType<T>: T;   
function AsInteger: Integer;   
function AsBoolea n: Boolean;   
function AsExtended: Extended;   
function AsInt64: Int64;   
function AsInterface: IInterface;   
function AsString: string;   
function AsV ariant: V ariant;   
function AsCurrency: Currency;   
 
这些方法大多会同时有 Try的版本，会在执行时，如果发现型别不兼容时
回传 False，而不会触发例外事件。当中也有一些限制 转换的方法，最相关
的是泛型函式 Cast与ToString函式，我已经在范例中使用过它们了 : 
function Cast<T>: TV alue; overload;   
function ToString: string;   
 
  以TValue读取一个属性  
TValue的重要性，来自于这个结构会在存取属性或数据字段时，使用延伸
的RTTI与Rtti单元文件。作为使用 TValue的实际范例，我们可以用这个
记录型别来存取 TButton 对象发布区的属性与私有区的数据字段，请参考
以下的代码段 (节录自 RttiAccess 范例项目 ):  
 488 var 
   context: TRttiContext;  
   aType: TRttiType;  
   aProperty: TRttiProperty;  
   aV alue: TV alue;  
   aField: TRttiField;  
begin  
   aType := context.GetType(TButton);   
   aProperty := aType.GetProperty('Text');   
   aV alue := aProperty.GetV alue(Sende r);  
   Show (aV alue.AsString);   
 
   aField := aType.GetField('FDesignInfo');   
   aV alue := aField.GetV alue(Sender);   
   Show (aV alue.AsInteger.ToString);   
end;  
 
  呼叫方法  
新的延伸 RTTI并不只让我们存取值与数据字段， 它也让我们对于呼叫方法
有了更简化的方式。在这个例子中，我们必须为该方法的每个参数都定义
一个 TValue元素。我们在呼叫这样的方法 时，有个全局的函式叫做 Invoke
的可以使用 : 
function Invoke(CodeAddress: Pointer; const Args: TArray<TV alue>;   
    CallingConvention: TCallConv; AResultType: PTypeInfo): TV alue;   
 
作为更好的替代方案， 在 TRttiMethod 类别中就定义了一个简化版的 Invoke
多载版本：  
function Invoke(Instance: TObject;  const Args: ar ray of TV alue): TValue; overload;   
 
我们在以下的范例中，提供了两个方式来呼叫使用简化版的方法 (一个回传
一个值，第二个则要求一个参数 )，这些程序代码都是从 RttiAccess 范例项
目里面节录出来的 : 
var 
   context: TRttiContext;  
   aType: TRttiType;  
   aMethod: TRttiMethod;  
   theV alues: array of TV alue;   
 489    aV alue: TV alue;  
begin  
   aType := context.GetType(TButton);   
   aMethod := aType.GetMethod('ToString');   
   theV alues := [];   
   aV alue := aMethod.Invoke(Sender, theV alues);   
   Show(aV alue.AsString);   
 
   aType := context.GetType(TForm1);   
   aMethod := aType.GetMethod('Show');   
   SetLength (theV alues, 1); theV alues[0] := aV alue;   
   aMethod.Invoke(self, theV alues);   
end;   
 
使用标注  (Using Attributes)  
本章的第一个部分，是让我们能够对 Object Pascal 编译程序建立的延伸
RTTI能够有比较多的掌握，并透过介绍新的 Rtti单元文件，能多认识 Rtti
的存取能力。第二部分，我们终于要来介绍整个架构的关键之一 :定义自定
标注，以及透过特定方法来延伸编译程序所建立的 RTTI的可能性。我们接
下来会从比较抽象的观点来看这个技术， 然后说明这个技术对 Object Pascal
的重要性与其原因，而且我们会透过实例来看。  
 
  标注是什么？  
标注 (用Object Pascal 或C#的术语来说 )或批注 (用Java的习惯来看 )，是我
们可以在源代码里面加入的说明或指示，我们可以可以把它加入到型别 (数
据字段、方法、或者属性 (Property)) ，编译程序会把它跟产出的执行二进制
程序代码包在一起。这是通常用方括号进行的指示 : 
type  
   [MyAttribute]  
   TMyClass = cl ass 
     ...  
 
在开发环境中以工具读取这些信息，或者在最后的应用程序从运行时间中
读取这些信息，程序可以依照找到的信息来变更其规则。  
 
通常标注不是用来改变类别或对象的实际核心功能，而是让这些类别能够 
 490 在参与运作时能够有延伸特定功能的机制。把一个类别宣告为可串行化
(serializable) ，并不会影响到类别的任何功能，但会让串行化功能的程序代
码得知这个类别需要被串行化处理，以及该如何处理 (在这个例子里面，我
们需要透过标注来提供更多信息，或者在类别的数据字段或属性中建立更
进一步的标注 )。 
 
这完全就是局限版的 RTTI一开始被 Object Pascal 内部使用的方式。 被标示
为发布区的属性 (Property) ，可以被显示在开发工具的对象查看器当中，也
可以被串行化写成一个 DFM文件，同时也可以在运行时间被存取。标注
(Attribute) 开启了这个机制，使它更有弹性、也更为强大。目前使用上很复
杂，也很容易就误用，就像其他目前也很强大的程序语言功能一样。我并
不是要让大家放弃原本我们已经理解的面向对象程序设计的优点，而是期
望能从这些新的想法中跟原来的技术达到互补的效果。  
 
举例来说， 『员工』这个类别仍旧是从原有 的架构上，一定还是从个人的类
别中所衍生出来的， 『员工』这个对象还是会对该对象需要提供一个标识符
的字段，但我们可以 ”标注”这个『员工』类别需要跟数据库的特定数据表
进行对应，或者跟特定的运行时间窗体进行对应。所以我们可以透过继承
(是特定类别 )、拥有关系 (属于 )，以及标注 (标示为 )作为三种独立的机制，
我们可以在设计应用程序的时候，这三种机制都可以是需求来用上。  
 
当我们看过 Object Pascal 里面由编译程序功能支持的自定标注，并看了几
个案例以后，我刚介绍过的抽象想法应该就会变得比较容易懂了，至少这
是我的希望 。 
 
  标注类别与标注宣告  
我们要如何定义一个新的标注类别 (或者标注分类 )呢?我们必须从 System单
元文件里面的一个新类别 : TCustomAttribute 类别来衍生出新的类别：  
type  
   SimpleAttribute = class(TCustomAttribute)   
   end;   
 
我们为标注类别取的名字会变成在程序代码里面使用的标识符，我们可以
选 择 把标 注 加在 后 面作 为延 伸 。所 以如 果 我们 为 类别 命 名 为
SimpleAttribute ，我们可以在程序代码里面用 Simple或者 SimpleA ttribute
来使用这个类别。 因此 Object Pascal 里面不成文的规定， 为每个类别都以 T
开头来命名的这个规定，通常在使用标注的时候，就不使用了。   
 491 现在我们已经定义了一个自定的标注，我们可以把它应用在程序代码的任
何地方了 : 型别、方法、属性、数据字段，以及参数。使用标注的语法，是
把标注的名称用中括号包起来 : 
type  
    [Simple]  
    TMyClass = class(TObject)  
    public  
       [Simple]  
       procedure One;  
 
在上例中，我使用了 Simple这个标注加在整个类别跟一个方法上面。除了
名字，标注也支持一个或一个以上的参数。传递给标注的参数必须跟该标
注类别的建构函数声明相同，如果该标注类别有建构函式的话 : 
type  
  V alueAttribute = class(TCustomAttribute)   
  private   
     FV alue: Integer;  
  public  
     constructor Create(N: Integer);   
     property V alue: Integer r ead FV alue;   
  end;   
 
以下是把标注应用在一个参数的做法 : 
type  
    [V alue(22)]  
    TMyClass = class(TObject)  
    public  
       [V alue(0)]   
       procedure Two;  
 
要被传递给该类别的标注的值，必须是一个常数或表达式，因为常数或表
达式的内容在编译阶段就可以被解译出来了。这也是只有少数的数据型别 :
有序内容、字符串、集合，以及类别参考可以使用的原因。从正面来看，
我们可以用不同的参数来建立多种 重载版本的建构函式。  
 
注意一下， 我们可以把许多个标注只在同一个标识符上面， 就像在 RttiAtrrib
范例项目里面所做的，我们整理一下在这一节里面的代码段 : 
type   
 492    [Simple][V alue(22)]  
   TMyClass = class(TObject)  
   public  
      [Simple]  
      procedure One;  
      [V alue(0)]  
      procedure Two;  
   end;   
 
要是我们试着使用一个还没有定义的标注呢 (可能是因为在 uses区段使用了
别的单元文件所致 )，我们就会得到下面这个错误讯息了 : 
[DCC Warning] RttiAttribMainForm.pas(44): W1025   
   Unsupported language feature: 'custom attribute'   
 
事实上这个讯息只是说该标注会被忽略掉，所以我们得要留意到类似的警
告讯息里面，或者要更注意到是不是有 ”Unsupported language feature” 这样
的警告讯息出现，因为这个讯息已经跟错误没有两样了 (我们可以在项目设
定的画面中， Hint and Warning 设定页来调整要把这个情形看待成错误或是
警告讯息 ): 
[DCC Error] RttiAttribMainForm.pas(38):   
   E1025 Unsupported language feature: 'custom attribute'   
 
最后，跟其他类似的概念的实作方式做个比较，在标注的使用上目前机会
没有方法可以限制使用的范围，像是在宣告区段，标注可以用在型别上，
但不能用在方法上。然而在编辑器上面，标注在使用更名重购 (rename 
refactoring )的功能上几乎是完全可以使用，没有任何限制的。我们不只可以
更改标注类别的名字，系统还会自动在该标注被使用在完整的名字，以及
没有使用最终完整标注的地方帮我们补正。  
_________________________________________________________________________  
标注的重购，最初是由 Malcolm Groves 在他的部落格上所提出的 : 
http://www.malcolmgroves.com/blog/?p=554 。 
 
 
  浏览标注  
现在如果没有方法可以找到 哪些标注是有被定义过的，这些程序代码看起
来就完全没有用了，而且可能因为这些标注，在对象当中注入不同的规则
或行为。我们先来介绍第一部分吧。在 Rtti单元中的类别，让我们可以厘筆記   
 493 清哪些标识符有相关的标注。以下的程序代码是从 RttiAttrib 范例项目中节
录出来的，可以显示出跟目前的类别有关连的标注清单：  
procedure TMyClass.One;  
var 
   context: TRttiContext;   
   attributes: TArray<TCustomAttribute>;   
   attrib : TCustomAttribute;   
begin  
   attributes := context.GetType(ClassType).GetAttributes;   
   for attrib in attributes do   
      Form39.Log(attrib.ClassName);   
 
执行这个程序，输出结果如下：  
SimpleAttribute  
V alueAttribute  
 
我们可以在程序代码的 for-in循环里面做些修改，来解析出特定的标注型
别：  
if attrib is V alueAttribute then   
  Form39.Show (' -' + IntToStr   
    (V alueAttribute(attrib).V alue));   
 
要怎么得到透过特定的标注取得方法，或任何标注来取得 ?我们无法直接过
滤方法，但可以一一取得这些方法，检查其标注，然后看看是不是我们要
找的方法。为了协助这个作业，我已经写了这样的一个函式来检查每个方
法是不是支持特定的标注：  
type  
   TCustomAttributeClass = class of TCustomAttri bute;   
 
function HasAttribute (aMethod: TRttiMethod;   
    attribClass: TCustomAttributeClass): Boolean;   
var  
   attributes: TArray<TCustomAttribute>;   
   attrib: TCustomAttribute;   
begin  
   Result := False;   
   attributes := aMethod.GetAttributes;   
   for attrib in attributes do    
 494       if attrib.InheritsFrom (attribClass) then   
        Exit (True);   
end;   
 
HasAttribute 这个函式会被 RttiAttrib 程序用来检查特定的标注 : 
var 
   context: TRttiContext;  
   aType: TRttiType;  
   aMethod: TRttiMethod;  
begin  
   aType := context.GetType (TMyClass);   
   for aMethod in aType.GetMethods do   
     if HasAttribute (aMethod, SimpleAttribute) then   
       Show (aMethod.name);  
 
   for aMethod in aType.GetMethods do   
     if HasAttribute (aMethod, TCustomAttribute) then   
       Show (aMethod.name);  
 
这效果是列出特定标注的方法，会以更进一步的呼叫 Log，一如我在上述
的程序代码所列出的：  
Methods marked with [Simple] attribute   
One   
 
Methods marked with any attribute  
One  
Two  
 
我们一般所做的并不是简单的描述标注，而是对特定的标注类别加上一些
独立的行为，跟它原本的程序代码不同。举个实例，我们可以在上面的程
序代码里面注入特定行为 : 目标是呼叫有特定标注类别的所有方法， 先考虑
它们都是不需要参数的方法 : 
procedure  TForm39.btnInvokeIfZeroClick(Sender: TObject);   
var  
   context: TRttiContext;   
   aType: TRttiType;   
   aMethod: TRttiMethod;   
   aTarget: TMyClass;    
 495    zeroParams: array of TV alue;   
begin  
   aTarget := TMyClass.Create;  
   try 
     aType := context.GetTy pe(aTarget.ClassType);   
     for aMethod in aType.GetMethods do   
       if HasAttribute (aMethod, SimpleAttribute) then   
         aMethod.Invoke(aTarget, zeroParams);   
   finally  
     aTarget.Free;  
   end;   
end;   
 
这个程序片段所做的动作包含了建立一个对象、抓出该对象的型别，检测
特定的标注，最后呼叫 每个有标注为 Simple的方法。这跟从类别继承、实
作接口、或者写一些特定的程序代码来行使这个要求都不同，要取得新的
动作，我们只需要以特定的标注来为一个或多个方法进行加注。这并不式
说这个例子使得标注的使用异常明显 : 我们可以在本章的最后参照一些常
见的使用标注的模式，和一些实际的个案研究。  
 
 
虚拟方法拦截器  
有另一个相关的功能在延伸 RTTI被加入 Object Pascal 之后也被加入了， 这
个功能是对一个现存的类别可以透过虚拟方法来加以拦截的能力，只要对
现存的对象建立一个代理类别。换句话说，我们可以选一个已经存 在的对
象，然后修改它的虚拟方法 (可以一次只修改其中一个，或一次把全部都处
理掉 )。 
 
我们要怎么完成这一点 ?在标准的 Object Pascal 应用程序中，我们应该没办
法使用这个功能。如果我们需要让一个对象拥有不同的行为，就只能先衍
生一个子类别，然后在子类别里面修改程序代码来达成。而在函式库里面
则是完全不同的，因为函式库必须用很通用的方式来撰写，对对象的了解
不多，函式库可以操作，并且尽可能的降低对对象的负担。这就是在 Object 
Pascal里面加入虚拟方法拦截器的情境。  
___________________ ______________________________________________________  
我们可以从一则部落格的发文看到对于虚拟方法拦截器 (这部份我是比较
欠缺的 ): http://blog.barrkel.com/2010/09/virtual -method -interception  筆記   
 496 .html。 
在我们聚焦在可能的情境之前，我们先讨论技术本身吧。假设我们有一个
已经存在的类别，它带有至少一个虚拟方法，像下面的例子这样 : 
type  
   TPerson = class  
   ... 
   public  
      property Name: string read FName write SetName;   
      property BirthDate: TDate read FBirthDate write SetBirthDate;   
      function Age: Integer; virtual;  function ToString: string; override;   
   end;   
 
function TPerson.Age: Integer;  
begin  
   Result := Y earsBetween (Date, FBirthDate);   
end;   
 
function TPerson.ToString: string;   
begin   
   Result := FName + ' is ' + IntToStr (Age) + ' years old';   
end;   
 
现在， 我们可以做的就是建立一个 TVirtualMethodInterceptor 对象 (它是定义
在Rtti单元文件里面的一个新类别 )把它跟特定的类别绑定起来，成为一个
子类别的对象，把该 对象的固定类别变成动态类别 : 
var  
   vmi: TVirtualMethodInterceptor;   
begin  
   vmi := TVirtualMethodInterceptor.Create(TPerson);   
   vmi.Proxify(Person1);   
 
一旦我们有了 vmi对象，我们就可以用匿名方法，来为它安装处理程序到
特定的事件上 (onBefore, onAfter, 以及  onException) 。这些匿名方法会在任
何虚拟方法被呼叫前、被呼叫之后，以及万一在任何虚拟方法触 发了意外
的时候被驱动。以下是这三个匿名方法的特征：  
TInterceptBeforeNotify = reference to procedure( Instance: TObject; Method: TRttiMethod;   
  const Args: TArray<TV alue>; out DoInvoke: Boolean; out Result: TV alue);   
TInterceptAfterNotify = reference to procedure( Instance: TObject ; Method: TRttiMethod;    
 497   const Args: TArray<TV alue>; var Result: TV alue);   
TInterceptExceptionNotify = reference to procedure( Instance: TObject; Method: TRttiMethod;   
   const Args: TArray<TV alue>; out RaiseException: Boolean; TheException: Exception;   
   out Result: TV alue);   
 
在每个事件中， 我们可以取得该对象， 该方法的参考， 参数， 以及回传值 (有
时也可能没有回传值 )。在 OnBefore 事件中，我们可以设定 DoInvoke 参数
让标准的执行动作失效。在 OnExcept 事件中，我们可以取得意外事件的详
细信息。  
 
在InterceptBaseClass 范例中，范例中使用了上面的 TPerson类别，我拦截
了类别的虚拟方法，加入了以下的纪录程序代码 : 
procedure TFormIntercept.btnInterceptClick(Send er: TObject);   
begin   
   vmi := TVirtualMethodInterceptor.Create(TPerson);   
   vmi.OnBefore := procedure(Instance: TObject; Method: TRttiMethod;   
       const Args: TArray<TV alue>; out DoInvoke: Boolean;   
       out Result: TV alue)  
       begin  
          Show('Before calling ' + Method.Name);   
       end;   
   vmi.OnAfter := procedure(Instance: TObject; Method: TRttiMethod;   
       const Args: TArray<TV alue>; var Result: TV alue)   
       begin   
          Show('After calling ' + Method.Name);   
       end;   
   vmi.Proxify(Person1);  
end;  
 
注意到， vmi对象需要被维持到 Person1对象被使用结束为止，不然我们就
会使用一个动态类别，而该类别已经不能用了，最后我们就会呼叫到一个
已经被释放掉的匿名方法。在范例中，我把它存放在一个窗体的数据字段
中，就跟对象会参考到的数据一样。  
 
这个程序会透过呼叫它的方法以及检测基础类别的名称来使用对象 : 
Show ('Age: ' + IntToStr (Person1.Age));   
Show ('Person: ' + Person1.ToString) ;  
Show ('Class: ' + Person1.ClassName);    
 498 Show ('Base Class: ' + Person1.ClassParent.ClassName);   
在我们安装拦截器之前，输出结果是 : 
Age: 26  
Person: Mark is 26 years old  
Class: TPerson  
Base Class: TObject  
 
安装了拦截器之后，输出结果变成了 : 
 Before calling Age  
 After calling Age  
 Age: 26  
 Before calling ToString  
 Before calling Age  
 After calling Age  
 After calling ToString  
 Person: Mark is 26 years old  
 Class: TPerson  
 Base Class: TPerson  
 
请注意这个类别跟基础类别的名称完全一样，但事实上却是完全不同的两
个类别，它是用虚拟方法拦截器所制作的动态类别。纵使并没有官方的作
法可以把目标对象的类别恢复成原始的类别，该类别本身仍旧可以透过虚
拟方法拦截 器对象运作，也仍旧是该对象的基础类别。当然我们也可以硬
把正确的类别参考硬塞给该对象 (初始时是四个 Bytes)的类别数据 : 
PPointer(Person1)^ := vmi.OriginalClass;   
举个更难的例子，我们已经修改了 OnBefore 的程序代码，所以在这个案例
中，如果我们呼叫了 Age，它会回传特定的值，而把原来类别程序代码中
的动作给忽略掉 : 
vmi.OnBefore := procedure(Instance: TObject; Method: TRttiMethod;   
      const Args: TArray<TV alue>; out DoInvoke: Boolean;   
      out Result: TV alue)   
      begin  
         Show ('Before calling ' + Method.Name);   
         if Method.Name = 'Age' then   
         begin   
            Result := 33;   
            DoInvoke := False;  
         end;   
 499        end;   
输出结果跟原始版本的结果不同 (请记得 Age的呼叫跟相关的 OnAfter事件
都被忽略掉了 ): 
Before calling Age  
Age: 33  
Before calling ToString  
Before calling Age  
After calling ToString  
Person: Mark is 33 years old  
Class: TPerson  
Base Class: TPerson  
 
现在我们已经看过了虚拟方法拦截器的技术细节，我们可以继续厘 清在什
么情境下我们会想用这个功能了。再次重申，基本上在标准的应用程序中，
我们没有理由使用这个功能。但在大多数开发进阶的函式库，且需要为了
测试或处理对象的时候，会需要实作自定的行为。  
 
举例来说，这个功能就可以拿来作为单元测试函式库的基础，不过它只能
用在虚拟方法上面。我们也可以把这个功能和自定的标注一起使用，就可
以用来实作一个程序代码样式，像是面向导向程序一样 (Aspect Oriented 
Programming) 。 
 
RTTI 个案研究  
现在我们已经介绍过了 RTTI的基础，以及标注的使用，现在我们可以来看
一些使用这些技术的实际案例，好证明这些技术是有用的。在许多情境中，
更有弹性的 RTTI以及能够使用自定标注都是相关连的， 但是我们没有足够
的篇幅一一列出这些情形。所以我们会用两个简单但经典的案例让大家一
步步熟悉这样的开发方法。  
 
第一个范例程序，会展现使用标注来识别在类别中特定的信息。具体来说，
我们希望可以解析一个对象，该对象的类别是属于类别架构中的一员，并
且拥有说明与独特的代号，这个代号可用来参照到该对象。这可以用来处
理几种情形，像是描述储存在集合组件 (可能是泛型集合对象或是传统的集
合对象 )当中的对象。  
 
第二个范例则是串流的范例，特别是把对象串流到 XML文件中。我会以使
用发布区的 RTTI作为古典的目标开始介绍，接着介绍新的延伸 RTTI，最 
 500 后示范如何使用标注来自定程序代码，并让它变得更有弹性。  
  在ID跟描述上使用标注  
如果我们想要有一些方法可以让许多对象共享，最传统的作法就是定义一
个具备虚拟方法的类别，然后用这个类别作为基础类别来衍生几个不同的
对象，并重载这些虚拟方法。这个方法不错，但是在类别上还是有不少限
制，这些限制也会由于类别结构而产生，因为我们让这些对象拥有同一个
基础类别了。  
 
完全不同的风格 (当然有优点也有缺点 )是使用标注来为特定的类别、 方法货
属性进行标示。这个作法比较有弹性，而且并没有使用到接口，而是基于
一个相对比较慢，且容易出错的执行时期信息搜寻，和编译时期的解决方
法完全不同。这表示我们不崇尚这种以接口作为更高目标的程序风格，而
只是作为一个可能值得评估，以及在某些情形下使用的话可能会很有趣的
作法。  
 
  描述标注类别 (The Description Attribute Class)  
为了这个范例，我已经定义了会被应用到的标注，作为可以被搜寻的元素。
我们可以使用三个不同的标注，但应该要避免污染命名空 间的标注。以下
是标注类别的定义：  
type  
   TDescriptionAttrKind = (dakClass, dakDescription, dakId);   
   DescriptionAttribute = class (TCustomAttribute)   
   private   
      fDak: TDescriptionAttrKind;  
   public  
      constructor Create (aDak: TDescriptionAttrKind = dakClass );  
      property Kind: TDescriptionAttrKind read fDak;   
   end;   
 
注意到，建构函式的使用透过他的唯一一个默认值的结构，让我们使用不
带参数的标注。  
 
  简单的类别  
接下来，我写了两个使用标注的简单类别。每个类别都用标注来标示，并
且有两个方法以相同的标注，但不同的自定方式来标示。第一个 (TPerson) 
 501 拥有对应到 GetName 函式的描述，并且使用了它的 TObject.GetHashCode
方法来提供了一个 (暂时性的 )代号，把该方法重新宣告来 套用这个标注 (这
个方法的程序代码我们简单的称之为继承版本 ): 
type  
   [Description]  
   TPerson = class  
   private  
     FBirthDate: TDate;  
     FName: string;  
     FCountry: string;  
     procedure SetBirthDate(const V alue: TDate);  
     procedure SetCountry(const V alue: string);  
     proc edure SetName(const V alue: string);  
   public  
     [Description (dakDescription)]   
     function GetName: string;   
     [Description (dakID)]   
     function GetStringCode: Integer;   
   published   
     property Name: string read GetName write SetName;   
     property BirthDate: TDate   
         read FBirthDate write SetBirthDate;   
     property Country: string read FCountry write SetCountry;   
   end;   
 
第二个类别 (TCompany) 相对的更简单，因为它有自己的代号跟描述 : 
type  
   [Description]  
   TCompany = class  
   private  
     FName: string;   
     FCountry: string;   
     FID: string;   
     procedure SetName(const V alue: string);   
     procedure SetID(const V alue: string);   
   public  
     [Description (dakDescription)]   
     function GetName: string;    
 502      [Description (dakID)]   
     function  GetID: string;   
   published   
     property Name: string read GetName write SetName;   
     property Country: string read FCountry write FCountry;   
     property ID: string read FID write SetID;   
   end;   
 
虽然这两个类别有点相似，但他们在类别架构上、一般接口、或是任何面
向都是完全不相干的。它们只共享了相同 名字的标注而已。  
 
  简单的专案与浏览标注  
标注的分享是用来显示被加入一个列表中的对象的相关信息，这个列表宣
告在程序的主窗体里面 : 
fObjectsList: TObjectList<TObject>;   
 
这个列表会在程序启动时被建立，并进行初始化 : 
procedure TFormDescrAttr.FormCreate(Sender: TObject);   
var  
   aPerson: TPerson;  
   aCompany: TCompany;  
begin  
   fObjectsList :=  TObjectList<TObject>.Create;   
   // add a person   
   aPerson := TPerson.Create;   
   aPerson.Name := 'Wiley';   
   aPerson.Country := 'Desert';   
   aPerson.BirthDate := Date - 1000;   
   fObjectsList.Add(aPerson);   
 
   // add a company   
   aCompany := TCompa ny.Create;   
   aCompany.Name := 'ACME Inc.';   
   aCompany.ID := IntToStr (GetTickCount);   
   aCompany.Country := 'Worldwide';   
   fObjectsList.Add(aCompany);   
  
 503    // add an unrelated object   
   fObjectsList.Add(TStringList.Create);   
 
要显示跟这个对象相关的信息 (通常是有被命名的 代号跟描述，如果有定义
的话 )，在程序中使用了透过 RTTI功能进行的标注寻找功能。首先，使用
了助手函式来判断该类别是否有被以特定的标注进行标示：  
function TypeHasDescription (aType: TRttiType): Boolean;   
var  
   attrib: TCustomAttribute;  
begin  
   for attrib in aType.GetAttributes do   
   begin   
      if (attrib is DescriptionAttr ibute) then   
        Exit (True);   
   end;   
   Result := False;  
end;  
_________________________________________________________________________  
在这个案例里面，我们需要检查完整的类别名称， DescriptionAttribute ，则
不只检查『描述』内容，它是我们在套用标注时可以使用的标识符。  
 
如果这个案例符合条件，程序就会取得每个方法里面的每个标注，透过巢
式循环， 检查该标注是不是我们正在寻找的 : 
if TypeHasDescription (aType) then   
begin   
   for aMethod in aType.GetMethods do   
      for attrib in aMethod.GetAttributes do   
         if attrib is DescriptionAttribute then   
           ...  
 
在循环的核心中，有被标注的方法会被呼叫来读取作为回传值的两个暂时
字符串 (稍后会被显示在用户 接口上 ): 
if attrib is DescriptionAttribute then   
  case DescriptionAttribute(attrib).Kind of   
      dakClass: ; // ignore  
      dakDescription:  
         strDescr := aMethod.Invoke(anObject, []).ToString;   
      dakId:   筆記   
 504         strID := aMethod.Invoke(anObject , []).ToString;   
这个程序错在不该检查标注是否重复了 (因为如果多个方法被标示了同一
个标注的话，我们可能会建立一个例外事件 )。把前面提到的范例程序整理
一下，以下是完整的 UpdateList 方法 : 
procedure TFormDescrAttr.UpdateList;   
var  
   anObject: TObject;  
   context: TRttiContext;  
   aType: TRttiType;  
   attrib: TCustomAttribute;  
   aMethod : TRttiMethod;  
   strDescr, strID: string;  
begin  
   for anObject in fObjectsList do   
   begin   
      aType := context.GetType(anObject.ClassInfo);   
      if TypeHasDescription (aType) then   
    begin   
         for aMethod in aType.GetMethods do   
            for attrib in aMethod.GetAttributes do   
               if attrib is DescriptionAttribute then   
                 case DescriptionAttribute(attrib).Kind of   
                 dakClass: ; // ignore   
                 dakDescription: // should check if duplic ate attribute   
                      strDescr := aMethod.Invoke(   
                          anObject, []).ToString;  
                 dakId:  
                    strID := aMethod.Invoke(  
                       anObject, []).ToString;  
                 end;  
                 // done looking for attributes   
                 // should check if we found anything   
                 with ListView1.Items.Add do  begin   
                    Text := sTypeName;  
                    Detail := strDescr;  
                 end;  
             end;   
          end;    
 505 // else ignore the object, could raise an exception   
end;   
 
如果这个程序产生了不太有趣的输出结果，那么执行的方法一定会是相关
的，因为我把一些类别批注掉了，其中这些类别的两个方法又使用了同一
个标注，且已经让这些类别可以用外部的算法来进行处理。  
 
换句话说，这些类别并不需要特定的基础类别，不用实作接口，也不用任
何类别架构中提供任何内部程序代码，只需要这些类别在宣告的时候记得
使用标注就 行了。而管理这些类别的完全责任，则落在了外部的程序代码
身上。  
 
  XML串流 
有一个有趣且很有用的使用 RTTI的案例，是为对象建立一个外部的映像，
用来把它的状态储存到 文件，或者把它透过网络传递给另一个应用程序。
传统上， Object Pascal 达到这个目标的作法，是为对象的发布区属性进行串
流，同样的作法也用来建立 DFM文件。现在， RTTI让我们可以把对象的
实际数据进行储存，而不用透过外部接口。这功能更强大了，虽然它也带
来了一些额外的复杂度，例如对于内部对象的数据管理。再次强调，这个
范例只是为这个技术做一个 简单的示范，并没有深入探讨它的含意。  
 
这个范例包含有三个版本，而为了简化它，把它们放在同一个项目进行编
译。第一个版本是传统的 Object Pascal 作法，基于发布区的属性，其次则
是使用了延伸 RTTI跟数据字段的版本， 第三个则是使用标注来自定数据对
照方式。  
 
  当然要有的 XML Writer 类别 
为了协助建立这样的 XML，我已经以让 XmlPersist 范例以一个延伸版的
TTrivialXmlEriter 为基础，这个类别原本是我在撰写 Delphi 2009 Handbook
这本书的时候，为了介绍 TText Writer类别所做的范例。在这里我就不再对
它多做赘述了。 我只想说， 这个类别可以持续追踪它所开启的 XML节点 (感
谢字符串堆栈 )，然后依照后进先出的顺序关闭 XML节点。  
_________________________________________________________________________  
TTrivialXmlWriter 类别的原始码，可以从 Delphi 2009 Handbook 的范例找
到，网址是 :http://www.marcocantu.com/code/2009/Read erWriter.htm 。 
 筆記   
 506 我在原始的类别中加入了一些限制格式的程序代码，以及用来储存对象的
三个方法，基于我们在本节里面要介绍的三个不同作法，以下是类别的完
整宣告内容 : 
type  
  TTrivialXmlWriter = class   
  private   
     fWriter: TTextWriter;  
     fNodes: TStack<string>;  
     fOwnsTextWriter: Boolean;  
  public  
     constructor Create (aW riter: TTextWriter); overload;   
     constructor Create (aStream: TStream); overload;   
     destructor Destroy; override;   
     procedure WriteStartElement (const sName: string);   
     procedure WriteEndElement (fIndent: Boolean = False);   
     procedure W riteString (const sV alue: string);  
     procedure WriteObjectPublished (AnObj: TObject);   
     procedure WriteObjectRtti (AnObj: TObject);   
     procedure WriteObjectAttrib (AnObj: TObject);   
     function Indentation: string;   
  end;   
 
要了解这段程序代码的意义， WriteS tartElement 方法，会使用到 Indentation
方法来为让该行的节点可以留下两个空白，好让整个内部堆栈可以显示的
比较容易阅读 : 
procedure TTrivialXmlWriter.WriteStartElement( const sName: string);   
begin  
   fWriter.Write (Indentation + '<' + sName + '>');   
   fNodes.Push (sname);   
end;   
 
在范例项目中可以找到完整的程序代码。  
 
  传统以 RTTI为基础的串流  
在介绍过涵盖了所支持的类别之后，我们从基础开始吧，也就是把一个对
象用传统 RTTI将发布区的属性以 XML为基础格式进行储存。  
  
 507 WriteObjectPublished 方法的程序代码相当复杂，需要多一些说明。它是以
TypInfo单元文件为基础，且用了旧版 RTTI当中的低阶版本的方法来取得
特定对象发布区的属性 (参数 AnObj)，透过以下的程序代码 : 
nProps := GetTypeData(AnObj.ClassInfo)^.PropCount;   
GetMem(PropList, nP rops * SizeOf(Pointer));   
GetPropInfos(AnObj.ClassInfo, PropList);   
for i := 0 to nProps - 1 do   
   ...  
 
这段程序代码的功能，是要求一定数量的属性，配置适当大小的空间给数
据结构使用，并把发布区属性的信息填入这些数据结构。如果我们想知道
是否可以用低阶程序代码来做这些事情呢 ?发出这个问题的同时，我们就知
道为什么新版的 RTTI要被发展出来了。为了每一个字段，程序会把数字跟
字符串型别的属性内容解析出来，如果解析 出来的是任何子对象的话，也
会进一步解析这个子对象 : 
strPropName := UTF8ToString (PropList[i].Name);   
case PropList[i].PropType^.Kind of   
   tkInteger, tkEnumeration, tkString, tkUString, ...:   
   begin   
      WriteStartElement (strPropName);   
      WriteString (GetPropV alue(AnObj, strPropName));   
      WriteEndElement;   
   end;  
   tkClass:  
   begin  
      internalObject := GetObjectProp(AnObj, strPropName);   
      // recurse in subclass   
      WriteStartElement (strPropName);   
      WriteObjectPublished (internalObject as TPersistent );  
       WriteEndElement (True);  
   end;  
end;   
 
这里有点复杂，但为了范例，并让大家对传统方法有个概念，这应该是足
够的。  
 
为了示范这个程序的效果，我已经写了两个类别 (TCompany 跟TPerson)，
这两个类别是从前一个范例借过来的。然而现在 Company 对象有了一个额 
 508 外的 Person型别属性，叫做 Boss。在实际的世界，这可能很复杂，但在这
个范例中，这是很合理的假设。以下是这两个类别的发布区属性宣告 : 
type  
   TPerson = class ( TPersistent)  
     ... 
   published  
      property Name: string read FName write FName;   
      property Country: string read FCountry write FCountry;   
   end;   
 
   TCompany = class (TPersistent)  
     ... 
   published   
      property Name: string read FName write FName;   
      property Country: string read FCountry write FCountry;   
      property ID: string read FID write FID;   
      property Boss: TPerson read FPerson write FPerson;   
end;   
 
这个程序的主窗体有一个按钮，用来建立并连结这两个类别建立出来的两
个对象，并且把它们储存到一个 XML串流中，稍后我们会让它显示出来。
以下是串流化的程序代码 : 
ss := TStringStream.Create;   
xmlWri := TTrivialXmlWriter.Create (ss);   
xmlWri.WriteStartElement('company');   
xmlWri.WriteObjectPublished(aCompany);   
xmlWri.WriteEndElement;   
 
所产生的 XML内容如下 : 
<company>   
   <Name>ACME Inc.</Name>   
   <Country>Worldwid e</Country>   
   <ID>29088851</ID>   
   <Boss>   
     <Name>Wiley</Name>  
     <Country>Desert</Country>  
   </Boss>  
</company>    
 509  
 
  以新 RTTI建立的串流数据字段  
透过 Object Pascal 的高阶 RTTI功能， 我可以把旧的程序代码改写成使用延
伸RTTI来存取发布区的属性。而我所要做的，是使用它来把对象的内部表
示进行储存，也就是私有区的数据字段。我所做的不只是更为核心的事情，
而且是使 用更为高阶的功能来达成的， WriteObjectRtti 方法完整的程序代码
如下 : 
procedure TTrivialXmlWriter.WriteObjectRtti(AnObj: TObject);   
var  
   aContext: TRttiContext;  
   aType: TRttiType;  
   aField: TRttiField;  
begin  
   aType := aContext.GetType (anObj.ClassType);   
   for aField in aTyp e.GetFields do   
   begin   
      if aField.FieldType.IsInstance then   
      begin   
         WriteStartElement (aField.Name);   
         WriteObjectRtti (aField.GetV alue(anObj).AsObject);   
         WriteEndElement (True);  
      end 
      else  
      begin  
          WriteStartElement (aField.Name);   
          WriteString (aField.GetV alue(anObj).ToString);   
          WriteEndElement;   
      end;   
   end;   
end;   
 
产生的 XML也很相似，只是相对的比较不清楚，因为数据字段的名称比属
性的名称更不清楚：  
<company>   
   <FName>ACME Inc.</FName>   
   <FCountry>Worldw ide</FCountry>    
 510    <FID>29470148</FID>   
   <FPerson>   
      <FName>Wiley</FName>  
      <FCountry>Desert</FCountry>   
   </FPerson>   
</company>   
 
然而另一个更大的不同，是在这个案例中，类别不需要从 TPersistent 类别
衍生而来，也不需要有任何特别的限制。  
 
  使用标注来自定串流化  
除了标签名称的问题以外，另外还有一个我还没提过的问题。使用 XML的
标签名会是很复杂 的标识符，这不是个好主意。同时，在这段程序代码里
面，无法从 XML串流的数据来排除特定的属性。  
_________________________________________________________________________  
Object Pascal 的属性串流可以透过 stored设定来控制，我们可以透过使用
TypInfo单元文件来读取它。再说一次，这个作法并不简单，也不明快，虽
然DFM串流机制把它运用的相当有效率。  
 
这些是我们可以用标注来加以厘清的问题，但它的缺点是在宣告类别的时
候大量使用标注，这种风格我并不喜欢。对于新版的程序代码，我已经透
过一个选用的参数定义了一个标注化的建构函式：  
type  
   xmlAttribute = class (TCustomAttribute)   
   private   
      fTag: string;  
   public  
      constructor Create (strTag: string = '');   
      property TagName: string read fTag;   
   end;   
 
标注化的串流程序代码 则是一个以最后一版，以延伸 RTTI为基础的演变。
唯一的不同是现在的程序会呼叫 CheckXmlAttr 助手函式来确认该数据字段
是否有 xml标注，以及选用的标签名称加以注释 : 
procedure TTrivialXmlWriter.WriteObjectAttrib(AnObj: TObject);   
var  
   aContext: TRttiContext;  筆記   
 511    aType: TRttiType;  
   aField: TRttiField;  
   strTagName: string;  
begin  
    aType := aContext.GetType (anObj.ClassType);   
    for aField in aType.GetFields do   
    begin   
       if CheckXmlAttr (aField, strTagName) then   
       begin   
          if aField.FieldType.IsInstance then   
          begin   
             WriteStartElemen t (strTagName);   
             WriteObjectAttrib (aField.GetV alue(anObj).AsObject);   
             WriteEndElement (True);   
          end 
          else  
          begin  
             WriteStartElement (strTagName);   
             WriteString (aField.GetV alue(a nObj).ToString);   
             WriteEndElement;   
          end;   
       end;   
    end;   
end;   
 
最相关的程序代码是在 CheckXmlAttr 助手函式里面的 : 
function CheckXmlAttr (aField: TRttiField; var strTag: string): Boolean;   
var 
   attrib: TCustomAttribute;  
begin  
   Result := Fal se;  
   for attrib in aField.GetAttributes do   
      if attrib is XmlAttribute then   
      begin   
         strTag := xmlAttribute(attrib).TagName;   
         if strTag = '' then // default value   
            strTag := aField.Name;  
         Exit (True);   
 512       end;   
end;   
没有 XML标注的数据字段会被忽略掉， 在 XML输出的标签是可以自定的。
为了示范这一点，程序中有以下的类别 (这一次我已经略过了发布区的属
性，因为它们没相关 ): 
type  
   TAttrPerson = class  
   private  
     [xml ('Name')]  
     FName: string;  
     [xml]  
     FCountry: string;  
     ... 
   TAttrCompany = class  
   private  
     [xml ('CompanyName')]  
     FName: string;  
     [xml ('Country')]  
     FCountry: string;  
     FID: string; // omitted  
     [xml ('TheBoss')]  
     FPerson: TAttrPerson;  
     ... 
 
透过这些宣告， XML输出值看起来会像以下这些 XML数据 (请注意到卷标
名称， ID是被忽略掉了，而预设的名称则是 FCountry 字段 ): 
<company>  
 <Co mpanyName>ACME Inc.</CompanyName>  
 <Country>Worldwide</Country>  
 <TheBoss>   
     <Name>Wiley</Name>  
     <FCountry>Desert</FCountry>  
 </TheBoss>   
</company>   
 
这里的不同是我们可以对哪些字段要被纳入 XML，以及如何在 XML里面
对它们进行命名很有弹性，而在前一版的作法则完全不能随意处理。  
  
 513 虽然这只是个骨架版本的实作，我还是希望读者们有机会能看一下如何一
步步的以传统 RTTI来建立出最后的版本， 这会让我们对于几个不同的技术
之间如何实作留下印象。而很重要，必须一定要记住的是，事实上，使用
标注并不一定是最好的解决方法。另一方面，很明显的 RTTI跟标注在任何
一种情境中都提供了许多威力跟弹性，我们需要透过这个技术才能在运行
时间对结构跟未知的对象进行了解。  
 
  其他以 RTTI为基础的函式库  
要为这一章做结论，我想指出一个事实，目前有一些函式库，包含内建在
Delphi与第三方的函式库，都已经开始并入延伸 RTTI了。一个很明显的例
子是表达式绑定的机制已经跟背景的可视化绑 定逐渐一致。我们可以建立
绑定表达式，把它指派给一个表达式 (例如 Text里的一个字符串，可以进行
处理，例如字符串连接 )，或是让该表达式参考到一个额外对象与其数据字
段。  
 
即使我不想太深入这个主题，它是一个很特定的函式库，并且不是 Object 
Pascal的一部分，也不是核心系统的一部分，我想用一个简单的列表来让大
家有这个概念 : 
var  
   bindExpr: TBindingExpression;   
   pers: TPerson;   
begin  
   pers := TPerson.Create;  
   pers.Name := 'John';  
   pers.City := 'San Francisco';  
 
   bindExpr := TBindingExpressionDefault.Create;   
   bindExpr.Source := 'person.name + " lives is " + person.city');   
   BindExpr.Compile([   
     TBindingAssociation.Create(pers, 'person')]);   
   Show (BindExpr.Evaluate.GetV alue.ToString);   
   pers.Free;   
   bindExpr.Free;  
end;  
 
注意到这段程序的优点来自于我们可以在运行时间改变表达式的内容 (虽
然在上面的范例程序代码里面，表达式的内容是用一个字符串常数写成 
 514 的)。表达式的内容可以从一个 Edit组件让用户输入，或者可以动态的从几
个不同的表达式结合而来。它先被指派给 TBindingExpression 对象，接着在
运行时间被透过呼叫 Compile方法，加以分析、编译 (这里所指的是字符 串
被转换成标识符的格式，不是真的编译成汇编语言的执行码 )。然后会在执
行时使用 RTTI来存取 TPerson对象。  
 
缺点是这个作法会使得表达式的执行明显的比预先编译完成的 Object 
Pascal机器码来的慢。换句话说，我们得在效能跟弹性上取得一个平衡。也
可以说可视化直接绑定模型的功能提供了功能强大、容易使用的开发者经
验。  
  
 515 17:TObject 与System 单
元文件  
 
在任何 Object Pascal 程序语言的应用程序核心里，都有类别的架构存在。
在系统的每一个类别都一定是从 TObject类别所衍生出来的， 所以整个架构
只有单一的根源。 这使得我们可以使用 TObject数据型别来做为系统所任何
一个类别的数据型别的替代品。  
 
TObject类别是定义在核心的 RTL当中，单元文件的名字是 System，因为
这个单元文件非常重要，所以在任何的编译动作当中，都会自动引入这个
单元文件。我们不会逐一介绍所有在 System单元文件里面的类别跟函式，
我们要把心力放在 TObject这个最重要的主角之上。  
_________________________________________________________________ ________  
我们可以花很长的篇幅来争论核心系统类别，像 TObject是否算是 Object 
Pascal程序语言的一部分，或者算是执行时期函式库的一部分。其他在
System单元文件的功能也一样，一个单元文件重要到会自动在编译时被引
入。 (事实上如果我们把它加入到 uses区块，反而会造成错误 )。这样的争
论没有意义，所以我们在这里不去谈他。  
 
TObject 类别 
正如我刚提到的， TObject类别是非常特殊的类别，因为所有其他的类别都
继承自 TObject。当我们宣告一个新的类别时，事实上，如果我们没有指定
一个基础类别，该类别就会自动继承自 TObject了。在程序语言的术语里，
这样的型别系统被称为『单一根源类别架构』 ，这是 Object Pascal 的功能，
C#，Java跟一些现代的程序语言也都如此设计。值得一提的例外是 C++，
它没有单一根源的基础类别，且允许我们定义多重完全分离的类别架构。  
 
这个基础类别并不是一个让我们直接建立实体来用的类别。然而我们最后
可以很容易的在很多地方使用它。每次我们需要一个可以用来储存对象或
其任何其他型别变量时，我们就可以把它宣告为 TObject型别。这个用法有
个很好的例子，就是在组 件函式库当中的事件处理程序，所有的事件处理
程序通常都使用 TObject作为第一个参数的型别，通常称之为 Sender。这表筆記   
 516 示它可以是任何实际类别的对象。  
 
很多泛型集合也是对象的集合，且有一些情境忠， TObject型别是直接被使
用上的。在以下的情境当中，我会介绍到这个类别的一些功能，这些功能
是所有位于 System单元文件里面的类别都可以用的。  
 
  建立与毁灭  
虽然直接建立 TObject没有什么意义， 不过这个类别的建构函式跟解构函式
还是很重要的，因为它们会被所有其他类别自动继承。如果我们定义了一
个没有建构函式 的类别，我们还是可以呼叫它的 Create方法，这会呼叫
TObject 的建构函式，这是个空的函式 (因为在这个基础类别中没有什么要
初始化的 )。这个 Create建构函式不是虚构的，且我们可以在自定的类别中
把它整个替换掉，除非这个没做什么事的建构函式就已经够用了。呼叫基
础类别的建构函式，对任何的子类别实作都是一个好习惯，即使直接呼叫
TObject.Create 没有什么特别的用处。  
____________________________________________________________________ _____  
我已经强调这是一个非虚拟的建构函式，因为有另一个核心函式库类别，
TComponent ，是有定义虚拟建构函式的。 TComponent 类别的虚拟建构函式
是整个串流化系统当中的关键角色，我们将在下一章里面介绍。  
 
为了毁灭一个对象， TObject类别里有一个 Free方法 (这个方法最后会呼叫
Destroy解构函式 )，以及 ARC特定功能，像是 DisposeOf ，我们已经在第
13章里面介绍过了，并在该章里面提出许多建议来端正内存使用的风气，
所以在这里就不再赘述了。  
 
  物件的二三事 (Knowing Ab out an Object)  
在TObject里面有一组有趣的方法，它们会回传关于型别的一些信息。最常
用的就是 ClassType 跟ClassName 方法。 ClassName 方法会把类别的名称用
字符串来回传。因为它是一个类别方法 (就像大多数 TObject的类别方法一
样)，我们可以透过对象或类别来呼叫它。假设我们定义了一个对象名为
TButton，并以这个类别建立了一个名为 Button1的对象。那么以下的两杭
程序代码，回传的结果就会完全相同：  
Text := Button1.ClassName;  
Text := TButton.ClassName;  
 
当然，我们也可以把这些应用在常见的 TObject 上面，但我们不会得到筆記   
 517 TObject 的信息，而是关于该对象变量所属的类别的信息。例如在按钮的
OnClick事件处理程序里，我们可以呼叫 : 
Text := Sender.ClassName;  
 
这会回传跟前面两个指令一样的结果， 回传值将会是 ”TButton” 这个字符串。
这是因为类别名称是在执行时期决定的 (由特定的对象本身决定 )， 而不是由
编译程序来决定的 (编译程序只会认为它是一个 TObject型别的对象 )。 
 
取得类别名称对于 侦错、记录跟一般显示类别信息都是很有用的，通常它
也对于存取该类别的类别参考更为重要。举例来说，比较两个类别参考比
用两个类别的名称来做字符串比对更好。 我们可以透过 ClassType 方法来取
得类别参考， 而 ClassParent 方法则会回传当前对象的基础类别的类别参考，
允许浏览基础类别列表。 唯一的例外是当该方法回传 TObject是nil时(因为
它没有父代类别 )。一旦我们有了类别参考，我们就可以用它来呼叫任何类
别方法，包含 ClassName 方法。  
 
另一个也很有趣的方法会回传关于类别的信息， 是名为 InstanceS ize的方法，
这个方法会回传一个对象在执行时期的大小，回传的这个数字是指该对象
的数据字段所要求的大小总和 (以及继承自基础类别的数据 )。 这个功能是当
系统需要为该类别的新实体进行配置时，内部使用的功能。  
_________________________________________________________________________  
虽然我们可能会觉得 SizeOf这个全局函式也会提供相同的信息，但这个函
式实际上是回传对象参考的大小， 也就是指标的大小， 指标现在不是 4 bytes
就是 8 bytes，要看是在 32位还是 64位的操作系统上 -跟对象本身所占用的
空间完全无关。  
 
  更多TObject 类别的方法  
还有些 TObject类别的方法我们可以用在任何对象上 (也可以用在任何类别
或类别参考，因为这些方法是类别方法 )。以下是一部分的列表，搭配简单
的描述：  
 ClassName 以字符串回传该类别的名称，用以显示。  
 ClassNameIs 检查类别名称是否与参数值相同  
 ClassParent 回传当前类别的父类别的类别参考或者对象的类别。我们
可以从 ClassParent 浏览到 ClassParent ，直到浏览的对 象到达 TObject
为止，对 TObject呼叫这个方法，回传值会是 nil。 
 ClassInfo 回传类别所属的内部的，低阶的执行时期型别信息 (RTTI)。这
是早期在 TypInfo单元文件里面使用的，但现在已经以 RTTI单元文件筆記   
 518 的功能取代了它，我们在第 16章已经介绍过了。目前仅剩内部使用，
它还是传统 RTTI取得信息的途径。  
 ClassType 回传该对象所属类别的参考 (这无法透过类别呼叫，只能透过
对象来呼叫 )。 
 InheritsFrom 检测一个类别是否继承自 (直接或间接都算 )特定的类别
(这效果很像 is运算符号， 但is运算符号的实作比较全面 )。 
 InstanceSize 回传对象的数据大小，单位是 Bytes。这个数字会是所有字
段的总和， 加上一些额外的特定保留位 (包含例如类别参考 )。 要留意到。
再一次留意到，这是实体的大小，而指向实体的参考只是一个指标 (4
或8 bytes，要看操作系统而定 ) 
 UnitName 回传定义该类别的单元文件的名字。对于描述一个类别是很
有用的。事实上，类别名称在系统中并不是唯一的。当我们看完最后
一章，就会知道只有完整连同单元文件一起列出的类别名称 (包含单元
文件名称跟类别名称的组合，以 .加以连接 )在应用程序中才是唯一的。  
 QualifiedClassName 回传整个单元文件跟类别名称的连结，在执行中的
系统里，这个值会是唯一的。  
 
以上 TObject的方法适用于每一个类别的对象，因为 TObject是每个类别共
通的祖先类别。以下是我们透过这些方法来存取类别信息的例子 : 
procedure TSenderForm.ShowSender(Sender: TObject);  
begin  
    Memo1.Lines.Add (‘Class Name: ‘ +  
       Sender.ClassName) ; 
    if Sender.ClassParent <> nil then  
       Memo1.Lines.Add (‘Parent Class: ‘ +  
    Sender.ClassParent.ClassName);  
    Memo1.Lines.Add (‘Instance Size: ‘ +  
        IntToStr (Sender.InstanceSize));  
 
这段程序代码会检测看看 ClassParent 的内容是不是 nil，万一我们正好用到
TObject型别的实体，它就 不会有基础类别了。我们可以用其他方法来进行
检测。例如，我们可以用以下的程序代码来检验 Sender对象是不是特定的
型别：  
if Sender.ClassType = TButton then ...  
 
我们也可以检测 Sender参数是否对应到特定的对象，用这个方式检测 : 
if Sender = Button1 then...  
不检查特定的类别或对象，我们通常需要测试某个类别的对象型别是否兼 
 519 容，也就是说，我们会需要检查一个类别的对象是否属于特定的类别或者
该类别的子类别。这会让我们知道我们是否可以透过该对象呼叫定 义在类
别中的方法。这个检测可以透过呼叫 InheritsFrom 方法来完成，当我们使用
到is运算符号的时候，系统也会呼叫这个方法。以下两个测试是完全一样
的：  
if Sender.InheritsFrom (TButton) then ...  
if Sender is TButton then ...  
 
  显示类别信息  
当我们取得类别参考时，我们可以把这个类别参考的所有基础类别的名称
(或者显示信息 )加入到一个列表中。在以下的程序片段中， MyClass 的所有
基础类别都会被加到 ListBox组件当中：  
ListP arent.Items.Clear;  
while MyClass.ClassParent <> nil do  
begin  
   MyClass := MyClass.ClassParent;  
   ListParent.Items Add (MyClass.ClassName);  
end;  
 
您应该注意到了，我们在 while循环当中使用了类别参考，这个类别参考会
用来检查该类别是否存在父代类别 (万一目前的类别是 TObject, 就不会有
父代类别 )。或者我们也可以把 while的判断条件写成这样 : 
while n ot MyClass.ClassNameIs ('TObject') do... // slow, error prone  
while MyClass <> TObject do... // fast, and readable  
 
  TObject 的虚拟方法  
从Object Pascal 的早期， TObject类别的结构中就已经相当稳定，我们可以
从当中找到三个很有用的虚拟方法。这些方法可以被任何对象呼叫，就像
TObject的其他方法一样，但相关的是，这些方法我们在自己建立的子类别
中都应该重载或重新写过。  
_________________________________________________________________________  
如果您已经使用过 .NET架构，您可能会立刻发现这些方法是 C#基础类别
函式库的 System.Object 类别的一部分。 类似的方法也在 Java当中被设计在
基础类别当中，在 JavaScript 里面也很常见，其他语言当中也是。这些方法
(例如 toString)的来源，可以追溯到 SmallTalk ，它应该算是第一个 OOP语
言。  筆記   
 520   ToString 方法 
ToString 这个虚拟方法是提示要回传以文字化表示 (描述或者是把对象进行
串行化的结果 )一个特定对象。在 TObject当中预设的实作程序代码是回传
该类别的名字 : 
function TObject.ToString: string;  
begin  
   Result := ClassName;  
end;  
 
当然这样距离实用还远的很。理论上，每个类别都应该提供一个方式来把
自己对使用者作介绍，例如当一个对象被加到可视化的列表时。在运行时
间函式库中的部分类别有对这个函式进行重载，像是 TStringBuilder, 
TStringWrit er,以及 Exception 类别， Exception 类别会回传整个列表的例外讯
息(我们已经在第九章的巢状例外与内部例外机制这一节当中介绍过 )。 
 
透过一个标准的方法为任何对象回传文字表现形式是相当有意思的想法。
而且我推荐大家要好好利用 TObject类别这个核心功能， 把它当成程序语言
内建功能一样。  
_________________________________________________________________________  
要注意 ToString方法在 『语义上多载』 了在 Classes单元文件中定义的 toString
标识符，该定义的意思是『解析 token字符串』 。因此，我们应该也该常看
一下在 Classes.toString 当中的参考定义。  
 
  Equals方法 
Equals虚拟函式是提示要检测两个对象是否有相同的逻辑内容，这个检测
跟检测两个变量是否在内存中指向同一个对象是不同的，如果只是要检测
两个变量是否在内存当中指向同一个对象，我们可以用 =这个运算符号。然
而，这样看上去的确挺让人迷惑的，预设的实作程序代码如下，我们该想
想有没有更好的办法 : 
function TObject.Equals( Obj: TObject): Boolean;  
begin  
   Result := Obj = Self;  
end;  
 
举个使用这个方法的例子 (透过适当的重载 )，在 TStrings类别当中的 Equals
方法会把该类别的字符串列表的总数跟内容一一进行比对。  筆記   
 521 使用这个技术最显著的函式库是对泛型支持的功能，特别是在 Generics.De - 
fault跟Generics.Collections 单元。通常在函式库或架构中把对象概念定义
为”内容是否相等 ”，而不是 ”是否是同一个对象 ”是很重要的。能透过一个标
准的机制来比 对对象的『内容』绝对是很大的好处。  
 
  GetHashCode 方法 
GetHashCode 虚拟函式是从 .NET架构借来的另一个提示，让每一个类别可
以为其对象计算哈希值 (Hash)。预设的程序代码会回传一个整数值，看起来
是该对象的地址：  
function TObject.GetHashCode: Integer;  
begin  
   Result := Integer(Self);  
end;  
___________________________________________________________ ______________  
对象建立时的内存地址，通常都是在 heap内存里面的限定区域，所以用这
个数字来建立哈希值并不实际，对于 Hash算法的使用会有负面的影响。强
烈建议大家要自行重写这个方法，依照对象内部的逻辑数据与好的 Hash算
法来建立哈希值 (Hash)，不要用对象的地址。 Dictionary 跟其他的数据结构
会依赖 Hash值，因此改进 Hash的建立，在效能表现上会有显著的改善喔。  
 
GetHash 虚拟方法在不少集合类别 (只要有支持哈希表 -Hash Table 的类别 )
当中都有用到，且这些类别是把 Hash当成优化部分程序的方法，像是
TDictionary<T> 。 
 
  使用 TObject 虚拟方法  
以下是以 TObject虚拟方法为基础的范例，这个范例中有一个类别，它重载
了这些虚拟方法当中的两个：  
type  
  TAnyObject = class  
  private  
     V alue: Integer;  
     name: string;  
  public  
      constructor Create (aName: string; aV alue: Integer);  
      function  Equals(obj: TObject): Boolean; override;  
      function ToString: string; override;  筆記   
 522   end;   
 
在这三个方法的实作中，我单纯的把呼叫 GetType改成呼叫 ClassType:  
constructor TAnyObject.Create(aName: string;  
   aV alue: Integer);  
begin  
   inherited Create;  
   name := aName;  
   V alue :=  aV alue;  
end;   
function TAnyObject.Equals(obj: TObject): Boolean;  
begin  
   Result := (obj.ClassType = self.ClassType) and  
       ((obj as TAnyObject).V alue = self.V alue);  
end;   
function TAnyObject.ToString: string;  
begin  
   Result := Name;  
end;  
 
注意到对象是否相同， 是依照它们是否属于同一个类别，且当中的数据是
否相同，当中判断的字符串表现内容，只包含了 name这个字段。这个程序
在启动时，以这个类别建立了一些对象 : 
procedure TFormSystemObject.FormCreate(Sender: TObject);  
begin  
  ao1 := TAnyObject.Create ('ao1', 10);  
  ao2 := TAnyObject.Create ('ao2 or ao3', 20);  
  ao3 := ao2;  
  ao4 := TAnyObje ct.Create ('ao4', 20);  
  ... 
 
注意到这两个参考 (ao2跟ao3)是指向内存当中的同一个对象，且最后一个
对象 (ao4)有着相同的数值内容。这个程序具备了用户接口，让用户可以选
择任两者，并对被选上的对象进行比较，同时使用 Equals跟直接透过参考
来做比较。  
 
以下是比较的一些结果：  
Comparing ao1 and ao4   
 523 Equals: False  
Reference = False  
 
Comparing ao2 and ao3  
Equals: True  
Reference =  True  
 
Comparing ao3 and ao4  
Equals: True  
Reference = False  
 
这个程序有另一个按钮，用来检测该按钮的其他方法：  
var 
    btn2: TButton;  
begin  
   btn2 := btnTest;  
   Log ('Equals: ' +  
     BoolToStr (btnTest.Equals (btn2), True));  
   Log ('Reference = ' +  
     BoolToStr (btnTest = bt n2, True));  
   Log ('GetHashCode: ' +  
     IntToStr (btnTest.GetHashCode));  
   Log ('ToString: ' + btnTest.ToString);  
end;   
 
执行结果如下 (透过运行时间改变的哈希值 ): 
Equals: True  
Reference = True  
GetHashCode: 28253904  
ToString: TButton  
 
  总结TObject 类别 
总结一下，在最新版的编译程序里， TObject 类别当中有完整的接口 (已经
把大多数的的 IFDEF跟低阶的多载部分省略了，并略过私有区跟保护区 ): 
type  
    TObject = class  
    public   
 524       constructor Create;  
      procedure Free;  
      procedure DisposeOf;  
      class function InitInstance(Instance: Pointer): TObject;  
      procedure CleanupInstance;  
      function ClassType: TClass; inline;  
      class function ClassName: string;  
      class function ClassNameIs(const Name: string): Boolean;  
      class function ClassParent: TClass;  
      class function ClassInfo: Pointer; inline;  
      class function InstanceSize: Integer; inline;  
      class function InheritsFrom(AClass: TClass): Boolean;  
      class function MethodAddress(const Name: string): Pointer;  
      class function MethodName(Address: Pointer): string;  
      class function QualifiedClassName: string;  
      function FieldAddress(const Name: string): Pointer;  
      function GetInterface(const IID: TGUID; out Obj): Boolean;  
      class function GetInterfaceEntry(  
           const IID: TGUID): PInterfaceEntry;  
            class function GetInterfac eTable: PInterfaceTable;  
      class function UnitName: string;  
      class function UnitScope: string;  
     {$IFDEF AUTOREFCOUNT}  
         function __ObjAddRef: Integer; virtual;  
         function __ObjRelease: Integer; virtual;  
     {$ENDIF}  
      functi on Equals(Obj: TObject): Boolean; virtual;  
      function GetHashCode: Integer; virtual;  
      function ToString: string; virtual;  
      function SafeCallException(ExceptObject: TObject;  
           ExceptAddr: Pointer): HResult; virtual;  
      procedure Af terConstruction; virtual;  
      procedure BeforeDestruction; virtual;  
      procedure Dispatch(var Message); virtual;  
      procedure DefaultHandler(var Message); virtual;  
      class function NewInstance: TObject; virtual;  
      procedure FreeInstance; vi rtual;  
      destructor Destroy; virtual;   
 525     public  
      property RefCount: Integer read FRefCount;  
      property Disposed: Boolean read GetDisposed;  
    end;  
 
  Unicode 跟类别名称  
MethodAddress 跟FieldAddress 具备多载的版本，依照其参数的型别不同，
我们可以使用 UnicodeString 或ShortString 作为参数，如果使用 ShortString
参数，则输入的字符串会被认为是 UTF -8字符串。事实上这些版本都会使
用Unicode字符串， 它们会自动呼叫 UTF8EncodeToShortString 来进行转换 : 
function TObject.FieldAddress(const Name: string): Pointer;  
begin  
   Result := FieldAddress(UTF8EncodeToShortString(Name));  
end;  
 
因为 Object Pascal 本身就已经支持 Unicode了，在 Object Pascal 内部的类
别名称是使用 ShortString( 它是一个 1位的字符数组 )来表示的，但是是使用
UTF -8的编码法， 而不是传统的 ANSI编码法喔。 这个作法同时用在 TObject
阶层跟 RTTI阶层。  
 
举例来说 ClassName 方法是这样实作的 (用了很丑的低阶程序代码 ): 
class function TObject.ClassName: string;  
begin  
   Result := UTF8ToString (  
         PShortString (PPoin ter (  
              Integer(Self) + vmtClassName)^)^);  
end;  
 
跟TypInfo单元文件很相似， 所有存取类别名称的函式都会在内部把 UTF -8 
ShortString 表示转换成 UnicodeString 。类似的动作也会发生在属性的名称
处理上。  
 
System 单元 
TObject很显然已经是 Object Pascal 语言的核心角色了，我们已经很难去区
分它到底是程序语言的一部分，或是运行时间函式库的一部分，在 System
单元中，还有一些低阶的类别是构成基础 且已经跟编译程序支持整合在一 
 526 起了。这个单元的大多数内容，是为了低阶数据结构、简单记录结构、函
式、程序以及一些类别而制作的。  
 
在此我们要集中心力在这些类别上，但不可否认的，在 System单元中的选
多其他功能也是 Object Pascal 的关键。举例来说， System单元里面定义了
许多 Pascal里面固有的函式，这些函式没有实际的程序代码，会由编译程
序直接加以解析。例如 SizeOf，编译程序就会直接把这个函式换成该参数
数据结构的实际大小。  
 
我们可以阅读一下 System单元文件里面的批注来了解它的独特地位 (几乎
解释了为什么在浏览系统变量的时候都会需要这个单元 )： 
{ Predefined constants, types, procedures, }  
{ and functions (such as True, Integer, or }  
{ Writeln) do not have actual declarations.}  
{ Instead they are built into the compiler }  
{ and are treated as if they were declared }  
{ at the beginning of the System unit.     }  
 
译文如下：  
预先定义的常数、型别、程序与函式 (像是 True, Integer 或 Writeln)并没
有实际的宣告。反之，它们是内建在编译程序里的，并且会被当成宣告
在System单元文件的最开头一样。  
 
阅读这个单元里面的原始码可能会很无聊，也是因为我们可能在这个单元
文件里面发现一些执行时期函式库的低阶程序代码。所以我决定只挑里面
很有限的内容来介绍。  
 
  被选上的系统型别  
刚刚提过， System单元定义了核心数据型别，以及 许多不同值类型的型别
别名、有序型别，以及字符串。还有许多系统在低阶处理会使用到的核心
数据型别 (包含列举型别、记录，以及强制型别别名 )等，这些都值得一提 : 
 
 TVisiblityClasses 是用在 RTTI可视范围设定的列举型别 (详情请见第 16
章)。 
 TGUID是在 Windows 平台上用来表现 GUID的纪录，但也可以用在其
他支持 GUID的操作系统上。  
 TMethod 是一个核心的记录，用来表现事件处理程序要使用的结构， 
 527 包含一个指向方法地址的指针，以及一个指向当前对象的指针 (详情请
见第 10章) 
 TMonito r是一个记录，用来实作线程同步的机制 (称为”Monitor”) ，这是
由C.A.R Hoare 跟Per Brinch Hansen 所发明的， 在维基百科上面也有名
为”Monitor synchronization” 的详细介绍。 这是 Object Pascal 程序语言中
线程核心的功能，而 TMonitor 信息是在系统中的每个对象都存在的。  
 TDateTime 是Double型别的强制型别别名，用来储存日期信息 (使用其
中的指数部分来储存 )与时间信息 (用其十进制的部份 )。更进一步的别
名包含 TDate跟TTime。这些型别在 第二章里面有介绍。  
 THandle 是值类型的别名，用来表示操作系统对象的参考，通常称
为”Handle”( 至少是在 Windows API 的范畴中 )。 
 TMemoryManagerEx 是用来储存核心内存处理的记录， 可以把系统的内
存管理模块换成自定的模块 (这是比较新版的 TMemoryManager) ，新的
模块仍旧有向前支持。  
 THeapStatus 是一个记录用来储存关于 heap内存状态的信息， 我们在第
13章有提过。  
 TTextLineBreakStyle 是一个列举型态，代表特定操作系统对文本文件
的换行格式。 DefaultTextLineBreakStyle 这种型别的全局变量保存了目
前的信息，会在许多系统函式库里面使用到。同样的， sLineBreak 常
数则表达了字符串型别里相同的作用。  
 
  System 单元里面的接口  
接口型别有好几种 (而且有些类别在核心阶层实作了接口的功能 )，它们是
System单元的一部分，值得我们一看。界面我们在第 11章介绍过了。以下
是System单元里面跟接口相关的一些型别：  
 IInterface 是所有接口的基础，所有接口都要从这个型别继承而来，就
像TObject之于所有其他的类别一样。  
 IInvokable 跟IDispatch 是支持动态呼叫的接口 (部分与 Windows COM 的
实作绑在一起 )。 
 列举的支持跟比较的动作是透过以下的接口来定义的 : IEnumerator ，
IEnumerable, IEnumerator<T>, IENumerable<T>, IComparable, 
IComparable<T> 跟IEquatable<T> 。 
 
还有一些核心类别提供了接口的基础实作。我们可以直接从这些类别衍生
出新的类别，就可以实作接口了，在第 11章里面我们介绍过了：  
 TInterfacedO bject 是一个类别，在当中已经有对参考计数与对接口 ID
检查的基本实作。   
 528  TAggregatedObject 跟TContainedObject ，这两个类别特别提供对
aggregate 对象跟实作的语法。  
 
  被选上的系统函式  
在System单元里面，内建跟标准程序与函式非常多，但大多数都不常被用
到。以下是我们选出来的核心程序跟函式，每个 Object Pascal 开发人员都
应该知道这些：  
 
 CheckForCyclesProc 是用来验证在 ARC底下是否发生循环参考。它只
能在支持 ARC的编译程序里面用。  
 Move 是在系统中核心内存复制的程序，把特定数量的内存很单纯的从
一个地址复制到另一个地址去 (很强大、 速度快， 但有一点点的危险性 )。 
 ParamCount 跟ParamStr 函式可以用来处理命令行指令的参数 (在图形接
口系统中，像 Windows 跟Mac也都可以运作的很好 ) 
 Random 跟Randomize 是两个传统的函式 (似乎是从 BASIC借来的概
念)，提供我们产生随机数 (但一定要记得呼叫 Randomize ，产生的数目
才会真的随机 )。 
 很大量的核心数学运算函式，在这里全略过。  
 许多字符串处理跟字符串转换函式 (在UTF-16，Unicode，UTF -8，ANSI，
以及其他字符串格式之间转换 )，其中包含一些是跟平台相关的。  
_________________________________________________________________________  
这些函式中，包含一些间接的定义。换句话说，这些函式实际上是一个指
标指向实际的函式。所以原始系统的行为可能会在运行时间被程序代码动
态的替换掉。 (当然，如果我们知道自己在做什么，这也是把整个系统搞死
的好办法 ) 
 
  预先定义的 RTTI标注 
在本章的最后， 我 想介绍的最后一组数据型别是跟标注相关的， 额外的 RTTI
信息，我们可以连接到程序语言的任何符号。这个主题我们已经在第 16章
里面介绍过，但当时我并没有提到过在系统中预先定义的标注。  
 
以下是在 System单元中定义的标注类别：  
 
 TCustomAttribute 是所有自定标注的基础类别。这是我们可以当成所有
需要使用到标注的类别的根源基础类别 (且这是编译程序可以识别类
别的唯一方法，作为一个标注，因为没有特别宣告的语法 )。 筆記   
 529  WeakAttribute 也是用来在 ARC环境中标明 weak参考 (详见第 13章) 
 Unsa feAttribute 也是在 ARC环境中作为特别处理之用的 (详见第 13章) 
 RefAttribute 很直觉是给参考值使用的。  
 VolatileAttribute 标示会自动消灭的变量，这种变量可以从外部进行修
改，而且无法被编译程序优化。  
 StoredAttribute 是可以表达属性中的 stored旗目标另一种方法。  
 HPPGENAttribute 控制 C++接口文件 (HPP)的生成。  
 HFAAttribute 的文件目前还没有提供 (但它跟 ARM 64位架构是相关的 ) 
 
在System单元中还有更多内容， 但比较适合专家级的开发人员。我们先继
续介绍吧，在最后一章里面，我们会触及 Classes单元，以及其他 RTL的
功能。   
 530 18:其他核心 RTL的类别  
 
如果 TObject类别跟 System单元可以被认为是 Object Pascal 的结构化部分，
其他编译程序本身需要用来建置任何应用程序的功能，其他在执行时期函
式库的功能，都会被认为是核心系统的选项延伸。  
 
RTL当中有许多的系统函式，包含最常用的标准动作，以及有些部分可以
回溯到 Turbo Pascal 的时代，在前 Object Pascal 程序语言的时期。在 RTL
的许多单元文件都是函式跟子程序，包含核心的功能 (SysUtils) ，数学函式
(Math)，字符串处理 (StringUtils) ，日期时间处理 (DateUtils) 等等。  
 
在本书里，我并没有想要深入到 RTL的传统部分，而是要专心介绍核心类
别(这些是 Object Pascal(VCL 跟FireMonkey) 用于视觉组件的基础 )，以及其
他子系统。例如 TComponent 类别，定义了 ”以组件为基础 ”的概念架构。它
也是内存管理跟其他基础功能的基石。 TPersistent 类别则是组件串流化呈现
的关键。  
 
我们还会再看其 他许多的类别，因为 RTL涵盖的范围很大，包含了文件系
统、核心线程的支持、平行程序函式库、字符串建立、许多不同型别的集
合，以及容器类别、核心图形几何结构 (像是点跟长方形 )、核心数学结构 (像
是向量跟矩阵 )，还有许许多多的功能。  
 
因为本书的重点是 Object Pascal 程序语言，并不是函式库的手册，我们在
此只会选择几个类别，选择的原因是因为它们的角色极为关键，或者是因
为该类别是这几年才发表，而大多数的开发人员都没有留意到它们。  
 
Classes 单元 
Object Pascal RTL 类别函式库的基础 (也是可视 化函式库的基础 )可以说就
是System.Classes 。这个单元包含了许多最常用到的类别的集合，不包含特
殊用途的类别。当中重要的类别值得一看，我们接下来就深入分析当中最
重要的一些类别吧。  
 
  
 531   在Classes 单元中的类别  
以下是一个简单的列表 (我们大致上列出了该单元当中定义类别的一半 ): 
 
 TList 是一个核心的指标列表，它通常可以改编成未确立型别的列表，
通常建议改用 TList<T> ，详见第 14章。  
 TInterfaceList 是一个线程安全 (thread -safe)的界面列表，它实作出
IInter faceList，值得我们细细了解 (在此暂不介绍 )。 
 TBits 是一个非常简单的类别，用来操作在数据里面的独立位。它比较
高阶，执行位操作时可以透过位移 (shift)或是二元运算符号 or跟and。 
 TPersisitent 是一个很核心的类别 (TComponent 的基础类别 )，我们在下
一节里面来介绍。  
 TCollectionItem 跟TCollection 是用来定义集合的属性，这个属性会包
含一个内容的数组。对开发组件的人员来说 (当间接的使用组件时也
是)，这些是很重要的类别，但对于开发应用程序的人员来说就没有 这
么重要了。  
 TStrings是抽象的字符串列表， TStringList 才是实际实作出基础 TStrings
的类别， TStringList 类别提供对实际字符串的储存功能。每个项目还
可以再跟一个对象连接，这也是使用字符串列表的一个标准作法，透
过名称 /内容的字符串成对。在本章后面有一小节『使用字符串列表』
会介绍更多的信息。  
 TStream是一个抽象类，用来表现任何种类的连续字节，透过连续的存
取， 它可以包含许多不同的储存选项 (内存、文件、 字符串、 网络 socket，
二进制长数据 (BLOB)等等 )。在 Classes单元定义了许多特定的串流类
别，包含 THandleStream, TFileStream, TCustomMemory - 
Stream, TMemoryStream, TBytesStream, TStringStream 以及 TResou - 
rceStream 。其他特定串流则是在不同的 RTL单元里宣告。我们可以在
本章当中的『介绍串流』看到关于串流的介绍。  
 低阶组件的串流类别，像是 TFiler, TReader, TWriter 以及 TParser，大多
是开发组件的人员会使用 ……但不是只有他们会用到。  
 TThread  类别，定义了线程类别，可以支持跟操作系统无关的多线程应
用程序。也有一个为异步操作设计的类别，名为 TBaseAsync - 
Result。 
 实作了 observer( 检查者 )模式的类别 (像Visual live binding 就有使用到 )，
包含 TObservers, TLinkObservers 以及 TObserverMapping 。 
 为了自定标注而定义的类别，像是 DefaultAttribute, NoDefaultAttribute, 
StoredAttribute 以及 ObservableMemberAttr ibute。 
 基础的 TComponent 类别，它是所有 VCL跟FireMonkey 当中可视与不 
 532 可视组件的基础类别，我们在本章稍后来介绍。  
 为了支持 action跟action列表的类别 (action是抽象化的 ”命令”，会由接
口元素或者内部程序发起这些命令 )，包含 TBasicAction 跟
TBasicActionLink 。 
 用来镶嵌非可视化组件的容器类别， TDataModule 。 
 对文件存取跟串流存取动作更高阶的接口，包含 TTextReader 跟
TTextWriter ，TBinaryReader 跟TBinary Writer，TStringReader 跟
TStringWriter ，TStreamReader 跟TStreamWriter 。这些类别也在本章稍
后加以介绍。  
 
  TPersistent 类别 
TObject 类别有个非常重要的子类别，它是整个函式库的基础之一，名为
TPersistent 。如果我们仔细观察这个类别的方法，它的重要性将会让我们非
常惊讶…因为这个类别所做的事非常少。 TPersistent 的关键元素之一，是它
定义了一个特别的编译程序选项 {M+}，它的角色是启用 published 关键词，
我们在第十章里面 介绍过了。  
 
Published 关键词是属性串流化的一个基础角色，这一点也从类别的名字就
能看得出来了。一开始，只有从 TPersistent 类别衍生出来的类别可以把数
据字段当成发布区的属性。 RTTI的延伸在较新版的 Object Pascal 稍微把这
个情形给改变了一些些， 但 published 关键词跟 {M+}编译程序选项的地位却
是无可撼动的。  
_________________________________________________________________________  
使用当代的编译程序，如 果我们在一个类别里加入了 published 关键词，而
这个类别不是从 TPersistent 衍生而来， 也没有设定 {M+}这个编译程序选项，
系统会先加入适当的支持，然后也提出警告讯息。  
 
TPersistent 在整个架构中的角色到底有什么特别的 ?首先， 它是 TComponent
类别的基础类别，我们会在下一节里介绍 TComponent 。其次，它被当成属
性数据型别的基础类别，所以这些属性跟它们的内部结构才得以被适当的
串流化。实例就是字符串列表、位图、字型跟其他对象的表示。  
 
跟TPersistent 最相关的功能是它启用 了published 关键词，不过这个类别里
面还有一些有趣的方法值得我们花时间了解一下。首先，是 Assign方法，
这个方法可以用来把一个对象的所有内容复制到另一个对象实体去 (是真
的把数据完全复制，不是只把参考复制过去喔 )。每个有使用到这个功能的
persistent 类别都需要自行实作对应的程序代码 (程序语言或编译程序没有聪筆記   
 533 明到自己会判定每个字段，并加以复制喔 )。其次是相反的功能， AssignTo ，
这个方法是被保护的。这两个方法跟其他在此一类别中的方法大都都是组
件开发人员会使用到，应用程序开发人员不太有机会用到。  
 
  TComponent 类别 
TComponent 类别是组件函式库的基石，它通常会被 Object Pascal 编译程序
直接拿来使用。组件的概念基本上就是在类别中具备一些额外的设计时间
的规则、特定的串流化能力 (所以在设计时间的设定可以被执行中的应用程
序储存、重载 )，我们已经在第十章里面介绍过 PME(Property -Method  
-Event，属性 -方法 -事件 )的模式。  
 
类别中定义了一些标准的规则跟功能，并以对象所有权的概念、跨组件的
通知等概念为基础，把这些规则跟功能纳入了类别的内存模型当中。我们
没有打算对所有的属性跟方法作完整的分析， 当然 TComponent 类别当中的
一些关键功能是值得我们重点关切，因为它在 RTL是核心中的核心。  
 
另一个 TComponent 类别的核心功能则是它提供了一个虚拟的 Create建构
函式，提供了从类别参考建立对象的能力，同时能够呼叫该类别的特定建
构函式程序代码。 我们在第 12章里面对此进行过介绍， 但这是 Object Pascal
比较奇特的功能，值得我们了解一下。  
 
  组件所有权  
所有权的机制是 TComponent 类别的一个关键元素。 如果一个组件在届例的
时候就已经指派了拥有它的组 件(会以参数传递到它的虚拟建构函式 )， 这个
身为所有者的组件就要负责摧毁 (或说释放 )其拥有的所有组件。简单的说，
每一个组件都有一个参考指向它的所有者 (Owner这个属性 )， 同时也有一个
组件列表指向它所拥有的组件 (Components 数组属性 )以及所拥有的组件数
目(ComponentCount 这个属性 )。 
 
在预设的情形下， 当我们把一个组件放在设计接口中 (窗体、 Frame或是 Data 
Module)，就等于是为这个组件指派了所有者。当我们用程序代码建立组件
时，该组件的所有者可以随我们指派，指派 nil也可以 (这时我们就要自己
负责把组件从内存当中释放掉了 )。 
 
我们可以透过 Components 跟ComponetCount 属性来列出一个组件 (在以下
这个例子里，就是 aComp)所拥有的组件，程序片段如下 :  
 534  
var 
   I: Integer;  
begin  
   for I := 0 to aComp.ComponentCount – 1 do  
     aComp.Components[I].DoSomething;  
 
或使用原生的列举功能，改成这么写 : 
var 
  childComp: TComponent;  
begin 
  for childComp in aComp do  
    childComp.DoSomething;  
 
当组件被释放时，会把该组件从该组件所有者的对象列表中删除，并把自
己所拥有的所有子组件释放掉。这个机制对于 Object Pascal 的内存管理非
常关键 : 因为没有回收清理机制， 所有权机制可以解决掉大多数的内存管理
议题，我们在第 13章里面已经介绍了其中的部分。  
 
一如我们介绍过的， 通常在一个窗体或 Data Module 里所有的对象都是以窗
体或 Data Module 作为其所有者。只要我们释放了该窗 体或者该 Data 
Module，它们所拥有的组件也会一起被释放。这就是组件从串流中建立时
所发生的。  
 
  组件属性  
除了核心的所有权机制 (这个机制包含了通知与我们在这里没有介绍的功
能)，任何组件都有两个位于发布区的属性：  
 Name是用来储存组件名称的字符串。这个属性是用来动态搜寻特定组
件(呼叫组件所有者的 FindComponent 方法 )并把有参照到这个组件的
窗体数据字段与之链接。所有被同一个所有者所拥有的组件的名称不
可以相同，但这些组件的名称可以是空白字符串。这儿有两个简单的
规则 :为组件设定适当的名称，让我 们的程序代码更具可读性。另外，
则是不要在执行时期变更组件的名称 (除非我们完全了解到当中会有
什么潜在的效果 )。 
 Tag是一个原生整数数值 (过去是使用整数型别 )，在函式库当中没有使
用到，但我们可以透过它来把组件跟额外的信息进行链接。这个型别
是在储存大小上跟指针、对象参考兼容的，所以我们可以把指针跟对 
 535 象参考除存在一个组件的 Tag属性之内。 (译者 : 在撰写这么久的面向
对象程序的过程中， Tag是Object Pascal 发前人之所未见，这个属性后
来也在 Objective -C里面被广泛使用，我在 Objective -C的程序中，最常
用的动态接口程序搜寻跟处理，就是 viewWithTag ，但 Objective -C里
面后来还陆续扩充了这个属性，提供了字符串型别的 Tag) 
 
  在ARC环境之下的组件所有权关系  
组件所有权的定义很明显在 ARC功能下的编译程序中被改变了，但改变不
大。主要的差异是组件列表通常是一个一般的参考列表，从组件回指到所
有者的参考是一个 weak参考。以下是从类别宣告中节录的部分程序代码 : 
type  
   TComponent = class(TPersistent, IInterface,  
     IInterfaceComponentReference)  
   private  
     [Weak] FOwner: TComponent;  
 
留意到，如果我们用过去的 Delphi编译程序来编译 weak标注，它会被忽
略掉，其他的程序代码则不会有任何变更。  
 
  组件串流  
串流机制同时在 FireMonkey 跟VCL平台上都被用来建立 FMX或DFM文
件，这两个 文件就是围绕着 TComponent 类别为基础的。  
 
Object Pascal 串流机制会把组件跟子组件位于发布区内的属性跟事件都储
存下来。储存的结果就是我们看 到的 DFM跟FMX文件，也是当我们把一
个组件复制到文本编辑器所看到的结果。在运行时间，我们可以透过组件
的方法取得相同的信息，但这功能已经超过我们介绍的范围了。  
 
其中一个关键因素是，串流并不是组件在发布区当中所有的属性的完整集
合。串流包含了发布区当中内容不是默认值的所有属性 (换句话说，内容是
默认值的属性就不会被储存了，这样可以节省储存空间 )，以及有被标示为
stored的属性 (不管是不是默认值， 该属性都会被储存 )。Stored被设定为 False
的属性则不会被储存。还有另一个机制可以加入一个额外的『假』属性，
用以将之进行串流以及把他们读回来。所以我们可以在串流当中储存跟发
布区属性不同的内容。  
  
 536 当一个属性被从串流 文件重建回来的时候，会发生以下的流程：  
 组件的虚拟建构函式 Create会被呼叫 (执行适当的初始化程序代码 ) 
 会从串流中把属性跟事件加载 (加载属性时，会重新把方法的名称对应
到该方法在内存当中实际的名称 ) 
 Loaded虚拟方法会在加载完成时被呼叫 (且组件可以进行额外的自定程
序，此时属性的内容已经完成加载了 )。 
 
现代文件存取 
从前代的 Pascal语言借来， Object Pascal 仍然有此一关键词，且在核心的 语
言机制当中也还是可以处理 文件。当 Object Pascal 发表的时候，本来已经
把文件存取的功能取消，而我也不打算在本书里面介绍这个功能的。反之，
我本来要在下一节里面介绍一些现代处理 文件的技术的，这些技术都在
IOUtils单元中，包含串流类别、 reader跟writer类别。我也不准备对这些
主题太深入介绍，我们只提供一些简单的说明跟一些范例。  
 
  输入/输出工具单元  
System.IOUtils 单元是最近几版才被加入到执行时期函式库的。当中定义了
三个包含大多数类别方法的记录 : TDirectory, TP ath, 以及 TFile。 
 
TDirectory 很显然是用来浏览文件夹、 搜寻当中的 文件以及子文件夹， TFile
看起来跟 TPath没有很明显的差异。首先， TPath是用来处理文件名跟文件
夹名称的，当中有可以用来分离出磁盘代号、不包含路径的文件名、扩展
名，也用来操纵 UNC路径。而 TFile记录则让我们检查 文件的时间戳跟文
件属性，也可以用来操纵 文件，包含写入 文件跟复制文件。 
 
我们来看些例子吧， IOFilesInFolder 范例项目会解析出特定目录里面的所有
子目录，它也会抓出该目录里面所有特定扩展名的 文件。 
 
  解析子目录  
这个程序会把目录里面的文件夹名称找出来，填进 ListBox的内容，使用的
是TDirectory 记录里面的 GetDirectories 方法，把 TSearchOption.soAll - 
Directories 当成参数传入。回传的结果会是一个字符串数组，我们可以用列
举功能来处理它：  
procedure TFormIoFiles.btnSubfoldersClick(Sender: TObject);  
var  
 537    pathList: TStringDynArray;  
   strPath: str ing; 
begin  
   if TDirectory.Exists (edBaseFolder.Text) then  
   begin  
      ListBox1.Items.Clear;  
      pathList := TDirectory.GetDirectories(edBaseFolder.Text,  
TSearchOption.soAllDirectories, nil);  
      for strPath in pathList do  
       ListBox1.Items.Add  (strPath);  
   end;  
end;   
 
  搜寻文件 
这个程序的第二个按钮，让我们可以取得所有子目录当中的所有 文件，透
过呼叫 GetFiles，以及特定的屏蔽，我们可以扫描每一个目录。我们可以把
一个匿名方法，其型别是 TFilterPredicate ，当成参数传给 GetFiles的多载版
本，这样就可以有更复杂的过滤条件了。  
 
以下的范例使用的是比较简单的屏蔽型过滤方式，会建立内部的字符串列
表。这个字符串列表里面的元素接着会先被去除掉路径，指留下文件名，
然后复制到用户接口。当我们呼叫 GetDirec tories方法的时候，回传的只有
子目录，不会包含当前的目录。这也是为什么程序要先搜寻当前目录，然
后再对子目录逐一搜寻的原因了 : 
procedure TFormIoFiles.btnPasFilesClick(Sender: TObject);  
var 
  pathList, filesList: TStringDynArray;  
  strPath, strFile: string;  
begin  
  if TDirectory.Exists (edBaseFolder.Text) then  
  begin  
    // clean up  
    ListBox1.Items.Clear;  
    // search in the given folder  
    filesList := TDirectory.GetFiles (edBaseFolder.Text, '*.pas');  
    for strFile in filesList do  
      sFilesList.Add(strFile);   
 538     // search in all subfolders  
    pathList := T Directory.GetDirectories(edBaseFolder.Text,  
      TSearchOption.soAllDirectories, nil);  
    for strPath in pathList do  
    begin  
      filesList := TDirectory.GetFiles (strPath, '*.pas');  
      for strFile in filesList do  
sFilesList.Add(strFile);  
    end;  
    // now copy the file names only (no path) to a listbox  
    for strFile in sFilesList do  
      ListBox1.Items.Add (TPath.GetFileName(strFile));  
  end;  
end;   
 
在最后几行里， TPath的GetFileName 函式会被用来从完整路径中解析出文
件名。 TPath记录当中包含了一些有趣的方法，包含 GetTempFileName, 
GetRandomFile Name，一个可以用来合并路径的方法，以及一些用来检查是
否包含不合法字符的方法，还有更多其他的功能。  
 
  介绍串流  
如果 IOUtils单元是用来寻找 文件跟操作文件，当我们想要读写 文件的时候
(或者任何类似依序存取的数据结构 )， 我们就可以用 TStream类别跟它的几
个衍生类别。 TStream 抽象类中只有几个简单的属性 (Size跟Position)，以
及一些所有抽象类共享的基本接口，包含主要的 Read跟Write方法。每当
我们读写一些位数据时，目前的位置就会依照读写的数量移动。对大多数
的串流来说，我们可以设定让 目前位置向前移动，但也有一些串流类别是
只能单向移动的。  
 
  常见的串流类别  
一如稍早所提到的， Classes单元定义了几个具体的串流类别，包含以下这
一些 : 
 THandleStream 定义了磁盘 文件串流，可以透过 Handle指向一个 文件。 
 TFileStream 定义了磁盘 文件串流，可以透过档名指向一个 文件。 
 TMemoryStream 定义了一个在内存当中的数据串流，我们也可以使用
指标存取。   
 539  TBytesStream 表示在内存当中的位串流， 我们也可以把它当成像是位数
组来存取。  
 TStringStream 跟在内存当中的字符串串流关连。  
 TResourceStream 定义了一个串流，可以读取跟应用程序执行文件链接
的资源数据。  
 
  使用串流  
建立并使用串流就像建立一个特定型别的变量，以及呼叫组件的方法来从
文件加载内容一样简单。例如，我们要把串流数据加载到 Memo组件中，
我们可以这么写 : 
aStream := TFileStream.Create (FileName, fmOpenRead);  
Memo1.Lines.LoadFromStream (aStream);  
 
一如从这段程序代码中可以看出， 文件串流的 Create方法有两个参数 :文件
名，以及用来指定所需 文件存取模式的设定旗标。我们提到过串流支持读
与写的动作，但这些相对较为低阶，所以我建议使用下一节里面我们要介
绍的 reader跟writer类别。  
 
直接使用串流，提供的是全面的作业，像是在上面的程序代码中加载完整
的串流，或者把一个串流复制到另一个 : 
procedure CopyFile (SourceName, TargetName: String);  
var 
   Stream1, Stream2: TFileStream;  
begin  
   Stream1  := TFileStream.Create (SourceName, fmOpenRead);  
   try 
     Stream2 := TFileStream.Create (TargetName,  
      fmOpenWrite or fmCreate);  
     try 
         Stream2.CopyFrom (Stream1, Stream1.Size);  
     finally  
        Stream2.Free;  
     end  
   finally   
      Stream1.Free;  
   end 
end;    
 540   使用Reader跟Writer  
从串流进行读写的好处， 是使用了身为 RTL一部分的 reader跟writer类别。
在Classes单元当中一共定义了六个读写的类别 : 
 TStringReader 跟TStringWriter 用来处理内存中的字符串 (直接或间接的
使用了 TStringBuilder 类别 ) 
 TStreamReader 跟TStreamWriter 用来处理一般串流 (例如文件串流、内
存串流等等 ) 
 TBinaryReader 跟TBinaryWrit er用来处理二进制数据。  
 
这些文字 reader当中的每一个都实作了一些基本的读取技术 : 
function Read: Integer; overload;  
function ReadLine: string;  
function ReadToEnd: string;  
 
这些文字 writer当中的每一个都有两组多载的处理动作，不包含 (Write)刚
(WriteLine) ，以及每行结尾的符号，以下是第一组 : 
procedure Write(V alue: Boolean); overload;  
procedure  Write(V alue: Char); overload;  
procedure Write(const V alue: TCharArray); overload;  
procedure Write(V alue: Double); overload;  
procedure Write(V alue: Integer); overload;  
procedure Write(V alue: Int64); overload;  
procedure Write(V alue: TObject); overload;  
proc edure Write(V alue: Single); overload;  
procedure Write(const V alue: string); overload;  
procedure Write(V alue: Cardinal); overload;  
procedure Write(V alue: UInt64); overload;  
procedure Write(const Format: string;  
  Args: array of const); overload;  
procedure W rite(V alue: TCharArray;  
  Index, Count: Integer); overload;  
 
  文字 Readers 跟Writers  
为了写入串流， TStreamWriter 类别透过文件名使用了一个串流，或建立一
个串流，一个建立或增加的属性，以及 Unicode编码作为参数。  
所以我们可以像我在 ReaderWriter 范例项目里面这么写 :  
 541 var 
   sw: TStreamWriter;  
begin  
    sw := TStreamWriter.Create('test.txt ', 
    False, TEncoding.UTF8);  
    try 
       sw.WriteLine ('Hello, world');  
       sw.WriteLine ('Have a nice day');  
       sw.WriteLine (Left);  
    finally  
      sw.Free;  
end;   
 
要从 TStreamReader 读取数据，我们可以再对串流或对 文件作一次处理 (在
这个例子里，我用可以透过 UTF BOM 标注来侦测编码方式 ): 
var 
  sr: TStreamReader;  
begin  
  sr := TStreamReader.Create('test.txt', True);  
  try 
    while not sr.EndOfStream do  
      Memo1.Lines.Add (sr.ReadLine);  
  finally  
    sr.Free;  
end;   
 
留意到我们是怎么检查 EndOfStream 状态的。跟直接使用文字符串流或者
字符串不同，这些类别是便于使用的，且效能很好。  
 
  二进制 Reader与Writer 
TBinaryReader 跟TBinaryWriter 类别是用来管理二进制数据，而非文本文
件。这些类别通常是封装起串流 (可能是一个 文件串流或内存内容串流，内
容包含网络、数据库 BLOB字段 )，并重载了 Read跟Write方法。  
 
我们提供了 BinaryFiles 范例项目作为例子。在这个程序当中的第一个部分
会写一些二进制数据到 文件中(一个字段的内容与目前的时间 )然后把他们
读出来，再重新指派属性的内容：   
 542 procedure TFormBinary.btnWriteClick(Sender: TObject) ; 
var 
  bw: TBinaryWriter;  
begin  
  bw := TBinaryWriter.Create('test.data', False);  
  try 
    bw.Write(Left);  
    bw.Write(Now);  
    Log ('File size: ' + IntToStr (bw.BaseStream.Size));  
  finally  
    bw.Free;  
  end;  
end;   
procedure TFormBinary.btnReadClick( Sender: TObject);  
var 
  br: TBinaryReader;  
  time: TDateTime;  
begin  
  br := TBinaryReader.Create('test.data');  
  try 
    Left := br.ReadInt32;  
    Log ('Left read: ' + IntToStr (Left));  
    time := br.ReadDouble;  
    Log ('Time read: ' + TimeToStr (time));  
  finally  
    br.Free;  
  end;   
end;   
 
使用这些 reader跟writer类别的关键规则是我们必须依照写入的顺序来读
取数据，不然我们就会把数据搞乱了。事实上，只有独立字段的二进制数
据被储存，该字段的信息则不会被储存。没有可以阻止我们在 文件中插入
资料或者 metadata，例如把下一个数据结构的大小写在实际的数据之前，
或者把跟该字段相关的 token写入。  
 
 
建立字符串跟字符串列表   
 543 在介绍过 文件跟串流之后，我想花一些时间来介绍处理字符串跟字符串列
表方法。这是很常用的作法，而 且在 RTL当中有很多强大的功能是提供给
字符串跟字符串列表使用的。我只会介绍其中一部分。  
 
  TStringBuilder 类别 
我在第六章里面曾经提到过， Object Pascal 跟其他语言不一样，完整了支持
字符串直接链接的功能， 这个功能的效能非常好。 然而 Object Pascal 的RTL
也包含一个特别的类别，可以用来把字符串跟不同型别的数据进行重组，
这个类别就是 TStringBuilder 。 
 
我们用以下的程序片段作为 TStringBuilder 类别的范例 : 
var 
  sBuilder: TString Builder;  
  str1: string;  
begin  
  sBuilder := TStringBuilder.Create;  
  sBuilder.Append(12);  
  sBuilder.Append('hello');  
  str1 := sBuilder.ToString;  
  sBuilder.Free;  
end;   
 
留意到我们必须建立、释放这个 TStringBuilder 对象，另一个部分则是上面
的程序代码当中，传给 Append方法的参数中，包含了不同型别的资料。  
 
TStringB uilder里面有趣的方法还包含了 AppendFormat( 在对象内部呼叫
Format函式 )， 以及 AppendLine( 在对象内部加入了 sLineBreak) 。 除了 Append
之外，还有一系列的多载方法， Insert，可以用来在字符串里面插入不同型
别的数据，当然还有 Remove(删除部分字符串 )跟Replace(取代字符串 )等常
用的方法。  
_________________________________________________________________________  
TStringBui lder类别有一个非常好的接口，提供了良好的可用性。然而从效
能的观点来看，使用标准的字符串链接跟格式化函式可以提供比较好的效
能，跟其他程序语言不一样的地方是， Object Pascal 的字符串是可以修改内
容的，且在纯粹字符串链接时效能也都比其他语言的效能来的好上许多。  
  在StringBuilder 中的连锁方法  筆記   
 544 TStringBuilder 类别里面有个很特别的功能，是大多数的方法都会回传当时
被参考到的对象。  
 
这种程序的形式开启了连锁方法的可能性，这意思是呼叫对象的方法，会
回传前者，原本的写法是如此 : 
sBuilder.Append(12);  
sBuilder.AppendLine;  
sBuilder.Append('hello');  
 
我们可以改写成这样 : 
sBuilder.Append(12).AppendLine.Append('hello');  
 
把程序代码格式化一下，可以变这样 : 
sBuilder.  
    Append(12).  
    AppendLine.  
    Append('hello');  
 
我觉得这个语法会比原先的语法来的好，但我觉得这只是在语法上面稍微
好一点，但大多数的人会比较偏 好原始版本的写法，每一行都确实的把对
象名字写出来。不管怎么写，要记得不同的 Append呼叫并不会回传新的对
象(所以不会有内存泄漏的危险 )， 但永远都会是用同一个对象来连续呼叫这
些方法。  
 
  使用字符串列表  
字符串列表是在许多视觉组件中很常用的抽象概念，也是被用来处理多行
文字的一个方法。有两个类别是用来处理字符串列表的：  
 TStrings 是一个抽象类，用来表现所有形式的字符串列表，不管它们是
以什么形式进行储存的。这个类别定义了字符串列表的抽象概念。因
此，TStrings的对象只被用来作为组件的属性，这些属性 可以用来为组
件储存文字数据。  
 TStringList 是TStrings的子类别， 定义了自行建立储存空间的字符串列
表，我们可以用这个类别在程序中定义一个实际用来储存数据的字符
串列表。  
 
这两个字符串列表类别也有已经定义好的方法可以用来储存内容到 文件，
或者从文件读取内容了，分别是 SaveToFile 跟LoadFromFile( 这两个方法都 
 545 已经完全支持 Unicode了)。要把整个列表巡回一次，我们可以简单的用 for
指令，以列表的索引值为基础进行列举，直接把该字符串列表当成一个数
组，或者使用 for-in列举都可以 。 
 
执行时期函式库是相当巨大的  
我们在使用 Object Pascal 编译程序的时候，其中一大部分都是由 RTL所提
供的功能，当中包含了许多在不同操作系统上面的核心开发功能。如果我
们要介绍整个 RTL的话，随便写就会跟现在这一本一样厚了。  
 
如果我们只考虑到函式库的主要功能，算是 System这个命名空间，会包含
以下的单元 (我移除了其中一些不常用到的单元 ): 
 System.Actions 包含了对 actions架构的核心支持， 它提供了跟用户者指
令链接的方法，但是已经从用户接口层次抽象化了。  
 System.Chara cter是为了支持 Unicode 字符而设的固有型别助手 (协助
Char型别 )，我们已经在第三章里面介绍过。  
 System.Classes 提供了核心系统类别，也是我们在本章第一部分所介绍
的单元。  
 System.Contnrs 提供了旧版，非泛型的容器类别，像是组件列表，
Dictionary ，队列 (Queue)与堆栈 (Stack)。我建议，可以的话尽量使用泛
型版本的相同类别。  
 System.ConvUtils 提供了不同测量单位之间的转换工具。  
 System.DateUtils 提供了处理日期跟时间数值的函式。  
 System.Devices 提供了与系统装置的接口 (像是 GPS, 重力传感器等系
统内建装置 )。 
 System.Diagnostics 定义了一个记录结构，用以精确测量在测试程序当
中所花的时间，我在本书中几乎没有提到过。  
 System.Generics 有两个分开的单元，其中一个是泛型的集合类别，另
一个是泛型型别。这些单元我们已经在第 14章里面介绍过了。  
 System.Hash 提供了系统对定义哈希值的支持。  
 System.ImageList 包含了抽象定义，实作出跟函式库无关，用以管理图
片列表，以及把单 一图片当成集合的元素。  
 System.IniFiles 定义了一个接口来处理 INI配置文件案，通常只会在
Windows 平台里面找到。  
 System.IOUtils 定义了文件系统存取的记录 (文件、文件夹、路径 )，我
们在本章前面的篇幅介绍过。  
 System.JSON 包含了一些用来处理跟 JavaScript 对象记录方法，或称
JSON的核心类别。   
 546  System.Math 定义了数学运算的函式包含三角函数跟财务函数。在同一
个命名空间的其他单元中也定义了向量跟矩阵的函数。  
 System.Messaging 提供了在不 同操作系统上进行讯息处理的共享程序
代码。  
 System.NetEncoding 包含了处理一些常见的因特网编码法的能力， 像是
base64, HTML 跟URL。 
 System.RegularExpressions 定义了对常规表示法  (Regular Expression)
的支持。  
 System.Rtti 有一整套的 RTTI类别，我们在第 16章里面介绍过。  
 System.StrUtils 提供了核心与传统字符串的处理函式。  
 System.SyncObjs 定义了一些类别用来支持同步与多线程应用程序。  
 System .SysUtils 有系统工具的基本集合，当中包含一些最传统的函式，
以兼容于早期的编译程序。  
 System.Threading 包含了最新的平行程序函式库所需的接口、记录以及
类别。  
 System.Types 包含了一些核心的延伸数据型别， 像是 TPoint, TRectangle
以及 TSize记录， TBitConverter 类别，以及许多在 RTL里面有使用到
的基本数据型别。  
 System.TypInfo 定义了旧版的 RTTI接口， 我们也在第 16章里面介绍过，
但目前已经以 System.Rtti 取代掉它了。  
 Syste m.Variants 跟System.VarUtils 有用来处理变异型别的函式 (我们在
第五章里面介绍过这个功能 )。 
 System.Zip 提供了一个文件压缩跟解压缩的接口与函式库。  
 
RTL当中还有许多部分是 System命名空间的成员，因为每一部分都包含许
多单元 (通常当中的单元都很多，像是 System.Win 命名空间 )包含了 HTTP
客户端 (System.Net) ， 以及对物联网的支持 (System.Beacon, System.Bluetooth, 
System.Sensors 以及 System.Tether) 。当然当中也有从支持的操作系统当中
转译进来的接口跟 API宣告。  
 
再强调一次，直接使用 RTL函式、型别、记录、接口，以及记录，可以让
我们的程序立刻获得许多福利，这是我们需要去发现的，这样可以让我们
得以发挥 Object Pascal 的强大功能。花一些时间，浏览一下系统文件吧，
我们可以从中获益更多。  
 
 
写在最后   
 547 本章的最后，也是本书的结尾，留给接下来的附录。这是我第一本完全把
重点集中在 Object Pascal 程序语言的书，我也尽了最大的努力更新当中的
数据，并让本书的内容跟范例维持在最新的状态。再提一次，在一 开始我
们提到如何取得本书的范例原始码，您也可以随时关注我的网站以获得最
新的信息跟程序的更新。  
 
我希望您能享受阅读本书的过程，就跟我一样享受写作的过程，一如过去
20年我用 Object Pascal 写作的时光。  
 
 
  
 548 end. 
 
本书的最后一节，提供了一些附录，我们介绍一些特别值得一提的相关问
题，但不适合在本书各个章节里面介绍的。包含 Pascal跟Object Pascal 的
小历史，词汇表，以及一个简短的小节来介绍 Delphi跟Appmethod 的ㄎ发
环境  
 
附录一览  
附录 A: Object Pascal 的演进  
附录 B:词汇表  
  
 549 A: Object Pascal 的演进  
Object Pascal 是为不断延伸使用范围的计算装置而建置的程序语言， 从智能
型手机、平板、到桌面计算机以及服务器。它并不局限在特定的应用情境
中。它是被以坚固的基础精心设计，为现代程序设计人员所锻造的工具。
它提供了在开发速度与开发结果执行，以及在语法的清楚和表达式的功能
几乎最为理想的平衡。  
 
Object Pascal 的坚固基础，是建立在 Pascal家族的程序语言之上。就像
Google的Go语言，或者 Apple的Objective -C语言是从C语言衍生而来的
一样。 Object Pascal 是从 Pascal产生出来的。我们从名字就可以猜的到了。  
 
这个简单的附录包含了对这个程序语言家族的历史跟工具做了简短的摘
要，包含 Pascal，Turbo Pascal ，Delphi的Pascal，跟 Object Pascal 。要学习
这个程序语言虽然不用阅读历史，不过了解历史，也能了解这个语言演化
至今这个态势的原因。  
 
我们现在在 Embarcadero 开发工具里面所使用的 Object Pascal 程序语言， 是
在Borland于1995年发表的 Delphi当中一起发明出来的， Delphi是当时最
新的视觉化开发环境。第一个 Object Pascal 语言是从已经在 Turbo Pascal
产品使用的语言版本延伸发展出来的，当时的 Pascal语言就通常都被称为
Turbo Pascal 。Borland并没有发明 Pascal，而是协助 Pascal变得更普及，并
且扩展它的基础，克服许多原本跟 C语言相比之下的一些局限。  
 
以下的几个小节，涵盖了从 Wirth发明出 Pascal到最新版的 LLVM基础的
Delphi版Object Pascal 为了 ARM芯片与行动装置版制作的编译程序。  
 
Wirth的Pascal  
Pascal程序语言最初是在 1971年由 Niklaus Wirth 设计出来的，他是瑞士苏
黎士理工学院的教授。 Wirth教授最完整的传记， 可以从下面这个网址看到 : 
http://www.cs.inf.ethz.ch/~wirth 。 
 
Pascal的设计，是为了教育用途，简化 Algol语言。 Algol语言则是在 1960
年被创造出来的。当 Pascal被发明出来时，同一时代就有许多程序语言并
立，但只有其中几个有被广泛使用 : FORTRAN 、汇编语言、 COBOL 与 
 550 BASIC。Pascal的主要要求，是简洁、以强化型别的概念达到管理的要求、
变量的宣告，以及结构化的程控结构。这个程序语言也是设计成为教育的
工具，在接下来的十多年间，也的确成为学习程序设计最好的工具。  
 
不用说， Wirth的Pascal的核心概念对所有程序语言的历史都产生了重大的
影响，远远的超越了原有的 Pascal语法。作为教育用的程序语言，学校与
大学往往都遵循其他标准 (像是从工具提供者所提供的工作机会或捐赠 )，而
不是看哪个语言可以对学习程序语言的关键概念更有帮助。不过这已经是
另一个故事了。  
 
Turbo Pascal  
Borlan d闻名全球的 Pascal编译程序， 称为 Turbo Pascal ， 是在 1983发表的，
是实作了 Jensen和Wirth的”Pascal用户指南和报告 ”而成的。 Turbo Pascal
编译程序已经是跨越时代最畅销系列的编译程序之一，并且让 Pascal语言
在PC平台特别普及，感谢它在简单与强大之间的平衡。 Turbo Pascal 最原
始的作者是 Anders Hejlsberg ，后来他也为微软创造了 C#语言。  
 
Turbo Pascal 是以整合开发环境 (IDE)著称， 我们可以在这个环境中编辑程序
代码 (透过跟 WordS tar兼容的编辑程序 )，执行编译程序，看到程序的错误、
并跳到出错的程序代码。现在听起来，这都很平常，但是在 1980年代，我
们得编辑好程序、跳出编辑程序，回到 DOS，用命令行执行编译程序，写
下哪一行有错，然后再开启编辑器去修改程序代码。  
 
此外， Borland把Turbo Pascal 只卖 49块美金一份，当时微软的 Pascal编译
程序一份要卖数百块美金。 Turbo Pascal 数年的热销，最后让微软放弃了它
自己的 Pascal编译程序产品。  
 
我们现在还是可以从 Embarcadero 的博物馆区下载 Borland最初的 Turbo 
Pascal编译程序 : 
http://edn.embarcadero.com/museum/  
_________________________________________________________________________  
在最初的 Pascal语言之后， Nicklaus Wirth 设定了 Modula -2语言，是以现
在大多已经被遗忘的 Pascal语法进行延伸的，在这个新的语言里面，发表
了模块化的概念， 和早期的 Turbo Pascal 以及今日的 Object Pascal 在概念上
非常相似。  
 
Modula -2的延伸版本还有 Modula -3， 当中就有面向对象的概念了， 和 Object 筆記   
 551 Pascal非常类似。 Modula -3的使用者比 Modula -2的使用者更少，因为当时
的程序人员多已经投向商业化的 Pascal编译程序和 Apple的编译程序了，
直到 Apple放弃 Object Pascal ，转而支持 Objective -C，Borland就成了这个
程序语言独撑大局的角色。  
 
早期的 Delphi 的Object Pascal  
历经九个版本的世代交替， 从 Turbo Pascal 到Borland  Pascal编译程序， Pascal
终于从模块化程序语言蜕变进入到面向对象程序设计 (OOP)的领域，
Borland在1995年发表了 Delphi，把 Pascal引领朝向可视化程序语言的方
向走去。 Delphi在好几个面向上延伸了 Pascal语言，包含许多面向对象的
延伸模块， 这些跟 Object Pascal 的方向是不同的， 包含 Borland的Pascal with 
Objects编译程序 (这是 Turbo Pascal 最后的身影 )。 
________________________________________ _________________________________  
1995年真的是程序语言发展史上非常特别的一年，在同一年里面，同时有
Delphi的Object Pascal ，Java，JavaScript 跟PHP登场了。这些都是目前全
世界最普及的程序语言。事实上，大多数其他普及的语言 (C, C++, 
Objective -C跟COBOL)也都已经历史悠久了，相对比较年轻的程序语言只
剩下了 C#。我们可以从这个网址得到更多关于程序语言历史的资料 : 
http://en.wikipedia.org/wiki/H istory_of_programming_languages.  
 
在Delphi 2，Borland就把 Pascal编译程序带到了 32位的世界，也实际的把
它重新设计后，把原本在 C++编译程序中常用的一些作法带入了 Delphi。
这也把许多本来只能在 C/C++编译程序中独有的优化程序带入了 Pascal程
序语言。在 Delphi 3，Borland在语言中加入了接口的概念，在类别跟他们
的关系之间有了飞跃的进展。  
 
在全部七个版本的 Delphi里面， Borland终于正式把 Object Pascal 语言称为
Delp hi语言，但并没有在任何时候修改程序语言。在当时， Borland也创造
了Kylix，这是 Linux版的 Delphi，后来又创造了 Delphi的.NET版本 (该产
品就是 Delphi 8) 。这两个项目随后就被终止了，但 Delphi 8( 最后在 2003才
发表 )对程序语言本身做了很大幅度的修改，这些修改后来也被 Win32版本
的Delphi编译程序跟所有后来版本的编译成所采纳。  
 
Object Pascal 从CodeGear 到Embarcadero  
随着 Borland对于在开发工具上投资的迟疑， 后续的版本， 像是 Delphi 2007，
就是以 CodeGear 的名义发表的， CodeGear 当时已经是 Borland最主要的子筆記   
 552 公司了。这个子公司 (或说是事业单位 )，后来被卖给了 Embarcadero ，也是
目前 Delphi跟C++ Builder 产品线的拥有者 (包含组合起来提供给市场的
RAD Studio) 。在 Delphi 2007 发布之后，该公司的重心又回到了发展、延伸
Object Pascal 程序语言，在上面加入许多让全球盼望已久的功能，例如对
Unicode 的支持 (Delphi 2009) ，泛型，匿名方法 (或称程序区块 )，延伸的执
行时期型别信息 (或称镜设 )，以及很多其他主要的程序语言功能 (如本书第
三部分所介绍的 )。 
 
同一时间，除了 Win32编译程序之外，该公司也发表了 Win64的编译程序
(Delphi XE2) 以及 Mac OSX 的编译程序，渐渐走回多平台策略，这是继早
期以 Kylix企图跨足到 Linux平台之后的另一次尝试。然而，这时候的版本
已经成为了在单一 Windows 环境开发，并可以编译到其他平台上的功能支
持了。对 Mac的支持是该公司多装置策略的第一步，并同时涵盖桌上与行
动平台，像是 iOS跟Android。这个策略也让新的图 形接口架构应运而生，
这个新的架构就称为 FireMonkey 。 
 
朝向行动化  
朝向行动装置，以及 Object Pascal 对ARM芯片版本的编译程序 (所有之前
版本的 Delphi都只支持 Intel x86 的芯片 )已经演变成为整体重新以开放式
LLVM编译程序架构来拟定编译程序架构与相关工具了。对 iOS提出的
ARM编译程序在 Delphi XE4 的时候发表，当时是第一个以 LLVM为基础
的Object Pascal 编译程序，但也是第一次发表了像是自动参考计数
(Automatic Reference Counting ，简称ARC)的功能，以及对字符串型别处理
大量”清除”的功能。  
 
稍后在同一年 (2013)，Delphi XE5 加入了对 Android平台的支持，它也是第
二个以 LLVM为基础的 ARM编译程序。总结一下， Delphi XE5 里面包含
了Object Pascal 语言的六种编译程序 (Win32, Win64, Mac OS X, iOS 仿真
器， iOS ARM ，以及 Android ARM) 。这些编译程序都支持单一语言的共通
定义，当中的差异微乎其微，我已经在前面的篇幅加以介绍过了。  
 
在2014年的前几个月， Embarc adero发布了一个新的开发工具，以相同的
核心行动科技为基础， 称为 Appmethod 。Appmethod 使用之前只能在 Delphi
里面找到的 Object Pascal 编译程序。在 2014年四月， Embarcadero 发布了
Delphi XE6 ，2014年九月则发布了 Appmethod 与Delphi XE7 ，随即在 2015
年春天发布 Delphi XE8 ，当中就包含为了支持 iOS而发展的 ARM 64 位编
译程序。   
 553 b: 词汇表  
 
  A 
 Abstract Class  抽象类  是没有被完整实作，只在接口区段
宣告方法的类别，子类别则需要进
行完整的实作。  
 Ambiguous call  不明确的呼叫  这个错误讯息会发生在编译程序无
法判别我们的程序代码到底要呼叫
哪一个函式的时候。  
 Android  安卓系统  Google为移动装置开发的操作系
统，有数以百计的硬件制造厂商用
以制造装置。  
Andorid 是目前世界上最多装置使
用的操作系统，已超越了微软窗口
系统。  
 Anonymous 
Method  匿名方法  匿名方法，或者匿名函式是没有跟
任何函式名称关连的函式。匿名方
法可以被指派到一个变量，也可以
当成参数传递给另一个函 式，让另
一个函式稍后可以执行它。我们可
以把匿名方法想成是跟传统函式不
同的一个小魔法。而它的确也是个
魔法。这个实际存在的魔法是可以
从区块中存取变量，即使程序已经
执行到别的程序区块也可以喔。  
 API 应用程序编程
接口  API是由软件 (像是操作系统 )所提
供，让应用程序开发人员可以用来
制作某些功能。例如，当应用程序
在屏幕上面显示一行文字的时候，
通常他就是呼叫了在计算机中图形
接口的函式。这一类由计算机的图
形接口所提供的函式称为图形接口
的API。 
  
 554 通常当软件为程序语言提供 API，
该软件就是把一些功能写在里头
了。举例来说，微软窗口操作系统
提供了一个 API给C跟C++语言使
用 
 
笔记  Object Pascal 的Windows 单元   
     文件提供了 Object Pascal 语言
呼 
     叫微软窗口系统的功能， 平息  
     了直接呼叫以 C或C++写成
的 
     函式的争论。  
  B 
 Boolean 
Expression  布尔表达式  布尔表达式，就是结果会是 True或
False的表达式，例如 (1=2)，这个表
达式的结果就会是 False。布尔表达
式的内容不用非得是传统的数学运
算内容，它可以是一个单纯的布尔
型别的变量，甚至也可以是一个回
传布尔值的函数。  
  C 
 Cardinal  长整数  Cardinal 是Object Pascal 里面用来
表示自然数的一种型别，可以储存
0或大于 0的整数，其范围是 0到
232-1。 
 Class  类别  类别是对象的定义，对象可以用有
方法 (method)、属性 (Property) 与数
据字段 (data field) ，类别纯粹只是定
义，并不能被当成变量使用。  
 
笔记  并不是所有面向对象程序语
言 
     都需要先定义类别才能产生
物 
     件。像是 JavaScript 、IO跟 
 555 Rebol 
     这三种语言的对象， 都可以直  
     接定义，不用先定义类别。  
 
笔记  记录的定义跟类别的定义方  
     式，在 Object Pascal 里面是很   
     像的。 在记录里面也可以拥有  
     函式， 使用时必须完整的把记  
     录名称与函式名称完整写上，  
     这个特性与类别里面的方法
几 
     乎是完全相同的。  
 Code Point  字码  字码就是在 Unicode 里面用来表示
每个字符的数字表示值。每个全世
界文字的字符、符号都有一个
Unicode的字码用以表示。  
 Compiler 
Directive  编译程序设定  编译程序设定是编译程序的特殊指
令，编译程序有其标准规则。所有
的编译程序设定会是一个特别的
字，前面以 $符号开头，也可以透过
项目选项来设定。  
 Components  组件  组件是预先建置、已经可以使用的
程序对象，我们可以很容易的把应
用程序跟组件组合起来，节省下来
的开发时间，可是很惊人的。  
 COM  组件对象模型  COM是微软窗口架构的一部分。  
 Control  控制组件  控制组件是图形接口 (GUI)的一部
分，例如按钮、文字输入框、图片
容器等等，控制组件通 常也是视觉
组件。  
 CPU  中央处理单元  CPU是Central Processing Unit 的缩
写，它是所有计算器的核心，也是
实际上执行程序的零件。 Object 
Pascal的程序指令需要被转换成
CPU能够理解的汇编语言。记住，
我们在侦错程序中也有一个 CPU 
View的窗口， 它可不是新功能。 CPU
通常会跟 FPU(浮点数处理单元 )一 
 556 起运作。  
  D 
 Data Type  资料型别  数据型别是数据的专属类型，例如
整数。在 Object Pascal 里面，变量
跟内容 (Value)都会拥有数据。  
 
笔记  数据实际上是存在可执行程  
     式当中，以二进制形式储存  
     的， 实际的储存方法则依照其  
     资料型别而定。  
 
 Design Patterns  设计模式  从不同开发人员用来处理不同问题
的软件架构来看，我们会注意到当
中对共通的问题点处理上会有相似
之处。设计模式就是对于共通的设
计方式，只是大家给这些设计方式
一个共通的名字。并对一些不同的
情形整理出一些抽象的规则。软件
界的设计模式运动，始于 1994年，
由Erich Gamma, Richard Helm, 
Ralph Johnson 与John V lissides所合
着的”Design Patterns, Elements of 
Reusable Object -Oriented Software”
一书 (Addison -Wesley, 1994, 
ISBN:0 -201-633612)。 作者通常会被
简写成 Gamma 等人，或者 4人帮
(Gang of Four) 或GoF。这本书也常
被简称为 GoF book 。 
 
在该书中，作者描述了设计模式的
概念，精确的指出了描述这些模式
的方法，并且提出了 23种模式，分
为三大群组 :生成模式、结构模式、
行为模式。在台湾由台湾培 生教育
出版股份有限公司出版， 叶秉哲译。  
 DLL  动态链接函式
库 动态链接函式库是集结了许多没有
被包含在应用程序执行 文件的韩 
 557 式。当应用程序执行的时候，应用
程序会把函式库加载到内存当中，
之后才能呼叫被包含在该函式库里
面的函式。这些函式库通常是被设
计给很多不同的应用程序使用的。
在窗口程序系统之外，动态链接函
式库则被称为共享对象 (Shared 
Object，简称 SO檔) 
  E 
 Event  事件  类别中一种特别的属性，可以用来
链接对象中一个特别的 ”行为”，当
特定的”事件”发生时，就可以执行
被连结的行为。事 件已经成为快速
开发模式的一部分。  
  F 
 FireMonkey  FireMonkey  FireMonkey( 现在官方也称之为 FM
平台 )或FMX，是一组视觉与非可
视化组件，这个平台同时支持
Appmethod 和Delphi，整组平台的
组件是跨平台的，所以这些组件可
以同时在 Windows, Android, OS X, 
iOS这几个平台上面以同样的方式
运作。  
 Form  窗体  窗体是在 VCL跟FireMonkey 平台
上的窗口。  
 File System  文件系统  文件系统是计算机操作系统的一部
分，这个系 统会组织数据储存在计
算机上的方式，并管理数据储存与
取得的方法。  
 FPU 浮点数运算单
元 FPU是Floating Point Unit 的缩写，
这个单元的功能是纯粹在处理浮点
数的运算，就像 CPU纯粹在执行指
令一样，由于浮点数运算由 FPU专
们执行，也就使 CPU的执行速度能
够得到大幅提升。  
 Function  函式  函式是程序代码的区块，在 Object  
 558 Pascal里面的函式会回传执行的结
果，呼叫函式时，可以依照预先定
义好的型别来进行参数的传递。  
 Function 
Overloading  函式多载  函式多载是面向对象程序语言的功
能之一，在 Object Pascal 里面限定
这个功能必须要以不同的参数个数
或型别加以区隔。  
  G 
 Global Memory  全局内存  全局内存是一个静态的内存区域，
供应用程序的全局变量使用。这个
区域的内存的生命周期是从应用程
序从启动到结束为止，且这个区域
无法扩充 (跟Heap内存，以及动态
配置内存相较 )。全局内存在 Object 
Pascal里面的使用是相当保守的。  
 GUI 用户图形接口  用户图形接口可以让用户在计算
机、平板以及手机上透过图形化的
图标以及其他可视化的指示讯 息进
行操作。大多数用户是透过使用鼠
标或手指 (或其他指针设备 )来执行
点击、触碰、按压、手指滑动以及
其他手势进行互动操作的。  
  H 
 Heap Memory  Heap (有人翻
成『堆』 ，但我
习惯不翻译，
直接念ㄏㄧ P) Heap是让动态配置动作使用的内
存区块， 就如 Heap这个英文字的字
面意思，在这里面的内存没有结构
或顺序。每当一个区块被需要的时
候，系统就会从这一块内存里面找
出还没有被使用到的区块提供程序
代码使用。每个独立的区块的生命
周期都不同，而配置与释放的动作
之间也没有绝对必然成对的顺序。
Heap可以用来 储存对象的数据、字
符串、动态数组或其他参考型别 (请
见Reference) ， 以及其他手动配置的
区块 (请见 Pointers)。Heap的区块很 
 559 大，但并不是无限的，且如果我们
没有把用过的对象从内存里面释放
掉，应用程序最后就会把所有内存
都用光。  
  I 
 IDE 整合开发环境  IDE是 Integrated Development 
Environment 的缩写，也就是整合开
发环境的意思。通常是在一个应用
程序中，提供给开发人员许多开发
跟侦错的功能，让开发的过程能提
高生产力。 IDE的最低限度，至少
要提供一个程序代码编 辑器、自动
化编译工具以及侦错程序。 IDE的
现代含义可以说是由 Borland Turbo 
Pascal所发明的，它也是目前
Embarcadero 所提供的 Object Pascal 
IDE的前身。  
 
Object Pascal IDE 支持 Delphi和
Appmethod ，IDE的功能非常丰富，
并包含了图形接口设计、程序代码
模版、程序代码重购 (refactoring) 以
及整合的单元测试功能等。  
 Inheritance  继承  型别继承是面向对象程序设计的核
心概念之一。原始的概念是让一个
数据型别能够从一个既存的数 据型
别进行延伸，并为既存的数据型别
进行功能扩充。这样的扩充就被称
为型别继承，也常和基础类别、前
代类别，以及祖先类别、子类别等
名词一起被提及。  
 Interface  界面  通常是参考到一个软件模块能够具
备的功能所进行的抽象宣告。在
Object Pascal 里面， 接口是纯粹的抽
象类定义 (当中只宣告方法，不含到
任何数据的定义 )，像是 C#或Java，
请参考本书第 11章。   
 560  
然而， Object Pascal 也仍旧在单元文
件里面引入了接口的概念，在单元
文件的 interface 区段所宣告的类别
跟方法可以被其他使用这个单 元文
件的程序代码所看到， interface 这
个关键词也会在单元文件里面被用
上。  
 iOS iOS (不翻译 ) 这是由 Apple提供的操作系统，在
Apple的iPod, iPhone, iPad, Apple 
TV上面都有使用到。  
  M 
 Method  方法  方法就是与对象绑定的方法或程
序。方法可以存取该对象当中的所
有数据。  
  O 
 Object  物件  对象是许多数据项 (属性或数据字
段)与程序代码 (方法 )的组合。对象
是类别的实体，类别则是对象的定
义。  
 OOP  面向对象式程
序设计  面向对象式程 序设计是 Object 
Pascal背后的概念性结构，奠基于
类别、继承、多型 (polymorphism)
等概念。现代的 Object Pascal 也支
持其他程序的概念，感谢泛型、匿
名方法与镜设 (reflection) 。 
 Ordinal Type  有序型别  有序型别是指该型别面的的数据是
有顺序概念的。我们可以想到整数
是有顺序的，字符也是，甚至我们
也可以自定列举型别。  
 OS X  OS X  这是 Apple麦金塔计算机的操作系
统的名称，从 2000年开始，进入
10.0之后，就都通称为 OS X了， X
是罗马数字 10的意思。  
     
 561   P 
 Pointer  指标  指针是直接储存内存地址的一个变
量。指针可以储存一个数据或者方
法的地址。指标并不常用到，因为
参考渐渐无法被直接使用，而受管
理的指标也渐渐常被用到了，但指
标仍旧很容易使用。  
 Polymorphism  多型  多型是指呼叫一个方法的时候，可
以使用不同的形式加以呼叫 (例如
在不同的操作系统中 )，端看该对象
是否有提供此方法， 这是 OOP程序
语言的标准特点之一。  
 Procedure  程序  程序跟函式一样，都是程序代码区
块，在其他程序中也常被称为子程
序，跟函式不同的 地方，是程序不
会回传任何执行结果。  
 Project Option  项目设定  一整组针对应用程序项目的设定
值，也会影响编译程序跟链接程序
的行为。  
 Property  属性  属性是对象的抽象数据项，它可以
直接对应数据字段，也可以透过方
法来对属性的内容进行读写。  
  R 
 RAD  快速应用程序
开发  快速应用程序开发，是开发环境的
一个特征，透过这样的工具，会让
我们开发应用程序的时候更快、更
容易。 RAD工具通常具备视觉设计
程序，虽然视觉设计工具已经相对
的比较旧，且今日不一定还常被使
用到。  
 Record  记录  简单的纪录就是许多数据项的集
合， 储存的方式具备结构化的特征。
记录可以定义成型别，依序来显示
记录中单独的数据项。  
 
Object Pascal 也提供了进阶的纪录 
 562 功能，让记录像对象一样可以包含
方法。  
 Recursion  递归  递归或者递归调用是子程序写作的
一种方式，让一个子程序可以呼叫
自己，或者让两个子程序可以彼此
呼叫。递归调用通常是循环的替代
方案。  
 Reference  参考  参考是一个变量，可以直接餐靠内
存里面的某些数据，而不直接储存
这些数据。在 Object Pascal 中，某
些型别，像是类别或 字符串，以及
接口、动态数组，都是参考。跟指
标(请见 Pointer)不同的是，参考通
常是由编译程序跟运行时间函式库
管理的，开发人员也需要一些低阶
的相关知识跟直接存取内存的相关
知识。  
 RTTI ( 或
Reflection)  执行时期型别
信息，还是简
称RTTI  Run-Time Type Information 的缩写，
是在实际的应用程序中存取型别信
息的能力 (这能力传统上只有编译
程序才拥有 )。其他的程序开发环境
则把这个功能称之为镜设
(Reflection)  
 Run-Time 
Library (RTL)  执行时期函式
库，仍简称
RTL 预先写好的程序代码的集合，编译
程序会自动把这些程序代码跟应用
程序组合成执行文件。他包含了很
多基础的处理，尤其当成是执行时
需要与操作系统进行互动的程序
(例如配置内存、读写数据、与文件
系统的互动等 ) 
  S 
 SDK  软件开发工具
包 软件开发工具包是一整组的软件工
具，透过 SDK，我们可以在特定的
环境中提供软件功能。一个很直觉
的例子，是 Android SDK 提供了软
件API函式库与开发工具，我们可
以透过它来为 Android 应用程序提 
 563 供建立、测试、侦错等程序。  
 
笔记  Object P ascal跟FireMonkey  
     平台提供了许多单元文件， 让
我 
     们可以透过 Android函式库使  
     用许多功能， 而 IDE则处理建  
     置、测试、侦错等许多功能。  
 
 Search Path  搜寻路径  编译程序会在该路径，以及其下的
所有子目录寻找程序所使用到的外
部单元文件。  
 Stack (memory)  内存堆栈  内存堆栈是动态、依序配置的内存
区域。每当我们呼叫一个方法、程
序或函式的时候，内存堆栈就会把
它自己的内存区域 (包含局部变量、
暂时变量与参数等 )进行保留。当子
程序结束，这些内存就会被清除，
这个作法非常有规范。会把内存堆
栈用光的唯一情境，是一个方法进
入了无穷递归的情形。  
 
笔记  在大多数的情形下， 在堆栈中  
     配置的局部变量都没有被初  
     始化成 0：我们应该在使用前  
     先对这些动态配置的变量进  
     行初始化。  
 
  U 
 Unicode  万国码 (本书
中我仍称之为
Unicode)  Unicode 已经是用来以二进制 (一堆
0与1的组合 )标示每个独立文字的
标准方法。文字在不同的程序之间
进行交换的时候因此提升了可靠
度。这个标准当中涵盖了超过
110,000个不同的字符，包含了 100
种以上的手写文字。   
 564   V 
 VCL  视觉组件函式
库 VCL是Visual Component Library 的
缩写，也就是视觉组件函式库的意
思，这个架构支持 Delphi，也在
Delphi当中被大量使用。当中的用
户 图 形 接 口 组 件 都 是 原 生 的
Windows 用户图形接口组件。  
 Virtual Methods  虚拟方法  虚拟方法是当我们在宣告类别的时
候，宣告的函式或者程序，这些含
识货程序可以被该类别的子类别加
以重载 (override) 。基础类别中也可
以包含该方法的一些实作，这些 实
作的程序代码也会在子类别当中被
使用到。如果基础类别没有实作该
方法的预设版本，任何子类别就都
必须要定义虚拟方法的实作。  
    
  W 
 Window  窗口  窗口指的是屏幕上包含有用户图形
接口元素的区域，用户可以跟这些
元素互动。用户图形接口应用程序
可以拥有多重窗口。在 VCL跟
FireMonkey 当中，窗口就是透过窗
体来定义的。  
 Windows  窗口系统  这是微软的操作系统名称，它是图
形窗口概念的先驱 (当时还有 Apple
的Mac操作系统，以及其他几个图
形化接口的操作系统 )之一。  
 
 
 
 
 